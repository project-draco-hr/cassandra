{
  CFMetaData cfm=Schema.instance.getCFMetaData(keyspace(),columnFamily()).copy();
  IndexTarget target=rawTarget.prepare(cfm);
  ColumnDefinition cd=cfm.getColumnDefinition(target.column);
  String acceptedName=indexName;
  if (Strings.isNullOrEmpty(acceptedName))   acceptedName=Indexes.getAvailableIndexName(keyspace(),columnFamily(),cd.name);
  for (  IndexMetadata existing : cfm.getIndexes())   if (existing.indexedColumn(cfm).equals(cd) || existing.name.equals(acceptedName))   if (ifNotExists)   return false;
 else   throw new InvalidRequestException("Index already exists");
  IndexMetadata.IndexType indexType;
  Map<String,String> indexOptions;
  if (properties.isCustom) {
    indexType=IndexMetadata.IndexType.CUSTOM;
    indexOptions=properties.getOptions();
  }
 else   if (cfm.isCompound()) {
    Map<String,String> options=Collections.emptyMap();
    if (cd.type.isCollection() && cd.type.isMultiCell())     options=ImmutableMap.of(target.type.indexOption(),"");
    indexType=IndexMetadata.IndexType.COMPOSITES;
    indexOptions=options;
  }
 else {
    indexType=IndexMetadata.IndexType.KEYS;
    indexOptions=Collections.emptyMap();
  }
  logger.debug("Updating index definition for {}",indexName);
  IndexMetadata index=IndexMetadata.legacyIndex(cd,acceptedName,indexType,indexOptions);
  cfm.indexes(cfm.getIndexes().with(index));
  MigrationManager.announceColumnFamilyUpdate(cfm,false,isLocalOnly);
  return true;
}
