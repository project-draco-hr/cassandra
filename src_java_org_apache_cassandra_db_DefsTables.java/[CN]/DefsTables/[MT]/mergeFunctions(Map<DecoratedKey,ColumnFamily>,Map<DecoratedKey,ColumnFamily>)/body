{
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(old,updated);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
    ColumnFamily cfFunctions=entry.getValue();
    if (!cfFunctions.hasColumns())     continue;
    for (    UDFunction udf : UDFunction.fromSchema(new Row(entry.getKey(),cfFunctions)).values())     addFunction(udf);
  }
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> modifiedEntry : diff.entriesDiffering().entrySet()) {
    DecoratedKey namespace=modifiedEntry.getKey();
    ColumnFamily prevCFFunctions=modifiedEntry.getValue().leftValue();
    ColumnFamily newCFFunctions=modifiedEntry.getValue().rightValue();
    if (!prevCFFunctions.hasColumns()) {
      for (      UDFunction udf : UDFunction.fromSchema(new Row(namespace,newCFFunctions)).values())       addFunction(udf);
    }
 else     if (!newCFFunctions.hasColumns()) {
      for (      UDFunction udf : UDFunction.fromSchema(new Row(namespace,prevCFFunctions)).values())       dropFunction(udf);
    }
 else {
      MapDifference<ByteBuffer,UDFunction> functionsDiff=Maps.difference(UDFunction.fromSchema(new Row(namespace,prevCFFunctions)),UDFunction.fromSchema(new Row(namespace,newCFFunctions)));
      for (      UDFunction udf : functionsDiff.entriesOnlyOnRight().values())       addFunction(udf);
      for (      UDFunction udf : functionsDiff.entriesOnlyOnLeft().values())       dropFunction(udf);
      for (      MapDifference.ValueDifference<UDFunction> tdiff : functionsDiff.entriesDiffering().values())       updateFunction(tdiff.rightValue());
    }
  }
}
