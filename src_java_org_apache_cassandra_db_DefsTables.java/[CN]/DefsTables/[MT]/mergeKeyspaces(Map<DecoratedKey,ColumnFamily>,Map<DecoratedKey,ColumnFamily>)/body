{
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(old,updated);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
    ColumnFamily ksAttrs=entry.getValue();
    if (ksAttrs.hasColumns())     addKeyspace(KSMetaData.fromSchema(new Row(entry.getKey(),entry.getValue()),Collections.<CFMetaData>emptyList(),new UTMetaData()));
  }
  Map<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> modifiedEntries=diff.entriesDiffering();
  List<DecoratedKey> leftToProcess=new ArrayList<DecoratedKey>(modifiedEntries.size());
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> entry : modifiedEntries.entrySet()) {
    ColumnFamily prevValue=entry.getValue().leftValue();
    ColumnFamily newValue=entry.getValue().rightValue();
    if (!prevValue.hasColumns()) {
      addKeyspace(KSMetaData.fromSchema(new Row(entry.getKey(),newValue),Collections.<CFMetaData>emptyList(),new UTMetaData()));
      continue;
    }
    leftToProcess.add(entry.getKey());
  }
  if (leftToProcess.size() == 0)   return Collections.emptySet();
  Set<String> keyspacesToDrop=new HashSet<String>();
  for (  DecoratedKey key : leftToProcess) {
    MapDifference.ValueDifference<ColumnFamily> valueDiff=modifiedEntries.get(key);
    ColumnFamily newState=valueDiff.rightValue();
    if (newState.hasColumns())     updateKeyspace(KSMetaData.fromSchema(new Row(key,newState),Collections.<CFMetaData>emptyList(),new UTMetaData()));
 else     keyspacesToDrop.add(AsciiType.instance.getString(key.key));
  }
  return keyspacesToDrop;
}
