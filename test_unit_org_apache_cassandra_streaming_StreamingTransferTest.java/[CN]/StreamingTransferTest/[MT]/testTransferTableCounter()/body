{
  final Keyspace keyspace=Keyspace.open("Keyspace1");
  final ColumnFamilyStore cfs=keyspace.getColumnFamilyStore("Counter1");
  final CounterContext cc=new CounterContext();
  final Map<String,ColumnFamily> cleanedEntries=new HashMap<>();
  List<String> keys=createAndTransfer(cfs,new Mutator(){
    /** 
 * Creates a new SSTable per key: all will be merged before streaming. 
 */
    public void mutate(    String key,    String col,    long timestamp) throws Exception {
      Map<String,ColumnFamily> entries=new HashMap<>();
      ColumnFamily cf=TreeMapBackedSortedColumns.factory.create(cfs.metadata);
      ColumnFamily cfCleaned=TreeMapBackedSortedColumns.factory.create(cfs.metadata);
      CounterContext.ContextState state=CounterContext.ContextState.allocate(0,1,3,HeapAllocator.instance);
      state.writeLocal(CounterId.fromInt(2),9L,3L);
      state.writeRemote(CounterId.fromInt(4),4L,2L);
      state.writeRemote(CounterId.fromInt(6),3L,3L);
      state.writeRemote(CounterId.fromInt(8),2L,4L);
      cf.addColumn(new CounterColumn(ByteBufferUtil.bytes(col),state.context,timestamp));
      cfCleaned.addColumn(new CounterColumn(ByteBufferUtil.bytes(col),cc.clearAllLocal(state.context),timestamp));
      entries.put(key,cf);
      cleanedEntries.put(key,cfCleaned);
      cfs.addSSTable(SSTableUtils.prepare().ks(keyspace.getName()).cf(cfs.name).generation(0).write(entries));
    }
  }
,true);
  cleanedEntries.keySet().retainAll(keys);
  SSTableReader cleaned=SSTableUtils.prepare().ks(keyspace.getName()).cf(cfs.name).generation(0).write(cleanedEntries);
  SSTableReader streamed=cfs.getSSTables().iterator().next();
  SSTableUtils.assertContentEquals(cleaned,streamed);
  cfs.clearUnsafe();
  transferSSTables(streamed);
  SSTableReader restreamed=cfs.getSSTables().iterator().next();
  SSTableUtils.assertContentEquals(streamed,restreamed);
}
