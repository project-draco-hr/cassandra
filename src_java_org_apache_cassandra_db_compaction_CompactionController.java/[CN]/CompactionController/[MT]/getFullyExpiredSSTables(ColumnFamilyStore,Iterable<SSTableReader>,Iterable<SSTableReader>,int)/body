{
  logger.trace("Checking droppable sstables in {}",cfStore);
  if (compacting == null)   return Collections.<SSTableReader>emptySet();
  List<SSTableReader> candidates=new ArrayList<>();
  long minTimestamp=Long.MAX_VALUE;
  for (  SSTableReader sstable : overlapping) {
    if (sstable.getSSTableMetadata().maxLocalDeletionTime >= gcBefore)     minTimestamp=Math.min(minTimestamp,sstable.getMinTimestamp());
  }
  for (  SSTableReader candidate : compacting) {
    if (candidate.getSSTableMetadata().maxLocalDeletionTime < gcBefore)     candidates.add(candidate);
 else     minTimestamp=Math.min(minTimestamp,candidate.getMinTimestamp());
  }
  Iterator<SSTableReader> iterator=candidates.iterator();
  while (iterator.hasNext()) {
    SSTableReader candidate=iterator.next();
    if (candidate.getMaxTimestamp() >= minTimestamp) {
      iterator.remove();
    }
 else {
      logger.trace("Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})",candidate,candidate.getSSTableMetadata().maxLocalDeletionTime,gcBefore);
    }
  }
  return new HashSet<>(candidates);
}
