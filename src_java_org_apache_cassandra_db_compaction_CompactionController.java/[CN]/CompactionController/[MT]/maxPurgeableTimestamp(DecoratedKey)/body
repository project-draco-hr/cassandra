{
  if (!compactingRepaired())   return Long.MIN_VALUE;
  long min=Long.MAX_VALUE;
  overlapIterator.update(key);
  for (  SSTableReader sstable : overlapIterator.overlaps()) {
    if (sstable.getBloomFilter() instanceof AlwaysPresentFilter && sstable.getPosition(key,SSTableReader.Operator.EQ,false) != null)     min=Math.min(min,sstable.getMinTimestamp());
 else     if (sstable.getBloomFilter().isPresent(key))     min=Math.min(min,sstable.getMinTimestamp());
  }
  return min;
}
