{
switch (state) {
case ABORTED:
    return;
case FINISHED:
  throw new IllegalStateException("Cannot abort - changes have already been committed");
}
state=State.ABORTED;
Throwable fail=null;
try {
moveStarts(null,null,true);
}
 catch (Throwable t) {
fail=merge(fail,t);
}
for (SSTableReader sstable : finished) {
try {
  sstable.markObsolete(dataTracker);
  sstable.selfRef().release();
}
 catch (Throwable t) {
  fail=merge(fail,t);
}
}
if (writer != null) finishedEarly.add(new Finished(writer,currentlyOpenedEarly));
for (Finished finished : finishedEarly) {
try {
  finished.writer.abort();
}
 catch (Throwable t) {
  fail=merge(fail,t);
}
try {
  if (finished.reader != null) {
    discard.add(finished.reader);
    finished.reader.markObsolete(dataTracker);
  }
}
 catch (Throwable t) {
  fail=merge(fail,t);
}
}
try {
replaceWithFinishedReaders(Collections.<SSTableReader>emptyList());
}
 catch (Throwable t) {
fail=merge(fail,t);
}
if (fail != null) throw Throwables.propagate(fail);
}
