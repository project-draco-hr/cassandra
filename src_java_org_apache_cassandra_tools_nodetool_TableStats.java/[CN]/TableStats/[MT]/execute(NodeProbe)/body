{
  TableStats.OptionFilter filter=new OptionFilter(ignore,tableNames);
  ArrayListMultimap<String,ColumnFamilyStoreMBean> selectedTableMbeans=ArrayListMultimap.create();
  Map<String,KeyspaceStats> keyspaceStats=new HashMap<>();
  Iterator<Map.Entry<String,ColumnFamilyStoreMBean>> tableMBeans=probe.getColumnFamilyStoreMBeanProxies();
  while (tableMBeans.hasNext()) {
    Map.Entry<String,ColumnFamilyStoreMBean> entry=tableMBeans.next();
    String keyspaceName=entry.getKey();
    ColumnFamilyStoreMBean tableProxy=entry.getValue();
    if (filter.isKeyspaceIncluded(keyspaceName)) {
      KeyspaceStats stats=keyspaceStats.get(keyspaceName);
      if (stats == null) {
        stats=new KeyspaceStats(probe,keyspaceName);
        keyspaceStats.put(keyspaceName,stats);
      }
      stats.add(tableProxy);
      if (filter.isTableIncluded(keyspaceName,tableProxy.getTableName()))       selectedTableMbeans.put(keyspaceName,tableProxy);
    }
  }
  filter.verifyKeyspaces(probe.getKeyspaces());
  filter.verifyTables();
  for (  Map.Entry<String,Collection<ColumnFamilyStoreMBean>> entry : selectedTableMbeans.asMap().entrySet()) {
    String keyspaceName=entry.getKey();
    Collection<ColumnFamilyStoreMBean> tables=entry.getValue();
    System.out.println("Keyspace: " + keyspaceName);
    KeyspaceStats stats=keyspaceStats.get(keyspaceName);
    System.out.println("\tRead Count: " + stats.readCount);
    System.out.println("\tRead Latency: " + String.format("%s",stats.readLatency()) + " ms.");
    System.out.println("\tWrite Count: " + stats.writeCount);
    System.out.println("\tWrite Latency: " + String.format("%s",stats.writeLatency()) + " ms.");
    System.out.println("\tPending Flushes: " + stats.pendingFlushes);
    for (    ColumnFamilyStoreMBean table : tables) {
      String tableName=table.getTableName();
      if (tableName.contains("."))       System.out.println("\t\tTable (index): " + tableName);
 else       System.out.println("\t\tTable: " + tableName);
      System.out.println("\t\tSSTable count: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"LiveSSTableCount"));
      int[] leveledSStables=table.getSSTableCountPerLevel();
      if (leveledSStables != null) {
        System.out.print("\t\tSSTables in each level: [");
        for (int level=0; level < leveledSStables.length; level++) {
          int count=leveledSStables[level];
          System.out.print(count);
          long maxCount=4L;
          if (level > 0)           maxCount=(long)Math.pow(10,level);
          if (count > maxCount)           System.out.print("/" + maxCount);
          if (level < leveledSStables.length - 1)           System.out.print(", ");
 else           System.out.println("]");
        }
      }
      Long memtableOffHeapSize=null;
      Long bloomFilterOffHeapSize=null;
      Long indexSummaryOffHeapSize=null;
      Long compressionMetadataOffHeapSize=null;
      Long offHeapSize=null;
      try {
        memtableOffHeapSize=(Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"MemtableOffHeapSize");
        bloomFilterOffHeapSize=(Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"BloomFilterOffHeapMemoryUsed");
        indexSummaryOffHeapSize=(Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"IndexSummaryOffHeapMemoryUsed");
        compressionMetadataOffHeapSize=(Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"CompressionMetadataOffHeapMemoryUsed");
        offHeapSize=memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize+ compressionMetadataOffHeapSize;
      }
 catch (      RuntimeException e) {
        if (!(e.getCause() instanceof InstanceNotFoundException))         throw e;
      }
      System.out.println("\t\tSpace used (live): " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"LiveDiskSpaceUsed"),humanReadable));
      System.out.println("\t\tSpace used (total): " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"TotalDiskSpaceUsed"),humanReadable));
      System.out.println("\t\tSpace used by snapshots (total): " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"SnapshotsSize"),humanReadable));
      if (offHeapSize != null)       System.out.println("\t\tOff heap memory used (total): " + format(offHeapSize,humanReadable));
      System.out.println("\t\tSSTable Compression Ratio: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"CompressionRatio"));
      System.out.println("\t\tNumber of keys (estimate): " + probe.getColumnFamilyMetric(keyspaceName,tableName,"EstimatedPartitionCount"));
      System.out.println("\t\tMemtable cell count: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"MemtableColumnsCount"));
      System.out.println("\t\tMemtable data size: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"MemtableLiveDataSize"),humanReadable));
      if (memtableOffHeapSize != null)       System.out.println("\t\tMemtable off heap memory used: " + format(memtableOffHeapSize,humanReadable));
      System.out.println("\t\tMemtable switch count: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"MemtableSwitchCount"));
      System.out.println("\t\tLocal read count: " + ((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"ReadLatency")).getCount());
      double localReadLatency=((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"ReadLatency")).getMean() / 1000;
      double localRLatency=localReadLatency > 0 ? localReadLatency : Double.NaN;
      System.out.printf("\t\tLocal read latency: %01.3f ms%n",localRLatency);
      System.out.println("\t\tLocal write count: " + ((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"WriteLatency")).getCount());
      double localWriteLatency=((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"WriteLatency")).getMean() / 1000;
      double localWLatency=localWriteLatency > 0 ? localWriteLatency : Double.NaN;
      System.out.printf("\t\tLocal write latency: %01.3f ms%n",localWLatency);
      System.out.println("\t\tPending flushes: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"PendingFlushes"));
      System.out.println("\t\tBloom filter false positives: " + probe.getColumnFamilyMetric(keyspaceName,tableName,"BloomFilterFalsePositives"));
      System.out.printf("\t\tBloom filter false ratio: %s%n",String.format("%01.5f",probe.getColumnFamilyMetric(keyspaceName,tableName,"RecentBloomFilterFalseRatio")));
      System.out.println("\t\tBloom filter space used: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"BloomFilterDiskSpaceUsed"),humanReadable));
      if (bloomFilterOffHeapSize != null)       System.out.println("\t\tBloom filter off heap memory used: " + format(bloomFilterOffHeapSize,humanReadable));
      if (indexSummaryOffHeapSize != null)       System.out.println("\t\tIndex summary off heap memory used: " + format(indexSummaryOffHeapSize,humanReadable));
      if (compressionMetadataOffHeapSize != null)       System.out.println("\t\tCompression metadata off heap memory used: " + format(compressionMetadataOffHeapSize,humanReadable));
      System.out.println("\t\tCompacted partition minimum bytes: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"MinPartitionSize"),humanReadable));
      System.out.println("\t\tCompacted partition maximum bytes: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"MaxPartitionSize"),humanReadable));
      System.out.println("\t\tCompacted partition mean bytes: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"MeanPartitionSize"),humanReadable));
      CassandraMetricsRegistry.JmxHistogramMBean histogram=(CassandraMetricsRegistry.JmxHistogramMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"LiveScannedHistogram");
      System.out.println("\t\tAverage live cells per slice (last five minutes): " + histogram.getMean());
      System.out.println("\t\tMaximum live cells per slice (last five minutes): " + histogram.getMax());
      histogram=(CassandraMetricsRegistry.JmxHistogramMBean)probe.getColumnFamilyMetric(keyspaceName,tableName,"TombstoneScannedHistogram");
      System.out.println("\t\tAverage tombstones per slice (last five minutes): " + histogram.getMean());
      System.out.println("\t\tMaximum tombstones per slice (last five minutes): " + histogram.getMax());
      System.out.println("\t\tDropped Mutations: " + format((Long)probe.getColumnFamilyMetric(keyspaceName,tableName,"DroppedMutations"),humanReadable));
      System.out.println("");
    }
    System.out.println("----------------");
  }
}
