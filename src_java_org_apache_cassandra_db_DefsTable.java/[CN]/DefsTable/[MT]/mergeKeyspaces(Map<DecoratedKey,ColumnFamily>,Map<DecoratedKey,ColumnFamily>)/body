{
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(old,updated);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
    ColumnFamily ksAttrs=entry.getValue();
    if (!ksAttrs.isEmpty())     MigrationHelper.addKeyspace(KSMetaData.fromSchema(entry.getValue(),null));
  }
  Map<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> modifiedEntries=diff.entriesDiffering();
  List<DecoratedKey> leftToProcess=new ArrayList<DecoratedKey>();
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> entry : modifiedEntries.entrySet()) {
    ColumnFamily prevValue=entry.getValue().leftValue();
    ColumnFamily newValue=entry.getValue().rightValue();
    if (prevValue.isEmpty()) {
      MigrationHelper.addKeyspace(KSMetaData.fromSchema(newValue,null));
      continue;
    }
    leftToProcess.add(entry.getKey());
  }
  if (leftToProcess.size() == 0)   return Collections.emptySet();
  Set<String> keyspacesToDrop=new HashSet<String>();
  for (  DecoratedKey key : leftToProcess) {
    MapDifference.ValueDifference<ColumnFamily> valueDiff=modifiedEntries.get(key);
    ColumnFamily newState=valueDiff.rightValue();
    if (newState.isEmpty())     keyspacesToDrop.add(AsciiType.instance.getString(key.key));
 else     MigrationHelper.updateKeyspace(KSMetaData.fromSchema(newState));
  }
  return keyspacesToDrop;
}
