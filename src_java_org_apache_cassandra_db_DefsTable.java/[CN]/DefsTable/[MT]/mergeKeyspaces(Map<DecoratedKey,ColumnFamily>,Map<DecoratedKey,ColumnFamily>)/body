{
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(old,updated);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet()) {
    ColumnFamily ksAttrs=entry.getValue();
    if (!ksAttrs.isEmpty()) {
      KSMetaData ksm=KSMetaData.fromSchema(new Row(entry.getKey(),entry.getValue()),Collections.<CFMetaData>emptyList());
      MigrationHelper.addKeyspace(ksm,-1,false);
    }
  }
  Map<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> modifiedEntries=diff.entriesDiffering();
  List<DecoratedKey> leftToProcess=new ArrayList<DecoratedKey>(modifiedEntries.size());
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> entry : modifiedEntries.entrySet()) {
    ColumnFamily prevValue=entry.getValue().leftValue();
    ColumnFamily newValue=entry.getValue().rightValue();
    if (prevValue.isEmpty()) {
      KSMetaData ksm=KSMetaData.fromSchema(new Row(entry.getKey(),newValue),Collections.<CFMetaData>emptyList());
      MigrationHelper.addKeyspace(ksm,-1,false);
      continue;
    }
    leftToProcess.add(entry.getKey());
  }
  if (leftToProcess.size() == 0)   return Collections.emptySet();
  Set<String> keyspacesToDrop=new HashSet<String>();
  for (  DecoratedKey key : leftToProcess) {
    MapDifference.ValueDifference<ColumnFamily> valueDiff=modifiedEntries.get(key);
    ColumnFamily newState=valueDiff.rightValue();
    if (newState.isEmpty()) {
      keyspacesToDrop.add(AsciiType.instance.getString(key.key));
    }
 else {
      KSMetaData ksm=KSMetaData.fromSchema(new Row(key,newState),Collections.<CFMetaData>emptyList());
      MigrationHelper.updateKeyspace(ksm,-1,false);
    }
  }
  return keyspacesToDrop;
}
