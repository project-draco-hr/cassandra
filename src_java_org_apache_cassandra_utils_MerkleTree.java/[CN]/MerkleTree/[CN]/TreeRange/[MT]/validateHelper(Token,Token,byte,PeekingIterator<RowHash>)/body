{
  if (entries.hasNext() && Range.contains(left,right,entries.peek().token)) {
    if (depth < tree.hashdepth) {
      Token midpoint=tree.partitioner().midpoint(left,right);
      if (left.compareTo(midpoint) < 0 && midpoint.compareTo(right) < 0) {
        byte[] lhash=validateHelper(left,midpoint,inc(depth),entries);
        byte[] rhash=validateHelper(midpoint,right,inc(depth),entries);
        return Hashable.binaryHash(lhash,rhash);
      }
    }
    return consume(left,right,entries);
  }
 else {
    return EMPTIES[tree.hashdepth - depth];
  }
}
