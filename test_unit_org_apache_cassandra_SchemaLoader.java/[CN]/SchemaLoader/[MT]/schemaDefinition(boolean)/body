{
  List<KSMetaData> schema=new ArrayList<KSMetaData>();
  String ks1="Keyspace1";
  String ks2="Keyspace2";
  String ks3="Keyspace3";
  String ks4="Keyspace4";
  String ks5="Keyspace5";
  String ks6="Keyspace6";
  String ks_kcs="KeyCacheSpace";
  String ks_rcs="RowCacheSpace";
  String ks_nocommit="NoCommitlogSpace";
  String ks_prsi="PerRowSecondaryIndex";
  String ks_cql="cql_keyspace";
  Class<? extends AbstractReplicationStrategy> simple=SimpleStrategy.class;
  Map<String,String> opts_rf1=KSMetaData.optsWithRF(1);
  Map<String,String> opts_rf2=KSMetaData.optsWithRF(2);
  Map<String,String> opts_rf3=KSMetaData.optsWithRF(3);
  Map<String,String> opts_rf5=KSMetaData.optsWithRF(5);
  ColumnFamilyType st=ColumnFamilyType.Standard;
  ColumnFamilyType su=ColumnFamilyType.Super;
  AbstractType bytes=BytesType.instance;
  AbstractType<?> composite=CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance,TimeUUIDType.instance,IntegerType.instance}));
  AbstractType<?> compositeMaxMin=CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance,IntegerType.instance}));
  Map<Byte,AbstractType<?>> aliases=new HashMap<Byte,AbstractType<?>>();
  aliases.put((byte)'b',BytesType.instance);
  aliases.put((byte)'t',TimeUUIDType.instance);
  AbstractType<?> dynamicComposite=DynamicCompositeType.getInstance(aliases);
  Map<ByteBuffer,ColumnDefinition> integerColumn=new HashMap<ByteBuffer,ColumnDefinition>();
  integerColumn.put(IntegerType.instance.fromString("42"),ColumnDefinition.regularDef(IntegerType.instance.fromString("42"),UTF8Type.instance,null));
  Map<ByteBuffer,ColumnDefinition> utf8Column=new HashMap<ByteBuffer,ColumnDefinition>();
  utf8Column.put(UTF8Type.instance.fromString("fortytwo"),ColumnDefinition.regularDef(UTF8Type.instance.fromString("fortytwo"),IntegerType.instance,null));
  Map<String,String> compactionOptions=new HashMap<String,String>();
  compactionOptions.put("tombstone_compaction_interval","1");
  Map<String,String> leveledOptions=new HashMap<String,String>();
  leveledOptions.put("sstable_size_in_mb","1");
  schema.add(KSMetaData.testMetadata(ks1,simple,opts_rf1,standardCFMD(ks1,"Standard1").compactionStrategyOptions(compactionOptions),standardCFMD(ks1,"Standard2"),standardCFMD(ks1,"Standard3"),standardCFMD(ks1,"Standard4"),standardCFMD(ks1,"StandardGCGS0").gcGraceSeconds(0),standardCFMD(ks1,"StandardLong1"),standardCFMD(ks1,"StandardLong2"),new CFMetaData(ks1,"ValuesWithQuotes",st,BytesType.instance,null).defaultValidator(UTF8Type.instance),superCFMD(ks1,"Super1",LongType.instance),superCFMD(ks1,"Super2",LongType.instance),superCFMD(ks1,"Super3",LongType.instance),superCFMD(ks1,"Super4",UTF8Type.instance),superCFMD(ks1,"Super5",bytes),superCFMD(ks1,"Super6",LexicalUUIDType.instance,UTF8Type.instance),indexCFMD(ks1,"Indexed1",true),indexCFMD(ks1,"Indexed2",false),new CFMetaData(ks1,"StandardInteger1",st,IntegerType.instance,null),new CFMetaData(ks1,"Counter1",st,bytes,null).defaultValidator(CounterColumnType.instance),new CFMetaData(ks1,"SuperCounter1",su,bytes,bytes).defaultValidator(CounterColumnType.instance),superCFMD(ks1,"SuperDirectGC",BytesType.instance).gcGraceSeconds(0),jdbcCFMD(ks1,"JdbcInteger",IntegerType.instance).columnMetadata(integerColumn),jdbcCFMD(ks1,"JdbcUtf8",UTF8Type.instance).columnMetadata(utf8Column),jdbcCFMD(ks1,"JdbcLong",LongType.instance),jdbcCFMD(ks1,"JdbcBytes",bytes),jdbcCFMD(ks1,"JdbcAscii",AsciiType.instance),new CFMetaData(ks1,"StandardComposite",st,composite,null),new CFMetaData(ks1,"StandardComposite2",st,compositeMaxMin,null),new CFMetaData(ks1,"StandardDynamicComposite",st,dynamicComposite,null),standardCFMD(ks1,"StandardLeveled").compactionStrategyClass(LeveledCompactionStrategy.class).compactionStrategyOptions(leveledOptions),standardCFMD(ks1,"legacyleveled").compactionStrategyClass(LeveledCompactionStrategy.class).compactionStrategyOptions(leveledOptions)));
  schema.add(KSMetaData.testMetadata(ks2,simple,opts_rf1,standardCFMD(ks2,"Standard1"),standardCFMD(ks2,"Standard3"),superCFMD(ks2,"Super3",bytes),superCFMD(ks2,"Super4",TimeUUIDType.instance),indexCFMD(ks2,"Indexed1",true),compositeIndexCFMD(ks2,"Indexed2",true,withOldCfIds),compositeIndexCFMD(ks2,"Indexed3",true,withOldCfIds).gcGraceSeconds(0)));
  schema.add(KSMetaData.testMetadata(ks3,simple,opts_rf5,standardCFMD(ks3,"Standard1"),indexCFMD(ks3,"Indexed1",true)));
  schema.add(KSMetaData.testMetadata(ks4,simple,opts_rf3,standardCFMD(ks4,"Standard1"),standardCFMD(ks4,"Standard3"),superCFMD(ks4,"Super3",bytes),superCFMD(ks4,"Super4",TimeUUIDType.instance),new CFMetaData(ks4,"Super5",su,TimeUUIDType.instance,bytes)));
  schema.add(KSMetaData.testMetadata(ks5,simple,opts_rf2,standardCFMD(ks5,"Standard1"),standardCFMD(ks5,"Counter1").defaultValidator(CounterColumnType.instance)));
  schema.add(KSMetaData.testMetadata(ks6,simple,opts_rf1,indexCFMD(ks6,"Indexed1",true)));
  schema.add(KSMetaData.testMetadata(ks_kcs,simple,opts_rf1,standardCFMD(ks_kcs,"Standard1"),standardCFMD(ks_kcs,"Standard2"),standardCFMD(ks_kcs,"Standard3")));
  schema.add(KSMetaData.testMetadata(ks_rcs,simple,opts_rf1,standardCFMD(ks_rcs,"CFWithoutCache").caching(CFMetaData.Caching.NONE),standardCFMD(ks_rcs,"CachedCF").caching(CFMetaData.Caching.ALL)));
  schema.add(KSMetaData.testMetadataNotDurable(ks_nocommit,simple,opts_rf1,standardCFMD(ks_nocommit,"Standard1")));
  schema.add(KSMetaData.testMetadata(ks_prsi,simple,opts_rf1,perRowIndexedCFMD(ks_prsi,"Indexed1",withOldCfIds)));
  schema.add(KSMetaData.testMetadata(ks_cql,simple,opts_rf1,CFMetaData.compile("CREATE TABLE table1 (" + "k int PRIMARY KEY," + "v1 text,"+ "v2 int"+ ")",ks_cql),CFMetaData.compile("CREATE TABLE table2 (" + "k text," + "c text,"+ "v text,"+ "PRIMARY KEY (k, c))",ks_cql)));
  if (Boolean.parseBoolean(System.getProperty("cassandra.test.compression","false")))   useCompression(schema);
  return schema;
}
