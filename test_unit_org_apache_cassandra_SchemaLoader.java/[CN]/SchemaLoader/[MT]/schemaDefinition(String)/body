{
  List<KSMetaData> schema=new ArrayList<KSMetaData>();
  String ks1=testName + "Keyspace1";
  String ks2=testName + "Keyspace2";
  String ks3=testName + "Keyspace3";
  String ks4=testName + "Keyspace4";
  String ks5=testName + "Keyspace5";
  String ks6=testName + "Keyspace6";
  String ks_kcs=testName + "KeyCacheSpace";
  String ks_rcs=testName + "RowCacheSpace";
  String ks_ccs=testName + "CounterCacheSpace";
  String ks_nocommit=testName + "NoCommitlogSpace";
  String ks_prsi=testName + "PerRowSecondaryIndex";
  String ks_cql=testName + "cql_keyspace";
  Class<? extends AbstractReplicationStrategy> simple=SimpleStrategy.class;
  Map<String,String> opts_rf1=KSMetaData.optsWithRF(1);
  Map<String,String> opts_rf2=KSMetaData.optsWithRF(2);
  Map<String,String> opts_rf3=KSMetaData.optsWithRF(3);
  Map<String,String> opts_rf5=KSMetaData.optsWithRF(5);
  AbstractType bytes=BytesType.instance;
  AbstractType<?> composite=CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance,TimeUUIDType.instance,IntegerType.instance}));
  AbstractType<?> compositeMaxMin=CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance,IntegerType.instance}));
  Map<Byte,AbstractType<?>> aliases=new HashMap<Byte,AbstractType<?>>();
  aliases.put((byte)'b',BytesType.instance);
  aliases.put((byte)'t',TimeUUIDType.instance);
  aliases.put((byte)'B',ReversedType.getInstance(BytesType.instance));
  aliases.put((byte)'T',ReversedType.getInstance(TimeUUIDType.instance));
  AbstractType<?> dynamicComposite=DynamicCompositeType.getInstance(aliases);
  Map<String,String> compactionOptions=new HashMap<String,String>();
  compactionOptions.put("tombstone_compaction_interval","1");
  Map<String,String> leveledOptions=new HashMap<String,String>();
  leveledOptions.put("sstable_size_in_mb","1");
  schema.add(KSMetaData.testMetadata(ks1,simple,opts_rf1,standardCFMD(ks1,"Standard1").compactionStrategyOptions(compactionOptions),standardCFMD(ks1,"Standard2"),standardCFMD(ks1,"Standard3"),standardCFMD(ks1,"Standard4"),standardCFMD(ks1,"StandardGCGS0").gcGraceSeconds(0),standardCFMD(ks1,"StandardLong1"),standardCFMD(ks1,"StandardLong2"),superCFMD(ks1,"Super1",LongType.instance),superCFMD(ks1,"Super2",LongType.instance),superCFMD(ks1,"Super3",LongType.instance),superCFMD(ks1,"Super4",UTF8Type.instance),superCFMD(ks1,"Super5",bytes),superCFMD(ks1,"Super6",LexicalUUIDType.instance,UTF8Type.instance),keysIndexCFMD(ks1,"Indexed1",true),keysIndexCFMD(ks1,"Indexed2",false),superCFMD(ks1,"SuperDirectGC",BytesType.instance).gcGraceSeconds(0),jdbcCFMD(ks1,"JdbcInteger",IntegerType.instance).addColumnDefinition(integerColumn(ks1,"JdbcInteger")),jdbcCFMD(ks1,"JdbcUtf8",UTF8Type.instance).addColumnDefinition(utf8Column(ks1,"JdbcUtf8")),jdbcCFMD(ks1,"JdbcLong",LongType.instance),jdbcCFMD(ks1,"JdbcBytes",bytes),jdbcCFMD(ks1,"JdbcAscii",AsciiType.instance),standardCFMD(ks1,"StandardLeveled").compactionStrategyClass(LeveledCompactionStrategy.class).compactionStrategyOptions(leveledOptions),standardCFMD(ks1,"legacyleveled").compactionStrategyClass(LeveledCompactionStrategy.class).compactionStrategyOptions(leveledOptions),standardCFMD(ks1,"StandardLowIndexInterval").minIndexInterval(8).maxIndexInterval(256).caching(CachingOptions.NONE)));
  schema.add(KSMetaData.testMetadata(ks2,simple,opts_rf1,standardCFMD(ks2,"Standard1"),standardCFMD(ks2,"Standard3"),superCFMD(ks2,"Super3",bytes),superCFMD(ks2,"Super4",TimeUUIDType.instance),keysIndexCFMD(ks2,"Indexed1",true),compositeIndexCFMD(ks2,"Indexed2",true),compositeIndexCFMD(ks2,"Indexed3",true).gcGraceSeconds(0)));
  schema.add(KSMetaData.testMetadata(ks3,simple,opts_rf5,standardCFMD(ks3,"Standard1"),keysIndexCFMD(ks3,"Indexed1",true)));
  schema.add(KSMetaData.testMetadata(ks4,simple,opts_rf3,standardCFMD(ks4,"Standard1"),standardCFMD(ks4,"Standard3"),superCFMD(ks4,"Super3",bytes),superCFMD(ks4,"Super4",TimeUUIDType.instance),superCFMD(ks4,"Super5",TimeUUIDType.instance,BytesType.instance)));
  schema.add(KSMetaData.testMetadata(ks5,simple,opts_rf2,standardCFMD(ks5,"Standard1")));
  schema.add(KSMetaData.testMetadata(ks6,simple,opts_rf1,keysIndexCFMD(ks6,"Indexed1",true)));
  schema.add(KSMetaData.testMetadata(ks_kcs,simple,opts_rf1,standardCFMD(ks_kcs,"Standard1"),standardCFMD(ks_kcs,"Standard2"),standardCFMD(ks_kcs,"Standard3")));
  schema.add(KSMetaData.testMetadata(ks_rcs,simple,opts_rf1,standardCFMD(ks_rcs,"CFWithoutCache").caching(CachingOptions.NONE),standardCFMD(ks_rcs,"CachedCF").caching(CachingOptions.ALL),standardCFMD(ks_rcs,"CachedIntCF").caching(new CachingOptions(new CachingOptions.KeyCache(CachingOptions.KeyCache.Type.ALL),new CachingOptions.RowCache(CachingOptions.RowCache.Type.HEAD,100)))));
  schema.add(KSMetaData.testMetadataNotDurable(ks_nocommit,simple,opts_rf1,standardCFMD(ks_nocommit,"Standard1")));
  schema.add(KSMetaData.testMetadata(ks_prsi,simple,opts_rf1,perRowIndexedCFMD(ks_prsi,"Indexed1")));
  schema.add(KSMetaData.testMetadata(ks_cql,simple,opts_rf1,CFMetaData.compile("CREATE TABLE table1 (" + "k int PRIMARY KEY," + "v1 text,"+ "v2 int"+ ")",ks_cql),CFMetaData.compile("CREATE TABLE table2 (" + "k text," + "c text,"+ "v text,"+ "PRIMARY KEY (k, c))",ks_cql),CFMetaData.compile("CREATE TABLE foo (" + "bar text, " + "baz text, "+ "qux text, "+ "PRIMARY KEY(bar, baz) ) "+ "WITH COMPACT STORAGE",ks_cql),CFMetaData.compile("CREATE TABLE foofoo (" + "bar text, " + "baz text, "+ "qux text, "+ "quz text, "+ "foo text, "+ "PRIMARY KEY((bar, baz), qux, quz) ) "+ "WITH COMPACT STORAGE",ks_cql)));
  if (Boolean.parseBoolean(System.getProperty("cassandra.test.compression","false")))   useCompression(schema);
  for (  KSMetaData ksm : schema)   MigrationManager.announceNewKeyspace(ksm,false);
}
