{
  try {
    boolean isStatic=isStatic(flags);
    boolean hasTimestamp=(flags & HAS_TIMESTAMP) != 0;
    boolean hasTTL=(flags & HAS_TTL) != 0;
    boolean hasDeletion=(flags & HAS_DELETION) != 0;
    boolean hasComplexDeletion=(flags & HAS_COMPLEX_DELETION) != 0;
    boolean hasAllColumns=(flags & HAS_ALL_COLUMNS) != 0;
    Columns headerColumns=header.columns(isStatic);
    LivenessInfo rowLiveness=LivenessInfo.EMPTY;
    if (hasTimestamp) {
      long timestamp=header.readTimestamp(in);
      int ttl=hasTTL ? header.readTTL(in) : LivenessInfo.NO_TTL;
      int localDeletionTime=hasTTL ? header.readLocalDeletionTime(in) : LivenessInfo.NO_EXPIRATION_TIME;
      rowLiveness=LivenessInfo.create(timestamp,ttl,localDeletionTime);
    }
    builder.addPrimaryKeyLivenessInfo(rowLiveness);
    builder.addRowDeletion(hasDeletion ? header.readDeletionTime(in) : DeletionTime.LIVE);
    Columns columns=hasAllColumns ? headerColumns : Columns.serializer.deserializeSubset(headerColumns,in);
    for (    ColumnDefinition column : columns) {
      if (column.isSimple())       readSimpleColumn(column,in,header,helper,builder,rowLiveness);
 else       readComplexColumn(column,in,header,helper,hasComplexDeletion,builder,rowLiveness);
    }
    return builder.build();
  }
 catch (  RuntimeException|AssertionError e) {
    throw new IOException("Error building row with data deserialized from " + in,e);
  }
}
