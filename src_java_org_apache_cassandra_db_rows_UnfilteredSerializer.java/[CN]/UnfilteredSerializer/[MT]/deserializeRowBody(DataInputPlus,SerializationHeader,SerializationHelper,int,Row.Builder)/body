{
  try {
    boolean isStatic=isStatic(flags);
    boolean hasTimestamp=(flags & HAS_TIMESTAMP) != 0;
    boolean hasTTL=(flags & HAS_TTL) != 0;
    boolean hasDeletion=(flags & HAS_DELETION) != 0;
    boolean hasComplexDeletion=(flags & HAS_COMPLEX_DELETION) != 0;
    LivenessInfo rowLiveness=LivenessInfo.EMPTY;
    if (hasTimestamp) {
      long timestamp=header.decodeTimestamp(in.readLong());
      int ttl=hasTTL ? header.decodeTTL(in.readInt()) : LivenessInfo.NO_TTL;
      int localDeletionTime=hasTTL ? header.decodeDeletionTime(in.readInt()) : LivenessInfo.NO_EXPIRATION_TIME;
      rowLiveness=LivenessInfo.create(timestamp,ttl,localDeletionTime);
    }
    builder.addPrimaryKeyLivenessInfo(rowLiveness);
    builder.addRowDeletion(hasDeletion ? UnfilteredRowIteratorSerializer.readDelTime(in,header) : DeletionTime.LIVE);
    Columns columns=header.columns(isStatic);
    if (header.useSparseColumnLayout(isStatic)) {
      int count=columns.columnCount();
      int simpleCount=columns.simpleColumnCount();
      int i;
      while ((i=in.readShort()) >= 0) {
        if (i > count)         throw new IOException(String.format("Impossible column index %d, the header has only %d columns defined",i,count));
        if (i < simpleCount)         readSimpleColumn(columns.getSimple(i),in,header,helper,builder,rowLiveness);
 else         readComplexColumn(columns.getComplex(i - simpleCount),in,header,helper,hasComplexDeletion,builder,rowLiveness);
      }
    }
 else {
      for (int i=0; i < columns.simpleColumnCount(); i++)       readSimpleColumn(columns.getSimple(i),in,header,helper,builder,rowLiveness);
      for (int i=0; i < columns.complexColumnCount(); i++)       readComplexColumn(columns.getComplex(i),in,header,helper,hasComplexDeletion,builder,rowLiveness);
    }
    return builder.build();
  }
 catch (  RuntimeException|AssertionError e) {
    throw new IOException("Error building row with data deserialized from " + in,e);
  }
}
