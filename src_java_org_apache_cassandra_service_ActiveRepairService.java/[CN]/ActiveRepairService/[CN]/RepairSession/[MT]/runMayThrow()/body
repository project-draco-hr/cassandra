{
  logger.info(String.format("[repair #%s] new session: will sync %s on range %s for %s.%s",getName(),repairedNodes(),range,tablename,Arrays.toString(cfnames)));
  if (endpoints.isEmpty()) {
    differencingDone.signalAll();
    logger.info(String.format("[repair #%s] No neighbors to repair with on range %s: session completed",getName(),range));
    return;
  }
  for (  InetAddress endpoint : endpoints) {
    if (!FailureDetector.instance.isAlive(endpoint)) {
      String message=String.format("Cannot proceed on repair because a neighbor (%s) is dead: session failed",endpoint);
      differencingDone.signalAll();
      logger.error(String.format("[repair #%s] ",getName()) + message);
      throw new IOException(message);
    }
    if (!MessagingService.instance().knowsVersion(endpoint) || MessagingService.instance().getVersion(endpoint) != MessagingService.current_version) {
      String message="Cannot repair among different protocol versions";
      differencingDone.signalAll();
      logger.error(String.format("[repair #%s] ",getName()) + message);
      throw new IOException(message);
    }
  }
  ActiveRepairService.instance.sessions.put(getName(),this);
  Gossiper.instance.register(this);
  FailureDetector.instance.registerFailureDetectionEventListener(this);
  try {
    for (    String cfname : cfnames) {
      RepairJob job=new RepairJob(cfname);
      jobs.offer(job);
      activeJobs.put(cfname,job);
    }
    jobs.peek().sendTreeRequests();
    completed.await();
    if (exception == null) {
      logger.info(String.format("[repair #%s] session completed successfully",getName()));
    }
 else {
      logger.error(String.format("[repair #%s] session completed with the following error",getName()),exception);
      throw exception;
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for repair.");
  }
 finally {
    terminate();
    FailureDetector.instance.unregisterFailureDetectionEventListener(this);
    Gossiper.instance.unregister(this);
    ActiveRepairService.instance.sessions.remove(getName());
  }
}
