{
  UUID parentRepairSession=UUIDGen.getTimeUUID();
  registerParentRepairSession(parentRepairSession,columnFamilyStores,ranges);
  final CountDownLatch prepareLatch=new CountDownLatch(endpoints.size());
  final AtomicBoolean status=new AtomicBoolean(true);
  IAsyncCallbackWithFailure callback=new IAsyncCallbackWithFailure(){
    public void response(    MessageIn msg){
      prepareLatch.countDown();
    }
    public boolean isLatencyForSnitch(){
      return false;
    }
    public void onFailure(    InetAddress from){
      status.set(false);
      prepareLatch.countDown();
    }
  }
;
  List<UUID> cfIds=new ArrayList<>(columnFamilyStores.size());
  for (  ColumnFamilyStore cfs : columnFamilyStores)   cfIds.add(cfs.metadata.cfId);
  for (  InetAddress neighbour : endpoints) {
    PrepareMessage message=new PrepareMessage(parentRepairSession,cfIds,ranges);
    MessageOut<RepairMessage> msg=message.createMessage();
    MessagingService.instance().sendRRWithFailure(msg,neighbour,callback);
  }
  try {
    prepareLatch.await(1,TimeUnit.HOURS);
  }
 catch (  InterruptedException e) {
    parentRepairSessions.remove(parentRepairSession);
    throw new RuntimeException("Did not get replies from all endpoints.",e);
  }
  if (!status.get()) {
    parentRepairSessions.remove(parentRepairSession);
    throw new RuntimeException("Did not get positive replies from all endpoints.");
  }
  return parentRepairSession;
}
