{
  StorageService ss=StorageService.instance;
  final int RING_SIZE=3;
  TokenMetadata tmd=ss.getTokenMetadata();
  tmd.clearUnsafe();
  IPartitioner partitioner=new RandomPartitioner();
  ss.setPartitionerUnsafe(partitioner);
  ArrayList<Token> endpointTokens=new ArrayList<Token>();
  ArrayList<Token> keyTokens=new ArrayList<Token>();
  List<InetAddress> hostsInUse=new ArrayList<InetAddress>();
  List<InetAddress> hosts=new ArrayList<InetAddress>();
  Util.createInitialRing(ss,partitioner,endpointTokens,keyTokens,hosts,RING_SIZE);
  AbstractReplicationStrategy strategy;
  for (  final String table : Schema.instance.getNonSystemTables()) {
    strategy=getStrategy(table,tmd);
    StorageService.calculatePendingRanges(strategy,table);
    int replicationFactor=strategy.getReplicationFactor();
    if (replicationFactor < 2)     continue;
    for (    ConsistencyLevel c : ConsistencyLevel.values()) {
      if (c == ConsistencyLevel.EACH_QUORUM || c == ConsistencyLevel.LOCAL_QUORUM)       continue;
      for (int i=0; i < replicationFactor; i++) {
        hostsInUse.clear();
        for (int j=0; j < i; j++) {
          hostsInUse.add(hosts.get(j));
        }
        if (hostsInUse.isEmpty()) {
          continue;
        }
        IWriteResponseHandler writeHandler=strategy.getWriteResponseHandler(hostsInUse,c);
        IReadCommand command=new IReadCommand(){
          public String getKeyspace(){
            return table;
          }
        }
;
        RowRepairResolver resolver=new RowRepairResolver(table,ByteBufferUtil.bytes("foo"));
        ReadCallback<Row> readHandler=StorageProxy.getReadCallback(resolver,command,c,hostsInUse);
        boolean isWriteUnavailable=false;
        boolean isReadUnavailable=false;
        try {
          writeHandler.assureSufficientLiveNodes();
        }
 catch (        UnavailableException e) {
          isWriteUnavailable=true;
        }
        try {
          readHandler.assureSufficientLiveNodes();
        }
 catch (        UnavailableException e) {
          isReadUnavailable=true;
        }
        assertTrue(String.format("Node Alive: %d - CL: %s - isWriteUnavailable: %b - isReadUnavailable: %b",hostsInUse.size(),c,isWriteUnavailable,isReadUnavailable),isWriteUnavailable == isReadUnavailable);
switch (c) {
case ALL:
          if (isWriteUnavailable)           assertTrue(hostsInUse.size() < replicationFactor);
 else           assertTrue(hostsInUse.size() >= replicationFactor);
        break;
case ONE:
case ANY:
      if (isWriteUnavailable)       assertTrue(hostsInUse.size() == 0);
 else       assertTrue(hostsInUse.size() > 0);
    break;
case TWO:
  if (isWriteUnavailable)   assertTrue(hostsInUse.size() < 2);
 else   assertTrue(hostsInUse.size() >= 2);
break;
case THREE:
if (isWriteUnavailable) assertTrue(hostsInUse.size() < 3);
 else assertTrue(hostsInUse.size() >= 3);
break;
case QUORUM:
if (isWriteUnavailable) assertTrue(hostsInUse.size() < (replicationFactor / 2 + 1));
 else assertTrue(hostsInUse.size() >= (replicationFactor / 2 + 1));
break;
default :
fail("Unhandled CL: " + c);
}
}
}
return;
}
fail("Test requires at least one table with RF > 1");
}
