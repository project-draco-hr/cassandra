{
  Class<?> jReturnType=meta.cqlReturnType.getType().getSerializer().getType();
  Class<?> paramTypes[]=new Class[meta.cqlArgumentTypes.size()];
  for (int i=0; i < paramTypes.length; i++)   paramTypes[i]=meta.cqlArgumentTypes.get(i).getType().getSerializer().getType();
  String className;
  String methodName;
  int i=meta.body.indexOf('#');
  if (i != -1) {
    methodName=meta.body.substring(i + 1);
    className=meta.body.substring(0,i);
  }
 else {
    methodName=meta.functionName;
    className=meta.body;
  }
  try {
    Class<?> cls=Class.forName(className,false,Thread.currentThread().getContextClassLoader());
    Method method=cls.getMethod(methodName,paramTypes);
    if (!jReturnType.isAssignableFrom(method.getReturnType())) {
      throw new InvalidRequestException("Method " + className + '.'+ methodName+ '('+ Arrays.toString(paramTypes)+ ") "+ "has incompatible return type "+ method.getReturnType()+ " (not assignable to "+ jReturnType+ ')');
    }
    return method;
  }
 catch (  ClassNotFoundException e) {
    throw new InvalidRequestException("Class " + className + " does not exist");
  }
catch (  NoSuchMethodException e) {
    throw new InvalidRequestException("Method " + className + '.'+ methodName+ '('+ Arrays.toString(paramTypes)+ ") does not exist");
  }
}
