{
  final int argCount=providedArgs.size();
  final List<AbstractType<?>> argsType=new ArrayList<>(argCount);
  final AbstractType<?> returnType=meta.cqlReturnType.getType();
  for (int i=0; i < argCount; i++) {
    AbstractType<?> argType=meta.cqlArgumentTypes.get(i).getType();
    argsType.add(argType);
  }
  return new Function(){
    public String name(){
      return meta.qualifiedName;
    }
    public List<AbstractType<?>> argsType(){
      return argsType;
    }
    public AbstractType<?> returnType(){
      return returnType;
    }
    public ByteBuffer execute(    List<ByteBuffer> parameters) throws InvalidRequestException {
      Object[] parms=new Object[argCount];
      for (int i=0; i < parms.length; i++) {
        ByteBuffer bb=parameters.get(i);
        if (bb != null) {
          AbstractType<?> argType=argsType.get(i);
          parms[i]=argType.compose(bb);
        }
      }
      Object result;
      try {
        result=method.invoke(null,parms);
        @SuppressWarnings("unchecked") ByteBuffer r=result != null ? ((AbstractType)returnType).decompose(result) : null;
        return r;
      }
 catch (      InvocationTargetException e) {
        Throwable c=e.getCause();
        logger.error("Invocation of UDF {} failed",meta.qualifiedName,c);
        throw new InvalidRequestException("Invocation of UDF " + meta.qualifiedName + " failed: "+ c);
      }
catch (      IllegalAccessException e) {
        throw new InvalidRequestException("UDF " + meta.qualifiedName + " invocation failed: "+ e);
      }
    }
    public boolean isPure(){
      return meta.deterministic;
    }
  }
;
}
