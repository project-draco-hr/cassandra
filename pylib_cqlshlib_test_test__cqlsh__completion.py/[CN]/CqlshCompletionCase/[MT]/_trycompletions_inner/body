def _trycompletions_inner(self, inputstring, immediate='', choices=(), other_choices_ok=False):
    "\n        Test tab completion in cqlsh. Enters in the text in inputstring, then\n        simulates a tab keypress to see what is immediately completed (this\n        should only happen when there is only one completion possible). If\n        there is an immediate completion, the new text is expected to match\n        'immediate'. If there is no immediate completion, another tab keypress\n        is simulated in order to get a list of choices, which are expected to\n        match the items in 'choices' (order is not important, but case is).\n        "
    self.cqlsh.send(inputstring)
    self.cqlsh.send(TAB)
    completed = self.cqlsh.read_up_to_timeout(COMPLETION_RESPONSE_TIME)
    completed = completed.replace(' \x08', '')
    self.assertEqual(completed[:len(inputstring)], inputstring)
    completed = completed[len(inputstring):]
    completed = completed.replace(BEL, '')
    self.assertEqual(completed, immediate, ('cqlsh completed %r, but we expected %r' % (completed, immediate)))
    if immediate:
        return
    self.cqlsh.send(TAB)
    choice_output = self.cqlsh.read_up_to_timeout(COMPLETION_RESPONSE_TIME)
    if (choice_output == BEL):
        lines = ()
    else:
        lines = choice_output.splitlines()
        self.assertRegexpMatches(lines[(-1)], (self.cqlsh.prompt.lstrip() + re.escape(inputstring)))
    choicesseen = set()
    for line in lines[:(-1)]:
        choicesseen.update(completion_separation_re.split(line.strip()))
    choicesseen.discard('')
    if other_choices_ok:
        self.assertEqual(set(choices), choicesseen.intersection(choices))
    else:
        self.assertEqual(set(choices), choicesseen)
