{
  checkArgument(args.size() == 2,"tablehistograms requires keyspace and table name arguments");
  String keyspace=args.get(0);
  String table=args.get(1);
  long[] estimatedPartitionSize=(long[])probe.getColumnFamilyMetric(keyspace,table,"EstimatedPartitionSizeHistogram");
  long[] estimatedColumnCount=(long[])probe.getColumnFamilyMetric(keyspace,table,"EstimatedColumnCountHistogram");
  double[] estimatedRowSizePercentiles=new double[7];
  double[] estimatedColumnCountPercentiles=new double[7];
  double[] offsetPercentiles=new double[]{0.5,0.75,0.95,0.98,0.99};
  if (ArrayUtils.isEmpty(estimatedPartitionSize) || ArrayUtils.isEmpty(estimatedColumnCount)) {
    System.err.println("No SSTables exists, unable to calculate 'Partition Size' and 'Cell Count' percentiles");
    for (int i=0; i < 7; i++) {
      estimatedRowSizePercentiles[i]=Double.NaN;
      estimatedColumnCountPercentiles[i]=Double.NaN;
    }
  }
 else {
    long[] partitionSizeBucketOffsets=new EstimatedHistogram(estimatedPartitionSize.length).getBucketOffsets();
    long[] columnCountBucketOffsets=new EstimatedHistogram(estimatedColumnCount.length).getBucketOffsets();
    EstimatedHistogram partitionSizeHist=new EstimatedHistogram(partitionSizeBucketOffsets,estimatedPartitionSize);
    EstimatedHistogram columnCountHist=new EstimatedHistogram(columnCountBucketOffsets,estimatedColumnCount);
    if (partitionSizeHist.isOverflowed()) {
      System.err.println(String.format("Row sizes are larger than %s, unable to calculate percentiles",partitionSizeBucketOffsets[partitionSizeBucketOffsets.length - 1]));
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedRowSizePercentiles[i]=Double.NaN;
    }
 else {
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedRowSizePercentiles[i]=partitionSizeHist.percentile(offsetPercentiles[i]);
    }
    if (columnCountHist.isOverflowed()) {
      System.err.println(String.format("Column counts are larger than %s, unable to calculate percentiles",columnCountBucketOffsets[columnCountBucketOffsets.length - 1]));
      for (int i=0; i < estimatedColumnCountPercentiles.length; i++)       estimatedColumnCountPercentiles[i]=Double.NaN;
    }
 else {
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedColumnCountPercentiles[i]=columnCountHist.percentile(offsetPercentiles[i]);
    }
    estimatedRowSizePercentiles[5]=partitionSizeHist.min();
    estimatedColumnCountPercentiles[5]=columnCountHist.min();
    estimatedRowSizePercentiles[6]=partitionSizeHist.max();
    estimatedColumnCountPercentiles[6]=columnCountHist.max();
  }
  String[] percentiles=new String[]{"50%","75%","95%","98%","99%","Min","Max"};
  double[] readLatency=probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspace,table,"ReadLatency"));
  double[] writeLatency=probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean)probe.getColumnFamilyMetric(keyspace,table,"WriteLatency"));
  double[] sstablesPerRead=probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxHistogramMBean)probe.getColumnFamilyMetric(keyspace,table,"SSTablesPerReadHistogram"));
  System.out.println(format("%s/%s histograms",keyspace,table));
  System.out.println(format("%-10s%10s%18s%18s%18s%18s","Percentile","SSTables","Write Latency","Read Latency","Partition Size","Cell Count"));
  System.out.println(format("%-10s%10s%18s%18s%18s%18s","","","(micros)","(micros)","(bytes)",""));
  for (int i=0; i < percentiles.length; i++) {
    System.out.println(format("%-10s%10.2f%18.2f%18.2f%18.0f%18.0f",percentiles[i],sstablesPerRead[i],writeLatency[i],readLatency[i],estimatedRowSizePercentiles[i],estimatedColumnCountPercentiles[i]));
  }
  System.out.println();
}
