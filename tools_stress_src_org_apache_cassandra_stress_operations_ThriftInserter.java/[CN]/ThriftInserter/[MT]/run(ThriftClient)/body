{
  final ByteBuffer key=getKey();
  final List<Column> columns=generateColumns();
  Map<String,List<Mutation>> row;
  if (!state.settings.columns.useSuperColumns) {
    List<Mutation> mutations=new ArrayList<>(columns.size());
    for (    Column c : columns) {
      ColumnOrSuperColumn column=new ColumnOrSuperColumn().setColumn(c);
      mutations.add(new Mutation().setColumn_or_supercolumn(column));
    }
    row=Collections.singletonMap(state.settings.schema.columnFamily,mutations);
  }
 else {
    List<Mutation> mutations=new ArrayList<>(state.columnParents.size());
    for (    ColumnParent parent : state.columnParents) {
      final SuperColumn s=new SuperColumn(parent.bufferForSuper_column(),columns);
      final ColumnOrSuperColumn cosc=new ColumnOrSuperColumn().setSuper_column(s);
      mutations.add(new Mutation().setColumn_or_supercolumn(cosc));
    }
    row=Collections.singletonMap("Super1",mutations);
  }
  final Map<ByteBuffer,Map<String,List<Mutation>>> record=Collections.singletonMap(key,row);
  timeWithRetry(new RunOp(){
    @Override public boolean run() throws Exception {
      client.batch_mutate(record,state.settings.command.consistencyLevel);
      return true;
    }
    @Override public String key(){
      return new String(key.array());
    }
    @Override public int keyCount(){
      return 1;
    }
  }
);
}
