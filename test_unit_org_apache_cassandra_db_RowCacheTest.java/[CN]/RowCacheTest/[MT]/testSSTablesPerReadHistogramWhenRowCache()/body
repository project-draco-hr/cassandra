{
  CompactionManager.instance.disableAutoCompaction();
  Keyspace keyspace=Keyspace.open(KEYSPACE);
  ColumnFamilyStore cachedStore=keyspace.getColumnFamilyStore(COLUMN_FAMILY);
  CacheService.instance.invalidateRowCache();
  CacheService.instance.setRowCacheCapacityInMB(1);
  insertData(KEYSPACE,COLUMN_FAMILY,0,100);
  cachedStore.forceBlockingFlush();
  cachedStore.metric.sstablesPerReadHistogram.cf.clear();
  for (int i=0; i < 100; i++) {
    DecoratedKey key=Util.dk("key" + i);
    cachedStore.getColumnFamily(key,Composites.EMPTY,Composites.EMPTY,false,1,System.currentTimeMillis());
    long count_before=cachedStore.metric.sstablesPerReadHistogram.cf.count();
    cachedStore.getColumnFamily(key,Composites.EMPTY,Composites.EMPTY,false,1,System.currentTimeMillis());
    long count_after=cachedStore.metric.sstablesPerReadHistogram.cf.count();
    double belowMedian_after=cachedStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getValue(0.49);
    double mean_after=cachedStore.metric.sstablesPerReadHistogram.cf.mean();
    assertEquals("SSTablePerReadHistogram should be updated even key found in row cache",count_before + 1,count_after);
    assertTrue("In half of requests we have not touched SSTables, " + "so 49 percentile value (" + belowMedian_after + ") must be strongly less than 0.9",belowMedian_after < 0.9D);
    assertTrue("In half of requests we have not touched SSTables, " + "so mean value (" + mean_after + ") must be strongly less than 1, but greater than 0",mean_after < 0.999D && mean_after > 0.001D);
  }
  assertEquals("Min value of SSTablesPerRead should be zero",0,cachedStore.metric.sstablesPerReadHistogram.cf.min(),0.01);
  CacheService.instance.setRowCacheCapacityInMB(0);
}
