{
  if ((range.start_key == null) != (range.end_key == null)) {
    throw new InvalidRequestException("start key and end key must either both be non-null, or both be null");
  }
  if ((range.start_token == null) != (range.end_token == null)) {
    throw new InvalidRequestException("start token and end token must either both be non-null, or both be null");
  }
  if ((range.start_key == null) == (range.start_token == null)) {
    throw new InvalidRequestException("exactly one of {start key, end key} or {start token, end token} must be specified");
  }
  if (range.start_key != null) {
    IPartitioner p=StorageService.getPartitioner();
    Token startToken=p.getToken(range.start_key);
    Token endToken=p.getToken(range.end_key);
    if (startToken.compareTo(endToken) > 0 && !endToken.isMinimum(p)) {
      if (p instanceof RandomPartitioner)       throw new InvalidRequestException("start key's md5 sorts after end key's md5.  this is not allowed; you probably should not specify end key at all, under RandomPartitioner");
 else       throw new InvalidRequestException("start key must sort before (or equal to) finish key in your partitioner!");
    }
  }
  validateFilterClauses(metadata,range.row_filter);
  if (!isEmpty(range.row_filter) && superColumn != null) {
    throw new InvalidRequestException("super columns are not yet supported for indexing");
  }
  if (range.count <= 0) {
    throw new InvalidRequestException("maxRows must be positive");
  }
}
