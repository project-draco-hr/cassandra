{
  StringBuilder sb=new StringBuilder();
  lock.readLock().lock();
  try {
    Set<InetAddress> eps=tokenToEndpointMap.inverse().keySet();
    if (!eps.isEmpty()) {
      sb.append("Normal Tokens:");
      sb.append(System.getProperty("line.separator"));
      for (      InetAddress ep : eps) {
        sb.append(ep);
        sb.append(":");
        sb.append(tokenToEndpointMap.inverse().get(ep));
        sb.append(System.getProperty("line.separator"));
      }
    }
synchronized (bootstrapTokens) {
      if (!bootstrapTokens.isEmpty()) {
        sb.append("Bootstrapping Tokens:");
        sb.append(System.getProperty("line.separator"));
        for (        Map.Entry<Token,InetAddress> entry : bootstrapTokens.entrySet()) {
          sb.append(entry.getValue() + ":" + entry.getKey());
          sb.append(System.getProperty("line.separator"));
        }
      }
    }
    if (!leavingEndpoints.isEmpty()) {
      sb.append("Leaving Endpoints:");
      sb.append(System.getProperty("line.separator"));
      for (      InetAddress ep : leavingEndpoints) {
        sb.append(ep);
        sb.append(System.getProperty("line.separator"));
      }
    }
    if (!pendingRanges.isEmpty()) {
      sb.append("Pending Ranges:");
      sb.append(System.getProperty("line.separator"));
      sb.append(printPendingRanges());
    }
  }
  finally {
    lock.readLock().unlock();
  }
  return sb.toString();
}
