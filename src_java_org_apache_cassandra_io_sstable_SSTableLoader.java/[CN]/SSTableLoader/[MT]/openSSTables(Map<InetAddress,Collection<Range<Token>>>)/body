{
  outputHandler.output("Opening sstables and calculating sections to stream");
  directory.list(new FilenameFilter(){
    final Map<File,Set<File>> allTemporaryFiles=new HashMap<>();
    public boolean accept(    File dir,    String name){
      File file=new File(dir,name);
      if (file.isDirectory())       return false;
      Pair<Descriptor,Component> p=SSTable.tryComponentFromFilename(dir,name);
      Descriptor desc=p == null ? null : p.left;
      if (p == null || !p.right.equals(Component.DATA))       return false;
      if (!new File(desc.filenameFor(Component.PRIMARY_INDEX)).exists()) {
        outputHandler.output(String.format("Skipping file %s because index is missing",name));
        return false;
      }
      CFMetaData metadata=client.getTableMetadata(desc.cfname);
      if (metadata == null) {
        outputHandler.output(String.format("Skipping file %s: table %s.%s doesn't exist",name,keyspace,desc.cfname));
        return false;
      }
      Set<File> temporaryFiles=allTemporaryFiles.get(dir);
      if (temporaryFiles == null) {
        temporaryFiles=LifecycleTransaction.getTemporaryFiles(metadata,dir);
        allTemporaryFiles.put(dir,temporaryFiles);
      }
      if (temporaryFiles.contains(file)) {
        outputHandler.output(String.format("Skipping temporary file %s",name));
        return false;
      }
      Set<Component> components=new HashSet<>();
      components.add(Component.DATA);
      components.add(Component.PRIMARY_INDEX);
      if (new File(desc.filenameFor(Component.SUMMARY)).exists())       components.add(Component.SUMMARY);
      if (new File(desc.filenameFor(Component.COMPRESSION_INFO)).exists())       components.add(Component.COMPRESSION_INFO);
      if (new File(desc.filenameFor(Component.STATS)).exists())       components.add(Component.STATS);
      try {
        SSTableReader sstable=SSTableReader.openForBatch(desc,components,metadata);
        sstables.add(sstable);
        for (        Map.Entry<InetAddress,Collection<Range<Token>>> entry : ranges.entrySet()) {
          InetAddress endpoint=entry.getKey();
          Collection<Range<Token>> tokenRanges=entry.getValue();
          List<Pair<Long,Long>> sstableSections=sstable.getPositionsForRanges(tokenRanges);
          long estimatedKeys=sstable.estimatedKeysForRanges(tokenRanges);
          Ref<SSTableReader> ref=sstable.ref();
          StreamSession.SSTableStreamingSections details=new StreamSession.SSTableStreamingSections(ref,sstableSections,estimatedKeys,ActiveRepairService.UNREPAIRED_SSTABLE);
          streamingDetails.put(endpoint,details);
        }
        sstable.releaseSummary();
      }
 catch (      IOException e) {
        outputHandler.output(String.format("Skipping file %s, error opening it: %s",name,e.getMessage()));
      }
      return false;
    }
  }
);
  return sstables;
}
