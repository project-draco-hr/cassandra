{
  outputHandler.output("Opening sstables and calculating sections to stream");
  directory.list(new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      if (new File(dir,name).isDirectory())       return false;
      Pair<Descriptor,Component> p=SSTable.tryComponentFromFilename(dir,name);
      Descriptor desc=p == null ? null : p.left;
      if (p == null || !p.right.equals(Component.DATA) || desc.type.isTemporary)       return false;
      if (!new File(desc.filenameFor(Component.PRIMARY_INDEX)).exists()) {
        outputHandler.output(String.format("Skipping file %s because index is missing",name));
        return false;
      }
      CFMetaData metadata=client.getCFMetaData(keyspace,desc.cfname);
      if (metadata == null) {
        outputHandler.output(String.format("Skipping file %s: table %s.%s doesn't exist",name,keyspace,desc.cfname));
        return false;
      }
      Set<Component> components=new HashSet<>();
      components.add(Component.DATA);
      components.add(Component.PRIMARY_INDEX);
      if (new File(desc.filenameFor(Component.SUMMARY)).exists())       components.add(Component.SUMMARY);
      if (new File(desc.filenameFor(Component.COMPRESSION_INFO)).exists())       components.add(Component.COMPRESSION_INFO);
      if (new File(desc.filenameFor(Component.STATS)).exists())       components.add(Component.STATS);
      try {
        SSTableReader sstable=SSTableReader.openForBatch(desc,components,metadata,client.getPartitioner());
        sstables.add(sstable);
        for (        Map.Entry<InetAddress,Collection<Range<Token>>> entry : ranges.entrySet()) {
          InetAddress endpoint=entry.getKey();
          Collection<Range<Token>> tokenRanges=entry.getValue();
          List<Pair<Long,Long>> sstableSections=sstable.getPositionsForRanges(tokenRanges);
          long estimatedKeys=sstable.estimatedKeysForRanges(tokenRanges);
          StreamSession.SSTableStreamingSections details=new StreamSession.SSTableStreamingSections(sstable,sstableSections,estimatedKeys,ActiveRepairService.UNREPAIRED_SSTABLE);
          streamingDetails.put(endpoint,details);
        }
        sstable.releaseSummary();
      }
 catch (      IOException e) {
        outputHandler.output(String.format("Skipping file %s, error opening it: %s",name,e.getMessage()));
      }
      return false;
    }
  }
);
  return sstables;
}
