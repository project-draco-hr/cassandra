{
  columnCounter=columnCounter(container.getComparator(),now);
  DeletionInfo.InOrderTester tester=container.deletionInfo().inOrderTester(reversed);
  while (reducedColumns.hasNext()) {
    Column column=reducedColumns.next();
    if (logger.isTraceEnabled())     logger.trace(String.format("collecting %s of %s: %s",columnCounter.live(),count,column.getString(container.getComparator())));
    columnCounter.count(column,tester);
    if (columnCounter.live() > count)     break;
    if (respectTombstoneThresholds() && columnCounter.tombstones() > DatabaseDescriptor.getTombstoneFailureThreshold()) {
      Tracing.trace("Scanned over {} tombstones; query aborted (see tombstone_failure_threshold)",DatabaseDescriptor.getTombstoneFailureThreshold());
      logger.error("Scanned over {} tombstones in {}.{}; query aborted (see tombstone_failure_threshold)",DatabaseDescriptor.getTombstoneFailureThreshold(),container.metadata().ksName,container.metadata().cfName);
      throw new TombstoneOverwhelmingException();
    }
    container.addIfRelevant(column,tester,gcBefore);
  }
  Tracing.trace("Read {} live and {} tombstone cells",columnCounter.live(),columnCounter.tombstones());
  if (respectTombstoneThresholds() && columnCounter.tombstones() > DatabaseDescriptor.getTombstoneWarnThreshold()) {
    StringBuilder sb=new StringBuilder();
    AbstractType<?> type=container.metadata().comparator;
    for (    ColumnSlice sl : slices) {
      if (sl == null)       continue;
      sb.append('[');
      sb.append(type.getString(sl.start));
      sb.append('-');
      sb.append(type.getString(sl.finish));
      sb.append(']');
    }
    logger.warn("Read {} live and {} tombstone cells in {}.{} (see tombstone_warn_threshold). {} columns was requested, slices={}",columnCounter.live(),columnCounter.tombstones(),container.metadata().ksName,container.metadata().cfName,count,sb);
  }
}
