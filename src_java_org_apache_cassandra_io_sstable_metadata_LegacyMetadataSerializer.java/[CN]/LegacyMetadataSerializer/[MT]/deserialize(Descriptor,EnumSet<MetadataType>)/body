{
  Map<MetadataType,MetadataComponent> components=Maps.newHashMap();
  File statsFile=new File(descriptor.filenameFor(Component.STATS));
  if (!statsFile.exists() && types.contains(MetadataType.STATS)) {
    components.put(MetadataType.STATS,MetadataCollector.defaultStatsMetadata());
  }
 else {
    try (DataInputStream in=new DataInputStream(new BufferedInputStream(new FileInputStream(statsFile)))){
      EstimatedHistogram rowSizes=EstimatedHistogram.serializer.deserialize(in);
      EstimatedHistogram columnCounts=EstimatedHistogram.serializer.deserialize(in);
      ReplayPosition replayPosition=ReplayPosition.serializer.deserialize(in);
      long minTimestamp=in.readLong();
      long maxTimestamp=in.readLong();
      int maxLocalDeletionTime=descriptor.version.tracksMaxLocalDeletionTime ? in.readInt() : Integer.MAX_VALUE;
      double bloomFilterFPChance=descriptor.version.hasBloomFilterFPChance ? in.readDouble() : NO_BLOOM_FILTER_FP_CHANCE;
      double compressionRatio=in.readDouble();
      String partitioner=in.readUTF();
      int nbAncestors=in.readInt();
      Set<Integer> ancestors=new HashSet<>(nbAncestors);
      for (int i=0; i < nbAncestors; i++)       ancestors.add(in.readInt());
      StreamingHistogram tombstoneHistogram=StreamingHistogram.serializer.deserialize(in);
      int sstableLevel=0;
      if (in.available() > 0)       sstableLevel=in.readInt();
      List<ByteBuffer> minColumnNames;
      List<ByteBuffer> maxColumnNames;
      if (descriptor.version.tracksMaxMinColumnNames) {
        int colCount=in.readInt();
        minColumnNames=new ArrayList<>(colCount);
        for (int i=0; i < colCount; i++) {
          minColumnNames.add(ByteBufferUtil.readWithShortLength(in));
        }
        colCount=in.readInt();
        maxColumnNames=new ArrayList<>(colCount);
        for (int i=0; i < colCount; i++) {
          maxColumnNames.add(ByteBufferUtil.readWithShortLength(in));
        }
      }
 else {
        minColumnNames=Collections.emptyList();
        maxColumnNames=Collections.emptyList();
      }
      if (types.contains(MetadataType.VALIDATION))       components.put(MetadataType.VALIDATION,new ValidationMetadata(partitioner,bloomFilterFPChance));
      if (types.contains(MetadataType.STATS))       components.put(MetadataType.STATS,new StatsMetadata(rowSizes,columnCounts,replayPosition,minTimestamp,maxTimestamp,maxLocalDeletionTime,compressionRatio,tombstoneHistogram,sstableLevel,minColumnNames,maxColumnNames));
      if (types.contains(MetadataType.COMPACTION))       components.put(MetadataType.COMPACTION,new CompactionMetadata(ancestors,null));
    }
   }
  return components;
}
