{
  clusteringComponents[depth].poll();
  while (true) {
    if (clusteringComponents[depth].isEmpty()) {
      if (depth == 0)       return false;
      depth--;
      clusteringComponents[depth].poll();
      continue;
    }
    double thischance=useChance * chancemodifier[depth];
    if (thischance > 0.999f || thischance >= random.nextDouble()) {
      row.row[depth]=clusteringComponents[depth].peek();
      depth++;
      if (depth == clusteringComponents.length)       break;
      rollmodifier[depth]=rollmodifier[depth - 1] / Math.min(1d,thischance);
      chancemodifier[depth]=generator.clusteringChildAverages[depth] * rollmodifier[depth];
      fill(depth);
      continue;
    }
    clusteringComponents[depth].poll();
  }
  return continueChance >= 1.0d || continueChance >= random.nextDouble();
}
