{
  if (btree.length == 0)   return build(updateWith,comparator,updateWithIsSorted);
  if (!updateWithIsSorted)   updateWith=sorted(updateWith,comparator,updateWith.size());
  if (isLeaf(btree) && btree.length + updateWith.size() < QUICK_MERGE_LIMIT) {
    int btreeOffset=0;
    int keyEnd=getLeafKeyEnd(btree);
    Object[] merged=new Object[QUICK_MERGE_LIMIT];
    int mergedCount=0;
    for (    V v : updateWith) {
      int i=find(comparator,v,btree,btreeOffset,keyEnd);
      boolean found=i >= 0;
      if (!found)       i=-i - 1;
      int count=i - btreeOffset;
      if (count > 0) {
        System.arraycopy(btree,btreeOffset,merged,mergedCount,count);
        mergedCount+=count;
        btreeOffset=i;
      }
      if (found) {
        btreeOffset++;
        if (replaceF != null)         v=replaceF.apply((V)btree[i],v);
      }
 else       if (replaceF != null) {
        v=replaceF.apply(null,v);
      }
      merged[mergedCount++]=v;
    }
    if (btreeOffset < keyEnd) {
      int count=keyEnd - btreeOffset;
      System.arraycopy(btree,btreeOffset,merged,mergedCount,count);
      mergedCount+=count;
    }
    if (mergedCount > FAN_FACTOR) {
      int mid=(mergedCount >> 1) & ~1;
      return new Object[]{merged[mid],Arrays.copyOfRange(merged,0,mid),Arrays.copyOfRange(merged,1 + mid,mergedCount + ((mergedCount + 1) & 1))};
    }
    return Arrays.copyOfRange(merged,0,mergedCount + (mergedCount & 1));
  }
  return modifier.get().update(btree,comparator,updateWith,replaceF,terminateEarly);
}
