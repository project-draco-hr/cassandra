{
  if (cfs.isAutoCompactionDisabled()) {
    logger.debug("Autocompaction is disabled");
    return Collections.emptyList();
  }
  int count=compactingCF.count(cfs);
  if (count > 0 && executor.getActiveCount() >= executor.getMaximumPoolSize()) {
    logger.debug("Background compaction is still running for {}.{} ({} remaining). Skipping",cfs.keyspace.getName(),cfs.name,count);
    return Collections.emptyList();
  }
  logger.debug("Scheduling a background task check for {}.{} with {}",cfs.keyspace.getName(),cfs.name,cfs.getCompactionStrategy().getName());
  List<Future<?>> futures=new ArrayList<Future<?>>();
  do {
    if (executor.isShutdown()) {
      logger.info("Executor has shut down, not submitting background task");
      return Collections.emptyList();
    }
    compactingCF.add(cfs);
    futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
  }
 while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize());
  return futures;
}
