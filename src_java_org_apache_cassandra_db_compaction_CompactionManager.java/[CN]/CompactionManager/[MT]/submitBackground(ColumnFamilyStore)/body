{
  logger.debug("Scheduling a background task check for {}.{} with {}",new Object[]{cfs.table.name,cfs.columnFamily,cfs.getCompactionStrategy().getClass().getSimpleName()});
  Callable<Integer> callable=new Callable<Integer>(){
    public Integer call() throws IOException {
      compactionLock.readLock().lock();
      try {
        logger.debug("Checking {}.{}",cfs.table.name,cfs.columnFamily);
        if (!cfs.isValid()) {
          logger.debug("Aborting compaction for dropped CF");
          return 0;
        }
        boolean taskExecuted=false;
        AbstractCompactionStrategy strategy=cfs.getCompactionStrategy();
        List<AbstractCompactionTask> tasks=strategy.getBackgroundTasks(getDefaultGcBefore(cfs));
        logger.debug("{} minor compaction tasks available",tasks.size());
        for (        AbstractCompactionTask task : tasks) {
          if (!task.markSSTablesForCompaction()) {
            logger.debug("Skipping {}; sstables are busy",task);
            continue;
          }
          taskExecuted=true;
          try {
            task.execute(executor);
          }
  finally {
            task.unmarkSSTables();
          }
        }
        if (taskExecuted)         submitBackground(cfs);
      }
  finally {
        compactionLock.readLock().unlock();
      }
      return 0;
    }
  }
;
  return executor.submit(callable);
}
