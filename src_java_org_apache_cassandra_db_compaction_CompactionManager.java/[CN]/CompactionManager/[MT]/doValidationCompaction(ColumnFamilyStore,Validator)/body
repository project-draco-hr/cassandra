{
  if (!cfs.isValid())   return;
  String snapshotName=validator.desc.sessionId.toString();
  boolean isSnapshotValidation=cfs.snapshotExists(snapshotName);
  int gcBefore;
  if (isSnapshotValidation) {
    try (Refs<SSTableReader> sstables=cfs.getSnapshotSSTableReader(snapshotName)){
      gcBefore=cfs.gcBefore(cfs.getSnapshotCreationTime(snapshotName));
      buildMerkleTree(cfs,sstables,validator,gcBefore);
      cfs.clearSnapshot(snapshotName);
    }
   }
 else {
    StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(),cfs.name);
    ActiveRepairService.ParentRepairSession prs=ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId);
    try (ColumnFamilyStore.RefViewFragment sstableCandidates=cfs.selectAndReference(prs.isIncremental ? ColumnFamilyStore.UNREPAIRED_SSTABLES : ColumnFamilyStore.CANONICAL_SSTABLES)){
      Refs<SSTableReader> refs=sstableCandidates.refs;
      Set<SSTableReader> sstablesToValidate=new HashSet<>();
      for (      SSTableReader sstable : sstableCandidates.sstables) {
        if (new Bounds<>(sstable.first.getToken(),sstable.last.getToken()).intersects(Collections.singletonList(validator.desc.range))) {
          sstablesToValidate.add(sstable);
        }
      }
      Set<SSTableReader> currentlyRepairing=ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId,validator.desc.parentSessionId);
      if (!Sets.intersection(currentlyRepairing,sstablesToValidate).isEmpty()) {
        logger.error("Cannot start multiple repair sessions over the same sstables");
        throw new RuntimeException("Cannot start multiple repair sessions over the same sstables");
      }
      refs.relaseAllExcept(sstablesToValidate);
      prs.addSSTables(cfs.metadata.cfId,sstablesToValidate);
      if (validator.gcBefore > 0)       gcBefore=validator.gcBefore;
 else       gcBefore=getDefaultGcBefore(cfs);
      buildMerkleTree(cfs,refs,validator,gcBefore);
    }
   }
}
