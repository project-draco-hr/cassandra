{
  if (!cfs.isValid())   return;
  Refs<SSTableReader> sstables=null;
  try {
    String snapshotName=validator.desc.sessionId.toString();
    int gcBefore;
    boolean isSnapshotValidation=cfs.snapshotExists(snapshotName);
    if (isSnapshotValidation) {
      sstables=cfs.getSnapshotSSTableReader(snapshotName);
      gcBefore=cfs.gcBefore(cfs.getSnapshotCreationTime(snapshotName));
    }
 else {
      StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(),cfs.name);
      ActiveRepairService.ParentRepairSession prs=ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId);
      Set<SSTableReader> sstablesToValidate=new HashSet<>();
      for (      SSTableReader sstable : cfs.getSSTables()) {
        if (new Bounds<>(sstable.first.getToken(),sstable.last.getToken()).intersects(Arrays.asList(validator.desc.range))) {
          if (!prs.isIncremental || !sstable.isRepaired()) {
            sstablesToValidate.add(sstable);
          }
        }
      }
      Set<SSTableReader> currentlyRepairing=ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId,validator.desc.parentSessionId);
      if (!Sets.intersection(currentlyRepairing,sstablesToValidate).isEmpty()) {
        logger.error("Cannot start multiple repair sessions over the same sstables");
        throw new RuntimeException("Cannot start multiple repair sessions over the same sstables");
      }
      prs.addSSTables(cfs.metadata.cfId,sstablesToValidate);
      sstables=prs.getAndReferenceSSTablesInRange(cfs.metadata.cfId,validator.desc.range);
      if (validator.gcBefore > 0)       gcBefore=validator.gcBefore;
 else       gcBefore=getDefaultGcBefore(cfs);
    }
    long numPartitions=0;
    for (    SSTableReader sstable : sstables) {
      numPartitions+=sstable.estimatedKeysForRanges(Collections.singleton(validator.desc.range));
    }
    int depth=numPartitions > 0 ? (int)Math.min(Math.floor(Math.log(numPartitions)),20) : 0;
    MerkleTree tree=new MerkleTree(cfs.partitioner,validator.desc.range,MerkleTree.RECOMMENDED_DEPTH,(int)Math.pow(2,depth));
    long start=System.nanoTime();
    try (AbstractCompactionStrategy.ScannerList scanners=cfs.getCompactionStrategy().getScanners(sstables,validator.desc.range)){
      CompactionIterable ci=new ValidationCompactionIterable(cfs,scanners.scanners,gcBefore);
      Iterator<AbstractCompactedRow> iter=ci.iterator();
      metrics.beginCompaction(ci);
      try {
        validator.prepare(cfs,tree);
        while (iter.hasNext()) {
          if (ci.isStopRequested())           throw new CompactionInterruptedException(ci.getCompactionInfo());
          AbstractCompactedRow row=iter.next();
          validator.add(row);
        }
        validator.complete();
      }
  finally {
        if (isSnapshotValidation) {
          cfs.clearSnapshot(snapshotName);
        }
        metrics.finishCompaction(ci);
      }
    }
     if (logger.isDebugEnabled()) {
      long duration=TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
      logger.debug("Validation finished in {} msec, depth {} for {} keys, serialized size {} bytes for {}",duration,depth,numPartitions,MerkleTree.serializer.serializedSize(tree,0),validator.desc);
    }
  }
  finally {
    if (sstables != null)     sstables.release();
  }
}
