{
  if (!cfs.isValid())   return;
  Refs<SSTableReader> sstables=null;
  try {
    String snapshotName=validator.desc.sessionId.toString();
    int gcBefore;
    boolean isSnapshotValidation=cfs.snapshotExists(snapshotName);
    if (isSnapshotValidation) {
      sstables=cfs.getSnapshotSSTableReader(snapshotName);
      gcBefore=cfs.gcBefore(cfs.getSnapshotCreationTime(snapshotName));
    }
 else {
      StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(),cfs.name);
      if (validator.desc.parentSessionId == null || ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId) == null)       sstables=cfs.selectAndReference(ColumnFamilyStore.CANONICAL_SSTABLES).refs;
 else {
        ActiveRepairService.ParentRepairSession prs=ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId);
        prs.markSSTablesRepairing(cfs.metadata.cfId,validator.desc.parentSessionId);
        sstables=cfs.selectAndReference(ColumnFamilyStore.UNREPAIRED_SSTABLES).refs;
      }
      if (validator.gcBefore > 0)       gcBefore=validator.gcBefore;
 else       gcBefore=getDefaultGcBefore(cfs);
    }
    long numPartitions=0;
    for (    SSTableReader sstable : sstables) {
      numPartitions+=sstable.estimatedKeysForRanges(Collections.singleton(validator.desc.range));
    }
    int depth=numPartitions > 0 ? (int)Math.min(Math.floor(Math.log(numPartitions)),20) : 0;
    MerkleTree tree=new MerkleTree(cfs.partitioner,validator.desc.range,MerkleTree.RECOMMENDED_DEPTH,(int)Math.pow(2,depth));
    long start=System.nanoTime();
    try (AbstractCompactionStrategy.ScannerList scanners=cfs.getCompactionStrategy().getScanners(sstables,validator.desc.range)){
      CompactionIterable ci=new ValidationCompactionIterable(cfs,scanners.scanners,gcBefore);
      Iterator<AbstractCompactedRow> iter=ci.iterator();
      metrics.beginCompaction(ci);
      try {
        validator.prepare(cfs,tree);
        while (iter.hasNext()) {
          if (ci.isStopRequested())           throw new CompactionInterruptedException(ci.getCompactionInfo());
          AbstractCompactedRow row=iter.next();
          validator.add(row);
        }
        validator.complete();
      }
  finally {
        if (isSnapshotValidation) {
          cfs.clearSnapshot(snapshotName);
        }
        metrics.finishCompaction(ci);
      }
    }
     if (logger.isDebugEnabled()) {
      long duration=TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
      logger.debug("Validation finished in {} msec, depth {} for {} keys, serialized size {} bytes for {}",duration,depth,numPartitions,MerkleTree.serializer.serializedSize(tree,0),validator.desc);
    }
  }
  finally {
    if (sstables != null)     sstables.release();
  }
}
