{
  if (!cfs.isValid())   return;
  Refs<SSTableReader> sstables=null;
  try {
    String snapshotName=validator.desc.sessionId.toString();
    int gcBefore;
    int nowInSec=FBUtilities.nowInSeconds();
    boolean isSnapshotValidation=cfs.snapshotExists(snapshotName);
    if (isSnapshotValidation) {
      sstables=cfs.getSnapshotSSTableReader(snapshotName);
      gcBefore=cfs.gcBefore((int)(cfs.getSnapshotCreationTime(snapshotName) / 1000));
    }
 else {
      StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(),cfs.name);
      ActiveRepairService.ParentRepairSession prs=ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId);
      ColumnFamilyStore.RefViewFragment sstableCandidates=cfs.selectAndReference(prs.isIncremental ? ColumnFamilyStore.UNREPAIRED_SSTABLES : ColumnFamilyStore.CANONICAL_SSTABLES);
      Set<SSTableReader> sstablesToValidate=new HashSet<>();
      for (      SSTableReader sstable : sstableCandidates.sstables) {
        if (new Bounds<>(sstable.first.getToken(),sstable.last.getToken()).intersects(Collections.singletonList(validator.desc.range))) {
          sstablesToValidate.add(sstable);
        }
      }
      Set<SSTableReader> currentlyRepairing=ActiveRepairService.instance.currentlyRepairing(cfs.metadata.cfId,validator.desc.parentSessionId);
      if (!Sets.intersection(currentlyRepairing,sstablesToValidate).isEmpty()) {
        logger.error("Cannot start multiple repair sessions over the same sstables");
        throw new RuntimeException("Cannot start multiple repair sessions over the same sstables");
      }
      sstables=Refs.tryRef(sstablesToValidate);
      if (sstables == null) {
        logger.error("Could not reference sstables");
        throw new RuntimeException("Could not reference sstables");
      }
      sstableCandidates.release();
      prs.addSSTables(cfs.metadata.cfId,sstablesToValidate);
      if (validator.gcBefore > 0)       gcBefore=validator.gcBefore;
 else       gcBefore=getDefaultGcBefore(cfs,nowInSec);
    }
    long numPartitions=0;
    for (    SSTableReader sstable : sstables) {
      numPartitions+=sstable.estimatedKeysForRanges(singleton(validator.desc.range));
    }
    int depth=numPartitions > 0 ? (int)Math.min(Math.floor(Math.log(numPartitions)),20) : 0;
    MerkleTree tree=new MerkleTree(cfs.partitioner,validator.desc.range,MerkleTree.RECOMMENDED_DEPTH,(int)Math.pow(2,depth));
    long start=System.nanoTime();
    try (AbstractCompactionStrategy.ScannerList scanners=cfs.getCompactionStrategyManager().getScanners(sstables,validator.desc.range);ValidationCompactionController controller=new ValidationCompactionController(cfs,gcBefore);CompactionIterator ci=new ValidationCompactionIterator(scanners.scanners,controller,nowInSec,metrics)){
      validator.prepare(cfs,tree);
      while (ci.hasNext()) {
        if (ci.isStopRequested())         throw new CompactionInterruptedException(ci.getCompactionInfo());
        try (UnfilteredRowIterator partition=ci.next()){
          validator.add(partition);
        }
       }
      validator.complete();
    }
  finally {
      if (isSnapshotValidation) {
        cfs.clearSnapshot(snapshotName);
      }
    }
    if (logger.isDebugEnabled()) {
      long duration=TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
      logger.debug("Validation finished in {} msec, depth {} for {} keys, serialized size {} bytes for {}",duration,depth,numPartitions,MerkleTree.serializer.serializedSize(tree,0),validator.desc);
    }
  }
  finally {
    if (sstables != null)     sstables.release();
  }
}
