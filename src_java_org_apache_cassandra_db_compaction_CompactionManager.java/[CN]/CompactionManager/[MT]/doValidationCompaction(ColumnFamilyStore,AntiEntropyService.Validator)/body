{
  if (!cfs.isValid())   return;
  Collection<SSTableReader> sstables;
  int gcBefore;
  boolean isSnapshotValidation=cfs.snapshotExists(validator.request.sessionid);
  if (isSnapshotValidation) {
    sstables=cfs.getSnapshotSSTableReader(validator.request.sessionid);
    gcBefore=(int)(cfs.getSnapshotCreationTime(validator.request.sessionid) / 1000) - cfs.metadata.getGcGraceSeconds();
  }
 else {
    try {
      StorageService.instance.forceTableFlush(cfs.table.name,cfs.getColumnFamilyName());
    }
 catch (    ExecutionException e) {
      throw new IOException(e);
    }
catch (    InterruptedException e) {
      throw new AssertionError(e);
    }
    sstables=cfs.markCurrentSSTablesReferenced();
    gcBefore=getDefaultGcBefore(cfs);
  }
  CompactionIterable ci=new ValidationCompactionIterable(cfs,sstables,validator.request.range,gcBefore);
  CloseableIterator<AbstractCompactedRow> iter=ci.iterator();
  metrics.beginCompaction(ci);
  try {
    validator.prepare(cfs);
    while (iter.hasNext()) {
      if (ci.isStopRequested())       throw new CompactionInterruptedException(ci.getCompactionInfo());
      AbstractCompactedRow row=iter.next();
      if (row.isEmpty())       row.close();
 else       validator.add(row);
    }
    validator.complete();
  }
  finally {
    iter.close();
    if (isSnapshotValidation) {
      for (      SSTableReader sstable : sstables)       FileUtils.closeQuietly(sstable);
      cfs.clearSnapshot(validator.request.sessionid);
    }
 else {
      SSTableReader.releaseReferences(sstables);
    }
    metrics.finishCompaction(ci);
  }
}
