{
  long groupMaxDataAge=-1;
  for (Iterator<SSTableReader> i=anticompactionGroup.iterator(); i.hasNext(); ) {
    SSTableReader sstable=i.next();
    if (!new File(sstable.getFilename()).exists()) {
      logger.info("Skipping anticompaction for {}, required sstable was compacted and is no longer available.",sstable);
      i.remove();
      continue;
    }
    if (groupMaxDataAge < sstable.maxDataAge)     groupMaxDataAge=sstable.maxDataAge;
  }
  if (anticompactionGroup.size() == 0) {
    logger.info("No valid anticompactions for this group, All sstables were compacted and are no longer available");
    return 0;
  }
  logger.info("Anticompacting {}",anticompactionGroup);
  Set<SSTableReader> sstableAsSet=new HashSet<>(anticompactionGroup);
  File destination=cfs.directories.getDirectoryForNewSSTables();
  SSTableRewriter repairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,groupMaxDataAge,OperationType.ANTICOMPACTION,false);
  SSTableRewriter unRepairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,groupMaxDataAge,OperationType.ANTICOMPACTION,false);
  AbstractCompactionStrategy strategy=cfs.getCompactionStrategy();
  List<ICompactionScanner> scanners=strategy.getScanners(anticompactionGroup);
  int expectedBloomFilterSize=Math.max(cfs.metadata.getMinIndexInterval(),(int)(SSTableReader.getApproximateKeyCount(anticompactionGroup)));
  long repairedKeyCount=0;
  long unrepairedKeyCount=0;
  try (CompactionController controller=new CompactionController(cfs,sstableAsSet,CFMetaData.DEFAULT_GC_GRACE_SECONDS)){
    repairedSSTableWriter.switchWriter(CompactionManager.createWriterForAntiCompaction(cfs,destination,expectedBloomFilterSize,repairedAt,sstableAsSet));
    unRepairedSSTableWriter.switchWriter(CompactionManager.createWriterForAntiCompaction(cfs,destination,expectedBloomFilterSize,ActiveRepairService.UNREPAIRED_SSTABLE,sstableAsSet));
    CompactionIterable ci=new CompactionIterable(OperationType.ANTICOMPACTION,scanners,controller);
    try (CloseableIterator<AbstractCompactedRow> iter=ci.iterator()){
      while (iter.hasNext()) {
        AbstractCompactedRow row=iter.next();
        if (Range.isInRanges(row.key.getToken(),ranges)) {
          repairedSSTableWriter.append(row);
          repairedKeyCount++;
        }
 else {
          unRepairedSSTableWriter.append(row);
          unrepairedKeyCount++;
        }
      }
    }
     repairedSSTableWriter.finish(false,repairedAt);
    unRepairedSSTableWriter.finish(ActiveRepairService.UNREPAIRED_SSTABLE);
    logger.debug("Repaired {} keys out of {} for {}/{} in {}",repairedKeyCount,repairedKeyCount + unrepairedKeyCount,cfs.keyspace.getName(),cfs.getColumnFamilyName(),anticompactionGroup);
    return repairedSSTableWriter.finished().size() + unRepairedSSTableWriter.finished().size();
  }
 catch (  Throwable e) {
    logger.error("Error anticompacting " + anticompactionGroup,e);
    repairedSSTableWriter.abort();
    unRepairedSSTableWriter.abort();
  }
  return 0;
}
