{
  List<SSTableReader> anticompactedSSTables=new ArrayList<>();
  int repairedKeyCount=0;
  int unrepairedKeyCount=0;
  int expectedBloomFilterSize=Math.max(cfs.metadata.getMinIndexInterval(),(int)(SSTableReader.getApproximateKeyCount(repairedSSTables)));
  logger.info("Performing anticompaction on {} sstables",repairedSSTables.size());
  for (  SSTableReader sstable : repairedSSTables) {
    if (!new File(sstable.getFilename()).exists()) {
      logger.info("Skipping anticompaction for {}, required sstable was compacted and is no longer available.",sstable);
      continue;
    }
    logger.info("Anticompacting {}",sstable);
    Set<SSTableReader> sstableAsSet=new HashSet<>();
    sstableAsSet.add(sstable);
    File destination=cfs.directories.getDirectoryForNewSSTables();
    SSTableRewriter repairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,sstable.maxDataAge,OperationType.ANTICOMPACTION,false);
    SSTableRewriter unRepairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,sstable.maxDataAge,OperationType.ANTICOMPACTION,false);
    AbstractCompactionStrategy strategy=cfs.getCompactionStrategy();
    try (AbstractCompactionStrategy.ScannerList scanners=strategy.getScanners(new HashSet<>(Collections.singleton(sstable)));CompactionController controller=new CompactionController(cfs,sstableAsSet,CFMetaData.DEFAULT_GC_GRACE_SECONDS)){
      repairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,repairedAt,sstable));
      unRepairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,ActiveRepairService.UNREPAIRED_SSTABLE,sstable));
      CompactionIterable ci=new CompactionIterable(OperationType.ANTICOMPACTION,scanners.scanners,controller);
      Iterator<AbstractCompactedRow> iter=ci.iterator();
      while (iter.hasNext()) {
        AbstractCompactedRow row=iter.next();
        if (Range.isInRanges(row.key.getToken(),ranges)) {
          repairedSSTableWriter.append(row);
          repairedKeyCount++;
        }
 else {
          unRepairedSSTableWriter.append(row);
          unrepairedKeyCount++;
        }
      }
      repairedSSTableWriter.finish(false,repairedAt);
      unRepairedSSTableWriter.finish(ActiveRepairService.UNREPAIRED_SSTABLE);
      anticompactedSSTables.addAll(repairedSSTableWriter.finished());
      anticompactedSSTables.addAll(unRepairedSSTableWriter.finished());
    }
 catch (    Throwable e) {
      logger.error("Error anticompacting " + sstable,e);
      repairedSSTableWriter.abort();
      unRepairedSSTableWriter.abort();
    }
  }
  String format="Repaired {} keys of {} for {}/{}";
  logger.debug(format,repairedKeyCount,(repairedKeyCount + unrepairedKeyCount),cfs.keyspace,cfs.getColumnFamilyName());
  String format2="Anticompaction completed successfully, anticompacted from {} to {} sstable(s).";
  logger.info(format2,repairedSSTables.size(),anticompactedSSTables.size());
  return anticompactedSSTables;
}
