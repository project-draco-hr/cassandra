{
  List<SSTableReader> anticompactedSSTables=new ArrayList<>();
  int repairedKeyCount=0;
  int unrepairedKeyCount=0;
  logger.info("Performing anticompaction on {} sstables",repairedSSTables.size());
  Set<SSTableReader> successfullyAntiCompactedSSTables=new HashSet<>();
  for (  SSTableReader sstable : repairedSSTables) {
    if (!new File(sstable.getFilename()).exists()) {
      logger.info("Skipping anticompaction for {}, required sstable was compacted and is no longer available.",sstable);
      continue;
    }
    logger.info("Anticompacting {}",sstable);
    Set<SSTableReader> sstableAsSet=new HashSet<>();
    sstableAsSet.add(sstable);
    File destination=cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(sstableAsSet,OperationType.ANTICOMPACTION));
    SSTableRewriter repairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,sstable.maxDataAge,false,false);
    SSTableRewriter unRepairedSSTableWriter=new SSTableRewriter(cfs,sstableAsSet,sstable.maxDataAge,false,false);
    try (AbstractCompactionStrategy.ScannerList scanners=cfs.getCompactionStrategy().getScanners(new HashSet<>(Collections.singleton(sstable)));CompactionController controller=new CompactionController(cfs,sstableAsSet,getDefaultGcBefore(cfs))){
      int expectedBloomFilterSize=Math.max(cfs.metadata.getMinIndexInterval(),(int)sstable.estimatedKeys());
      repairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,repairedAt,sstable));
      unRepairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,ActiveRepairService.UNREPAIRED_SSTABLE,sstable));
      CompactionIterable ci=new CompactionIterable(OperationType.ANTICOMPACTION,scanners.scanners,controller);
      Iterator<AbstractCompactedRow> iter=ci.iterator();
      metrics.beginCompaction(ci);
      try {
        Range.OrderedRangeContainmentChecker containmentChecker=new Range.OrderedRangeContainmentChecker(ranges);
        while (iter.hasNext()) {
          AbstractCompactedRow row=iter.next();
          if (containmentChecker.contains(row.key.getToken())) {
            repairedSSTableWriter.append(row);
            repairedKeyCount++;
          }
 else {
            unRepairedSSTableWriter.append(row);
            unrepairedKeyCount++;
          }
        }
      }
  finally {
        metrics.finishCompaction(ci);
      }
      anticompactedSSTables.addAll(repairedSSTableWriter.finish(repairedAt));
      anticompactedSSTables.addAll(unRepairedSSTableWriter.finish(ActiveRepairService.UNREPAIRED_SSTABLE));
      successfullyAntiCompactedSSTables.add(sstable);
      cfs.getDataTracker().unmarkCompacting(sstableAsSet);
    }
 catch (    Throwable e) {
      JVMStabilityInspector.inspectThrowable(e);
      logger.error("Error anticompacting " + sstable,e);
      repairedSSTableWriter.abort();
      unRepairedSSTableWriter.abort();
    }
  }
  cfs.getDataTracker().markCompactedSSTablesReplaced(successfullyAntiCompactedSSTables,anticompactedSSTables,OperationType.ANTICOMPACTION);
  String format="Repaired {} keys of {} for {}/{}";
  logger.debug(format,repairedKeyCount,(repairedKeyCount + unrepairedKeyCount),cfs.keyspace,cfs.getColumnFamilyName());
  String format2="Anticompaction completed successfully, anticompacted from {} to {} sstable(s).";
  logger.info(format2,repairedSSTables.size(),anticompactedSSTables.size());
  return anticompactedSSTables;
}
