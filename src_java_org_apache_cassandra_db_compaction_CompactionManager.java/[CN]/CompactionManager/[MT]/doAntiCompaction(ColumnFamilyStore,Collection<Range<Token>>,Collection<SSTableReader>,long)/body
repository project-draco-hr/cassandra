{
  List<SSTableReader> anticompactedSSTables=new ArrayList<>();
  int repairedKeyCount=0;
  int unrepairedKeyCount=0;
  int expectedBloomFilterSize=Math.max(cfs.metadata.getIndexInterval(),(int)(SSTableReader.getApproximateKeyCount(repairedSSTables)));
  logger.info("Performing anticompaction on {} sstables",repairedSSTables.size());
  for (  SSTableReader sstable : repairedSSTables) {
    if (!new File(sstable.getFilename()).exists()) {
      logger.info("Skipping anticompaction for {}, required sstable was compacted and is no longer available.",sstable);
      continue;
    }
    logger.info("Anticompacting {}",sstable);
    File destination=cfs.directories.getDirectoryForNewSSTables();
    SSTableWriter repairedSSTableWriter=CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,repairedAt,sstable);
    SSTableWriter unRepairedSSTableWriter=CompactionManager.createWriter(cfs,destination,expectedBloomFilterSize,ActiveRepairService.UNREPAIRED_SSTABLE,sstable);
    try (CompactionController controller=new CompactionController(cfs,new HashSet<>(Collections.singleton(sstable)),CFMetaData.DEFAULT_GC_GRACE_SECONDS)){
      AbstractCompactionStrategy strategy=cfs.getCompactionStrategy();
      List<ICompactionScanner> scanners=strategy.getScanners(Arrays.asList(sstable));
      CompactionIterable ci=new CompactionIterable(OperationType.ANTICOMPACTION,scanners,controller);
      try (CloseableIterator<AbstractCompactedRow> iter=ci.iterator()){
        while (iter.hasNext()) {
          AbstractCompactedRow row=iter.next();
          if (Range.isInRanges(row.key.token,ranges)) {
            repairedSSTableWriter.append(row);
            repairedKeyCount++;
          }
 else {
            unRepairedSSTableWriter.append(row);
            unrepairedKeyCount++;
          }
        }
      }
       if (repairedKeyCount > 0)       anticompactedSSTables.add(repairedSSTableWriter.closeAndOpenReader(sstable.maxDataAge));
 else       repairedSSTableWriter.abort();
      if (unrepairedKeyCount > 0)       anticompactedSSTables.add(unRepairedSSTableWriter.closeAndOpenReader(sstable.maxDataAge));
 else       unRepairedSSTableWriter.abort();
    }
 catch (    Throwable e) {
      logger.error("Error anticompacting " + sstable,e);
      repairedSSTableWriter.abort();
      unRepairedSSTableWriter.abort();
    }
  }
  String format="Repaired {} keys of {} for {}/{}";
  logger.debug(format,repairedKeyCount,(repairedKeyCount + unrepairedKeyCount),cfs.keyspace,cfs.getColumnFamilyName());
  String format2="Anticompaction completed successfully, anticompacted from {} to {} sstable(s).";
  logger.info(format2,repairedSSTables.size(),anticompactedSSTables.size());
  return anticompactedSSTables;
}
