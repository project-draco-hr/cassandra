{
  logger.info("Starting anticompaction for {}.{} on {}/{} sstables",cfs.keyspace.getName(),cfs.getColumnFamilyName(),validatedForRepair.size(),cfs.getSSTables().size());
  logger.debug("Starting anticompaction for ranges {}",ranges);
  Set<SSTableReader> sstables=new HashSet<>(validatedForRepair);
  Set<SSTableReader> mutatedRepairStatuses=new HashSet<>();
  Set<SSTableReader> nonAnticompacting=new HashSet<>();
  Iterator<SSTableReader> sstableIterator=sstables.iterator();
  try {
    List<Range<Token>> normalizedRanges=Range.normalize(ranges);
    while (sstableIterator.hasNext()) {
      SSTableReader sstable=sstableIterator.next();
      Range<Token> sstableRange=new Range<>(sstable.first.getToken(),sstable.last.getToken(),sstable.partitioner);
      boolean shouldAnticompact=false;
      for (      Range<Token> r : normalizedRanges) {
        if (r.contains(sstableRange)) {
          logger.info("SSTable {} fully contained in range {}, mutating repairedAt instead of anticompacting",sstable,r);
          sstable.descriptor.getMetadataSerializer().mutateRepairedAt(sstable.descriptor,repairedAt);
          sstable.reloadSSTableMetadata();
          mutatedRepairStatuses.add(sstable);
          sstableIterator.remove();
          shouldAnticompact=true;
          break;
        }
 else         if (sstableRange.intersects(r)) {
          logger.info("SSTable {} ({}) will be anticompacted on range {}",sstable,sstableRange,r);
          shouldAnticompact=true;
        }
      }
      if (!shouldAnticompact) {
        logger.info("SSTable {} ({}) does not intersect repaired ranges {}, not touching repairedAt.",sstable,sstableRange,normalizedRanges);
        nonAnticompacting.add(sstable);
        sstableIterator.remove();
      }
    }
    validatedForRepair.release(Sets.union(nonAnticompacting,mutatedRepairStatuses));
    cfs.getDataTracker().notifySSTableRepairedStatusChanged(mutatedRepairStatuses);
    cfs.getDataTracker().unmarkCompacting(Sets.union(nonAnticompacting,mutatedRepairStatuses));
    if (!sstables.isEmpty())     doAntiCompaction(cfs,ranges,sstables,repairedAt);
  }
  finally {
    validatedForRepair.release();
    cfs.getDataTracker().unmarkCompacting(sstables);
  }
  logger.info("Completed anticompaction successfully");
}
