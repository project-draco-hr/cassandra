{
  Callable<Object> callable=new Callable<Object>(){
    public Object call() throws IOException {
      compactionLock.readLock().lock();
      try {
        if (cfs.isInvalid())         return this;
        Collection<SSTableReader> sstables=new ArrayList<SSTableReader>();
        for (        Descriptor desc : dataFiles) {
          SSTableReader sstable=lookupSSTable(cfs,desc);
          if (sstable == null) {
            logger.info("Will not compact {}: it is not an active sstable",desc);
          }
 else {
            sstables.add(sstable);
          }
        }
        Collection<SSTableReader> toCompact;
        try {
          if (sstables.isEmpty()) {
            logger.error("No file to compact for user defined compaction");
          }
 else           if ((toCompact=cfs.getDataTracker().markCompacting(sstables,1,Integer.MAX_VALUE)) != null) {
            try {
              AbstractCompactionStrategy strategy=cfs.getCompactionStrategy();
              AbstractCompactionTask task=strategy.getUserDefinedTask(toCompact,gcBefore);
              task.execute(executor);
            }
  finally {
              cfs.getDataTracker().unmarkCompacting(toCompact);
            }
          }
 else {
            logger.error("SSTables for user defined compaction are already being compacted.");
          }
        }
  finally {
          SSTableReader.releaseReferences(sstables);
        }
        return this;
      }
  finally {
        compactionLock.readLock().unlock();
      }
    }
  }
;
  return executor.submit(callable);
}
