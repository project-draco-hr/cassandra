{
  Iterable<SSTableReader> compactingSSTables=cfs.markAllCompacting();
  if (compactingSSTables == null) {
    logger.info("Aborting operation on {}.{} after failing to interrupt other compaction operations",cfs.keyspace.getName(),cfs.name);
    return AllSSTableOpStatus.ABORTED;
  }
  if (Iterables.isEmpty(compactingSSTables)) {
    logger.info("No sstables for {}.{}",cfs.keyspace.getName(),cfs.name);
    return AllSSTableOpStatus.SUCCESSFUL;
  }
  Set<SSTableReader> sstables=Sets.newHashSet(operation.filterSSTables(compactingSSTables));
  Set<SSTableReader> filteredAway=Sets.difference(Sets.newHashSet(compactingSSTables),sstables);
  cfs.getDataTracker().unmarkCompacting(filteredAway);
  final Set<SSTableReader> finished=Sets.newConcurrentHashSet();
  List<Future<Object>> futures=new ArrayList<>();
  try {
    for (    final SSTableReader sstable : sstables) {
      if (executor.isShutdown()) {
        logger.info("Executor has shut down, not submitting task");
        return AllSSTableOpStatus.ABORTED;
      }
      futures.add(executor.submit(new Callable<Object>(){
        @Override public Object call() throws Exception {
          try {
            operation.execute(sstable);
          }
  finally {
            cfs.getDataTracker().unmarkCompacting(Collections.singleton(sstable));
            finished.add(sstable);
          }
          return this;
        }
      }
));
    }
    FBUtilities.waitOnFutures(futures);
  }
  finally {
    cfs.getDataTracker().unmarkCompacting(Sets.difference(sstables,finished));
  }
  return AllSSTableOpStatus.SUCCESSFUL;
}
