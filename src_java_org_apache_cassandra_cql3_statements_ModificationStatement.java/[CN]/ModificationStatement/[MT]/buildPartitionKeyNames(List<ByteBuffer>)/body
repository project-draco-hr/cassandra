{
  CFDefinition cfDef=cfm.getCfDef();
  ColumnNameBuilder keyBuilderBase=cfDef.getKeyNameBuilder();
  List<ByteBuffer> keys=new ArrayList<ByteBuffer>();
  for (  CFDefinition.Name name : cfDef.partitionKeys()) {
    Restriction r=processedKeys.get(name.name);
    if (r == null)     throw new InvalidRequestException(String.format("Missing mandatory PRIMARY KEY part %s",name));
    List<ByteBuffer> values=r.values(variables);
    if (keyBuilderBase.remainingCount() == 1) {
      for (      ByteBuffer val : values) {
        if (val == null)         throw new InvalidRequestException(String.format("Invalid null value for partition key part %s",name));
        ColumnNameBuilder keyBuilder=keyBuilderBase.copy().add(val);
        if (keyBuilder.getLength() > FBUtilities.MAX_UNSIGNED_SHORT)         throw new InvalidRequestException(String.format("Partition key size %s exceeds maximum %s",keyBuilder.getLength(),FBUtilities.MAX_UNSIGNED_SHORT));
        ByteBuffer key=keyBuilder.build();
        ThriftValidation.validateKey(cfm,key);
        keys.add(key);
      }
    }
 else {
      if (values.size() != 1)       throw new InvalidRequestException("IN is only supported on the last column of the partition key");
      ByteBuffer val=values.get(0);
      if (val == null)       throw new InvalidRequestException(String.format("Invalid null value for partition key part %s",name));
      keyBuilderBase.add(val);
    }
  }
  return keys;
}
