{
  CFDefinition cfDef=cfm.getCfDef();
  for (  Relation relation : whereClause) {
    if (!(relation instanceof SingleColumnRelation)) {
      throw new InvalidRequestException(String.format("Multi-column relations cannot be used in WHERE clauses for UPDATE and DELETE statements: %s",relation));
    }
    SingleColumnRelation rel=(SingleColumnRelation)relation;
    if (rel.onToken)     throw new InvalidRequestException(String.format("The token function cannot be used in WHERE clauses for UPDATE and DELETE statements: %s",relation));
    ColumnIdentifier id=rel.getEntity().prepare(cfm);
    CFDefinition.Name name=cfDef.get(id);
    if (name == null)     throw new InvalidRequestException(String.format("Unknown key identifier %s",id));
switch (name.kind) {
case KEY_ALIAS:
case COLUMN_ALIAS:
      Restriction restriction;
    if (rel.operator() == Relation.Type.EQ) {
      Term t=rel.getValue().prepare(name);
      t.collectMarkerSpecification(names);
      restriction=new SingleColumnRestriction.EQ(t,false);
    }
 else     if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS && rel.operator() == Relation.Type.IN) {
      if (rel.getValue() != null) {
        Term t=rel.getValue().prepare(name);
        t.collectMarkerSpecification(names);
        restriction=new SingleColumnRestriction.InWithMarker((Lists.Marker)t);
      }
 else {
        List<Term> values=new ArrayList<Term>(rel.getInValues().size());
        for (        Term.Raw raw : rel.getInValues()) {
          Term t=raw.prepare(name);
          t.collectMarkerSpecification(names);
          values.add(t);
        }
        restriction=new SingleColumnRestriction.InWithValues(values);
      }
    }
 else {
      throw new InvalidRequestException(String.format("Invalid operator %s for PRIMARY KEY part %s",rel.operator(),name));
    }
  addKeyValues(name,restriction);
break;
case VALUE_ALIAS:
case COLUMN_METADATA:
case STATIC:
throw new InvalidRequestException(String.format("Non PRIMARY KEY %s found in where clause",name));
}
}
}
