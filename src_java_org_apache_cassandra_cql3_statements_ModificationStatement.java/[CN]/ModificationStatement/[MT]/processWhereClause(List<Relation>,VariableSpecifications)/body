{
  for (  Relation relation : whereClause) {
    if (relation.isMultiColumn()) {
      throw new InvalidRequestException(String.format("Multi-column relations cannot be used in WHERE clauses for UPDATE and DELETE statements: %s",relation));
    }
    SingleColumnRelation rel=(SingleColumnRelation)relation;
    if (rel.onToken())     throw new InvalidRequestException(String.format("The token function cannot be used in WHERE clauses for UPDATE and DELETE statements: %s",relation));
    ColumnIdentifier id=rel.getEntity().prepare(cfm);
    ColumnDefinition def=cfm.getColumnDefinition(id);
    if (def == null)     throw new InvalidRequestException(String.format("Unknown key identifier %s",id));
switch (def.kind) {
case PARTITION_KEY:
case CLUSTERING:
      Restriction restriction;
    if (rel.isEQ() || (def.isPartitionKey() && rel.isIN())) {
      restriction=rel.toRestriction(cfm,names);
    }
 else {
      throw new InvalidRequestException(String.format("Invalid operator %s for PRIMARY KEY part %s",rel.operator(),def.name));
    }
  addKeyValues(def,restriction);
break;
default :
throw new InvalidRequestException(String.format("Non PRIMARY KEY %s found in where clause",def.name));
}
}
}
