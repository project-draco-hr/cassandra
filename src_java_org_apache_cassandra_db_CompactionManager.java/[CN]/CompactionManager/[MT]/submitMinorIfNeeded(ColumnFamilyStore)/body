{
  Callable<Integer> callable=new Callable<Integer>(){
    public Integer call() throws IOException {
      compactionLock.readLock().lock();
      try {
        if (cfs.isInvalid())         return 0;
        Integer minThreshold=cfs.getMinimumCompactionThreshold();
        Integer maxThreshold=cfs.getMaximumCompactionThreshold();
        if (minThreshold == 0 || maxThreshold == 0) {
          logger.debug("Compaction is currently disabled.");
          return 0;
        }
        logger.debug("Checking to see if compaction of " + cfs.columnFamily + " would be useful");
        Set<List<SSTableReader>> buckets=getBuckets(convertSSTablesToPairs(cfs.getSSTables()),50L * 1024L * 1024L);
        updateEstimateFor(cfs,buckets);
        int gcBefore=cfs.isIndex() ? Integer.MAX_VALUE : getDefaultGcBefore(cfs);
        for (        List<SSTableReader> sstables : buckets) {
          if (sstables.size() < minThreshold)           continue;
          Collections.sort(sstables);
          Collection<SSTableReader> tocompact=cfs.getDataTracker().markCompacting(sstables,minThreshold,maxThreshold);
          if (tocompact == null)           continue;
          try {
            return doCompaction(cfs,tocompact,gcBefore);
          }
  finally {
            cfs.getDataTracker().unmarkCompacting(tocompact);
          }
        }
      }
  finally {
        compactionLock.readLock().unlock();
      }
      return 0;
    }
  }
;
  return executor.submit(callable);
}
