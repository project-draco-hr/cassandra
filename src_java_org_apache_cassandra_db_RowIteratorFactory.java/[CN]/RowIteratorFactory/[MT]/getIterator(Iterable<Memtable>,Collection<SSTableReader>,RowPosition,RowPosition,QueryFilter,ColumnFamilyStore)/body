{
  final List<CloseableIterator<OnDiskAtomIterator>> iterators=new ArrayList<CloseableIterator<OnDiskAtomIterator>>();
  for (  Memtable memtable : memtables) {
    iterators.add(new ConvertToColumnIterator<AtomicSortedColumns>(filter,memtable.getEntryIterator(startWith,stopAt)));
  }
  for (  SSTableReader sstable : sstables) {
    final SSTableScanner scanner=sstable.getScanner(filter,startWith);
    iterators.add(scanner);
  }
  return MergeIterator.get(iterators,COMPARE_BY_KEY,new MergeIterator.Reducer<OnDiskAtomIterator,Row>(){
    private final int gcBefore=cfs.gcBefore(filter.timestamp);
    private final List<OnDiskAtomIterator> colIters=new ArrayList<OnDiskAtomIterator>();
    private DecoratedKey key;
    private ColumnFamily returnCF;
    @Override protected void onKeyChange(){
      this.returnCF=TreeMapBackedSortedColumns.factory.create(cfs.metadata);
    }
    public void reduce(    OnDiskAtomIterator current){
      this.colIters.add(current);
      this.key=current.getKey();
      this.returnCF.delete(current.getColumnFamily());
    }
    protected Row getReduced(){
      ColumnFamily cached=cfs.getRawCachedRow(key);
      if (cached == null) {
        filter.collateOnDiskAtom(returnCF,colIters,gcBefore);
      }
 else {
        QueryFilter keyFilter=new QueryFilter(key,filter.cfName,filter.filter,filter.timestamp);
        returnCF=cfs.filterColumnFamily(cached,keyFilter);
      }
      Row rv=new Row(key,returnCF);
      colIters.clear();
      key=null;
      return rv;
    }
  }
);
}
