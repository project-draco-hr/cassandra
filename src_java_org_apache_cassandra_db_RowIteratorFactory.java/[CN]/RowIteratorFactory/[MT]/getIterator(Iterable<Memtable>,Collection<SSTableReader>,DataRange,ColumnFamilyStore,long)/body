{
  final List<CloseableIterator<OnDiskAtomIterator>> iterators=new ArrayList<>(Iterables.size(memtables) + sstables.size());
  for (  Memtable memtable : memtables)   iterators.add(new ConvertToColumnIterator(range,memtable.getEntryIterator(range.startKey(),range.stopKey())));
  for (  SSTableReader sstable : sstables)   iterators.add(sstable.getScanner(range));
  return MergeIterator.get(iterators,COMPARE_BY_KEY,new MergeIterator.Reducer<OnDiskAtomIterator,Row>(){
    private final int gcBefore=cfs.gcBefore(now);
    private final List<OnDiskAtomIterator> colIters=new ArrayList<>();
    private DecoratedKey key;
    private ColumnFamily returnCF;
    @Override protected void onKeyChange(){
      this.returnCF=ArrayBackedSortedColumns.factory.create(cfs.metadata,range.columnFilter.isReversed());
    }
    public void reduce(    OnDiskAtomIterator current){
      this.colIters.add(current);
      this.key=current.getKey();
      this.returnCF.delete(current.getColumnFamily());
    }
    protected Row getReduced(){
      ColumnFamily cached=cfs.getRawCachedRow(key);
      IDiskAtomFilter filter=range.columnFilter(key.getKey());
      try {
        if (cached == null || !cfs.isFilterFullyCoveredBy(filter,cached,now)) {
          QueryFilter.collateOnDiskAtom(returnCF,colIters,filter,gcBefore,now);
        }
 else {
          QueryFilter keyFilter=new QueryFilter(key,cfs.name,filter,now);
          returnCF=cfs.filterColumnFamily(cached,keyFilter);
        }
      }
 catch (      TombstoneOverwhelmingException e) {
        e.setKey(key);
        throw e;
      }
      Row rv=new Row(key,returnCF);
      colIters.clear();
      key=null;
      return rv;
    }
  }
);
}
