{
  FileInputStream tsf=null;
  FileInputStream ksf=null;
  SSLContext ctx;
  try {
    ctx=SSLContext.getInstance(options.protocol);
    TrustManager[] trustManagers=null;
    if (buildTruststore) {
      tsf=new FileInputStream(options.truststore);
      TrustManagerFactory tmf=TrustManagerFactory.getInstance(options.algorithm);
      KeyStore ts=KeyStore.getInstance(options.store_type);
      ts.load(tsf,options.truststore_password.toCharArray());
      tmf.init(ts);
      trustManagers=tmf.getTrustManagers();
    }
    ksf=new FileInputStream(options.keystore);
    KeyManagerFactory kmf=KeyManagerFactory.getInstance(options.algorithm);
    KeyStore ks=KeyStore.getInstance(options.store_type);
    ks.load(ksf,options.keystore_password.toCharArray());
    if (!checkedExpiry) {
      for (Enumeration<String> aliases=ks.aliases(); aliases.hasMoreElements(); ) {
        String alias=aliases.nextElement();
        if (ks.getCertificate(alias).getType().equals("X.509")) {
          Date expires=((X509Certificate)ks.getCertificate(alias)).getNotAfter();
          if (expires.before(new Date()))           logger.warn("Certificate for {} expired on {}",alias,expires);
        }
      }
      checkedExpiry=true;
    }
    kmf.init(ks,options.keystore_password.toCharArray());
    ctx.init(kmf.getKeyManagers(),trustManagers,null);
  }
 catch (  Exception e) {
    throw new IOException("Error creating the initializing the SSL Context",e);
  }
 finally {
    FileUtils.closeQuietly(tsf);
    FileUtils.closeQuietly(ksf);
  }
  return ctx;
}
