{
  argTypes=new ArrayList<>(argRawTypes.size());
  for (  CQL3Type.Raw rawType : argRawTypes)   argTypes.add(prepareType("arguments",rawType));
  AbstractType<?> stateType=prepareType("state type",stateTypeRaw);
  Function f=Functions.find(stateFunc,stateArguments(stateType,argTypes));
  if (!(f instanceof ScalarFunction))   throw new InvalidRequestException("State function " + stateFuncSig(stateFunc,stateTypeRaw,argRawTypes) + " does not exist or is not a scalar function");
  stateFunction=(ScalarFunction)f;
  AbstractType<?> stateReturnType=stateFunction.returnType();
  if (!stateReturnType.equals(stateType))   throw new InvalidRequestException("State function " + stateFuncSig(stateFunction.name(),stateTypeRaw,argRawTypes) + " return type must be the same as the first argument type - check STYPE, argument and return types");
  if (finalFunc != null) {
    f=Functions.find(finalFunc,Collections.<AbstractType<?>>singletonList(stateType));
    if (!(f instanceof ScalarFunction))     throw new InvalidRequestException("Final function " + finalFunc + '('+ stateTypeRaw+ ") does not exist or is not a scalar function");
    finalFunction=(ScalarFunction)f;
    returnType=finalFunction.returnType();
  }
 else {
    returnType=stateReturnType;
  }
  if (ival != null) {
    ColumnSpecification receiver=new ColumnSpecification(functionName.keyspace,"--dummy--",new ColumnIdentifier("(aggregate_initcond)",true),stateType);
    initcond=ival.prepare(functionName.keyspace,receiver).bindAndGet(QueryOptions.DEFAULT);
    if (Constants.NULL_LITERAL != ival && UDHelper.isNullOrEmpty(stateType,initcond))     throw new InvalidRequestException("INITCOND must not be empty for all types except TEXT, ASCII, BLOB");
  }
  return super.prepare();
}
