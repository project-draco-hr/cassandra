{
  List<ResampleEntry> toDownsample=new ArrayList<>(sstables.size() / 4);
  List<ResampleEntry> toUpsample=new ArrayList<>(sstables.size() / 4);
  List<SSTableReader> newSSTables=new ArrayList<>(sstables.size());
  long remainingSpace=memoryPoolCapacity;
  for (  SSTableReader sstable : sstables) {
    double readsPerSec=sstable.readMeter == null ? 0.0 : sstable.readMeter.fifteenMinuteRate();
    long idealSpace=Math.round(remainingSpace * (readsPerSec / totalReadsPerSec));
    int currentNumEntries=sstable.getIndexSummarySize();
    double avgEntrySize=sstable.getIndexSummaryOffHeapSize() / (double)currentNumEntries;
    long targetNumEntries=Math.max(1,Math.round(idealSpace / avgEntrySize));
    int currentSamplingLevel=sstable.getIndexSummarySamplingLevel();
    int newSamplingLevel=IndexSummaryBuilder.calculateSamplingLevel(currentSamplingLevel,currentNumEntries,targetNumEntries);
    int numEntriesAtNewSamplingLevel=IndexSummaryBuilder.entriesAtSamplingLevel(newSamplingLevel,sstable.getMaxIndexSummarySize());
    logger.trace("{} has {} reads/sec; ideal space for index summary: {} bytes ({} entries); considering moving from level " + "{} ({} entries) to level {} ({} entries)",sstable.getFilename(),readsPerSec,idealSpace,targetNumEntries,currentSamplingLevel,currentNumEntries,newSamplingLevel,numEntriesAtNewSamplingLevel);
    if (targetNumEntries >= currentNumEntries * UPSAMPLE_THRESHOLD && newSamplingLevel > currentSamplingLevel) {
      long spaceUsed=(long)Math.ceil(avgEntrySize * numEntriesAtNewSamplingLevel);
      toUpsample.add(new ResampleEntry(sstable,spaceUsed,newSamplingLevel));
      remainingSpace-=avgEntrySize * numEntriesAtNewSamplingLevel;
    }
 else     if (targetNumEntries < currentNumEntries * DOWNSAMPLE_THESHOLD && newSamplingLevel < currentSamplingLevel) {
      long spaceUsed=(long)Math.ceil(avgEntrySize * numEntriesAtNewSamplingLevel);
      toDownsample.add(new ResampleEntry(sstable,spaceUsed,newSamplingLevel));
      remainingSpace-=spaceUsed;
    }
 else {
      logger.trace("SSTable {} is within thresholds of ideal sampling",sstable);
      remainingSpace-=sstable.getIndexSummaryOffHeapSize();
      newSSTables.add(sstable);
    }
    totalReadsPerSec-=readsPerSec;
  }
  if (remainingSpace > 0) {
    Pair<List<SSTableReader>,List<ResampleEntry>> result=distributeRemainingSpace(toDownsample,remainingSpace);
    toDownsample=result.right;
    newSSTables.addAll(result.left);
  }
  toDownsample.addAll(toUpsample);
  Multimap<DataTracker,SSTableReader> replacedByTracker=HashMultimap.create();
  Multimap<DataTracker,SSTableReader> replacementsByTracker=HashMultimap.create();
  for (  ResampleEntry entry : toDownsample) {
    SSTableReader sstable=entry.sstable;
    logger.debug("Re-sampling index summary for {} from {}/{} to {}/{} of the original number of entries",sstable,sstable.getIndexSummarySamplingLevel(),Downsampling.BASE_SAMPLING_LEVEL,entry.newSamplingLevel,Downsampling.BASE_SAMPLING_LEVEL);
    SSTableReader replacement=sstable.cloneWithNewSummarySamplingLevel(entry.newSamplingLevel);
    DataTracker tracker=Keyspace.open(sstable.getKeyspaceName()).getColumnFamilyStore(sstable.getColumnFamilyName()).getDataTracker();
    replacedByTracker.put(tracker,sstable);
    replacementsByTracker.put(tracker,replacement);
  }
  for (  DataTracker tracker : replacedByTracker.keySet()) {
    tracker.replaceReaders(replacedByTracker.get(tracker),replacementsByTracker.get(tracker));
    newSSTables.addAll(replacementsByTracker.get(tracker));
  }
  return newSSTables;
}
