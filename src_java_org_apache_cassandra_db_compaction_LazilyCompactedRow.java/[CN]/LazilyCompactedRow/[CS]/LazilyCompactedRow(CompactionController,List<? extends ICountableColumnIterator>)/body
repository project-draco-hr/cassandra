{
  super(rows.get(0).getKey());
  this.rows=rows;
  this.controller=controller;
  indexer=controller.cfs.indexManager.updaterFor(key);
  long maxDelTimestamp=Long.MIN_VALUE;
  for (  OnDiskAtomIterator row : rows) {
    ColumnFamily cf=row.getColumnFamily();
    maxDelTimestamp=Math.max(maxDelTimestamp,cf.deletionInfo().maxTimestamp());
    if (emptyColumnFamily == null)     emptyColumnFamily=cf;
 else     emptyColumnFamily.delete(cf);
  }
  this.shouldPurge=controller.shouldPurge(key,maxDelTimestamp);
  try {
    indexAndWrite(null);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  columnStats=new ColumnStats(reducer == null ? 0 : reducer.columns,reducer == null ? Long.MAX_VALUE : reducer.minTimestampSeen,reducer == null ? maxDelTimestamp : Math.max(maxDelTimestamp,reducer.maxTimestampSeen),reducer == null ? Integer.MIN_VALUE : reducer.maxLocalDeletionTimeSeen,reducer == null ? new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE) : reducer.tombstones);
  columnSerializedSize=reducer == null ? 0 : reducer.serializedSize;
  reducer=null;
}
