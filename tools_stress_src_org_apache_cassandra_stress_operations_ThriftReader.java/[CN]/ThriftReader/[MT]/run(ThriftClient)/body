{
  final SlicePredicate predicate=slicePredicate();
  final ByteBuffer key=getKey();
  final List<ByteBuffer> expect=state.rowGen.isDeterministic() ? generateColumnValues(key) : null;
  for (  final ColumnParent parent : state.columnParents) {
    timeWithRetry(new RunOp(){
      @Override public boolean run() throws Exception {
        List<ColumnOrSuperColumn> row=client.get_slice(key,parent,predicate,state.settings.command.consistencyLevel);
        if (expect == null)         return !row.isEmpty();
        if (row == null)         return false;
        if (!state.settings.columns.useSuperColumns) {
          if (row.size() != expect.size())           return false;
          for (int i=0; i < row.size(); i++)           if (!row.get(i).getColumn().bufferForValue().equals(expect.get(i)))           return false;
        }
 else {
          for (          ColumnOrSuperColumn col : row) {
            SuperColumn superColumn=col.getSuper_column();
            if (superColumn.getColumns().size() != expect.size())             return false;
            for (int i=0; i < expect.size(); i++)             if (!superColumn.getColumns().get(i).bufferForValue().equals(expect.get(i)))             return false;
          }
        }
        return true;
      }
      @Override public String key(){
        return new String(key.array());
      }
      @Override public int keyCount(){
        return 1;
      }
    }
);
  }
}
