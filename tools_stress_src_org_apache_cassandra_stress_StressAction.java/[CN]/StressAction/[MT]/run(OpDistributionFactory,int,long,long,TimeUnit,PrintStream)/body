{
  output.println(String.format("Running %s with %d threads %s",operations.desc(),threadCount,durationUnits != null ? duration + " " + durationUnits.toString().toLowerCase() : opCount > 0 ? "for " + opCount + " iteration" : "until stderr of mean < " + settings.command.targetUncertainty));
  final WorkManager workManager;
  if (opCount < 0)   workManager=new ContinuousWorkManager();
 else   workManager=new FixedWorkManager(opCount);
  RateLimiter rateLimiter=null;
  if (settings.rate.opRateTargetPerSecond > 0)   rateLimiter=RateLimiter.create(settings.rate.opRateTargetPerSecond);
  final StressMetrics metrics=new StressMetrics(output,settings.log.intervalMillis);
  final CountDownLatch done=new CountDownLatch(threadCount);
  final Consumer[] consumers=new Consumer[threadCount];
  for (int i=0; i < threadCount; i++)   consumers[i]=new Consumer(operations,done,workManager,metrics,rateLimiter);
  for (int i=0; i < threadCount; i++)   consumers[i].start();
  metrics.start();
  if (durationUnits != null) {
    Uninterruptibles.sleepUninterruptibly(duration,durationUnits);
    workManager.stop();
  }
 else   if (opCount <= 0) {
    try {
      metrics.waitUntilConverges(settings.command.targetUncertainty,settings.command.minimumUncertaintyMeasurements,settings.command.maximumUncertaintyMeasurements);
    }
 catch (    InterruptedException e) {
    }
    workManager.stop();
  }
  try {
    done.await();
    metrics.stop();
  }
 catch (  InterruptedException e) {
  }
  if (metrics.wasCancelled())   return null;
  metrics.summarise();
  boolean success=true;
  for (  Consumer consumer : consumers)   success&=consumer.success;
  if (!success)   return null;
  return metrics;
}
