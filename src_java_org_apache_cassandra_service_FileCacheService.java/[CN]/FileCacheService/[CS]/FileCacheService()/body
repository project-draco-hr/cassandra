{
  RemovalListener<String,Queue<RandomAccessReader>> onRemove=new RemovalListener<String,Queue<RandomAccessReader>>(){
    @Override public void onRemoval(    RemovalNotification<String,Queue<RandomAccessReader>> notification){
      Queue<RandomAccessReader> cachedInstances=notification.getValue();
      if (cachedInstances == null)       return;
      if (cachedInstances.size() > 0)       logger.debug("Evicting cold readers for {}",cachedInstances.peek().getPath());
      for (RandomAccessReader reader=cachedInstances.poll(); reader != null; reader=cachedInstances.poll()) {
        memoryUsage.addAndGet(-1 * reader.getTotalBufferSize());
        reader.deallocate();
      }
    }
  }
;
  cache=CacheBuilder.newBuilder().expireAfterAccess(AFTER_ACCESS_EXPIRATION,TimeUnit.MILLISECONDS).concurrencyLevel(DatabaseDescriptor.getConcurrentReaders()).removalListener(onRemove).build();
}
