{
  validateKey(key);
  CellNameType comparator=metadata.comparator;
  AbstractType<?> at=comparator.asAbstractType();
  boolean hasCounterColumn=false;
  Mutation mutation=new Mutation(keyspace,key);
  for (  Map.Entry<Term,Operation> column : getColumns().entrySet()) {
    CellName colName=comparator.cellFromByteBuffer(column.getKey().getByteBuffer(at,variables));
    Operation op=column.getValue();
    if (op.isUnary()) {
      if (hasCounterColumn)       throw new InvalidRequestException("Mix of commutative and non-commutative operations is not allowed.");
      ByteBuffer colValue=op.a.getByteBuffer(metadata.getValueValidator(colName),variables);
      validateColumn(metadata,colName,colValue);
      mutation.add(columnFamily,colName,colValue,(timestamp == null) ? getTimestamp(clientState) : timestamp,getTimeToLive());
    }
 else {
      hasCounterColumn=true;
      if (!column.getKey().getText().equals(op.a.getText()))       throw new InvalidRequestException("Only expressions like X = X + <long> are supported.");
      long value;
      try {
        value=Long.parseLong(op.b.getText());
      }
 catch (      NumberFormatException e) {
        throw new InvalidRequestException(String.format("'%s' is an invalid value, should be a long.",op.b.getText()));
      }
      mutation.addCounter(columnFamily,colName,value);
    }
  }
  return (hasCounterColumn) ? new CounterMutation(mutation,getConsistencyLevel()) : mutation;
}
