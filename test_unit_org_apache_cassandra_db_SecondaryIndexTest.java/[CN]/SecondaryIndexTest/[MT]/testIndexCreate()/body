{
  Keyspace keyspace=Keyspace.open(KEYSPACE1);
  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(COMPOSITE_INDEX_TO_BE_ADDED);
  new RowUpdateBuilder(cfs.metadata,0,"k1").clustering("c").add("birthdate",1L).build().applyUnsafe();
  ColumnDefinition old=cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("birthdate"));
  IndexMetadata indexDef=IndexMetadata.singleColumnIndex(old,"birthdate_index",IndexMetadata.IndexType.COMPOSITES,Collections.EMPTY_MAP);
  cfs.metadata.indexes(cfs.metadata.getIndexes().with(indexDef));
  Future<?> future=cfs.indexManager.addIndex(indexDef);
  future.get();
  ColumnDefinition cDef=cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("birthdate"));
  String indexName=getIndexNameForColumn(cfs,cDef);
  assertNotNull(indexName);
  boolean flushed=false;
  for (  ColumnFamilyStore indexCfs : cfs.indexManager.getAllIndexColumnFamilyStores()) {
    if (SecondaryIndexManager.getIndexName(indexCfs).equals(indexName))     flushed=indexCfs.getLiveSSTables().size() > 0;
  }
  assertTrue(flushed);
  assertIndexedOne(cfs,ByteBufferUtil.bytes("birthdate"),1L);
  assertTrue(cfs.getBuiltIndexes().contains(indexName));
  cfs.indexManager.removeIndex(indexDef.name);
  assertFalse(cfs.getBuiltIndexes().contains(indexName));
  future=cfs.indexManager.addIndex(indexDef);
  future.get();
  assertIndexedOne(cfs,ByteBufferUtil.bytes("birthdate"),1L);
}
