{
  List<Memtable> memtablesToFlush=Collections.emptyList();
  flusherLock.readLock().lock();
  try {
    if (writeCommitLog)     CommitLog.instance().add(mutation,serializedMutation);
    DecoratedKey key=StorageService.getPartitioner().decorateKey(mutation.key());
    for (    ColumnFamily cf : mutation.getColumnFamilies()) {
      ColumnFamilyStore cfs=columnFamilyStores.get(cf.id());
      if (cfs == null) {
        logger.error("Attempting to mutate non-existant column family " + cf.id());
        continue;
      }
      SortedSet<byte[]> mutatedIndexedColumns=null;
      for (      byte[] column : cfs.getIndexedColumns()) {
        if (cf.getColumnNames().contains(column)) {
          if (mutatedIndexedColumns == null)           mutatedIndexedColumns=new TreeSet<byte[]>(FBUtilities.byteArrayComparator);
          mutatedIndexedColumns.add(column);
        }
      }
      if (mutatedIndexedColumns == null) {
        Memtable fullMemtable=cfs.apply(key,cf);
        if (fullMemtable != null)         memtablesToFlush=addFullMemtable(memtablesToFlush,fullMemtable);
      }
 else {
synchronized (indexLockFor(mutation.key())) {
          ColumnFamily oldIndexedColumns=readCurrentIndexedColumns(key,cfs,mutatedIndexedColumns);
          ignoreObsoleteMutations(cf,cfs.metadata.reconciler,mutatedIndexedColumns,oldIndexedColumns);
          Memtable fullMemtable=cfs.apply(key,cf);
          if (fullMemtable != null)           memtablesToFlush=addFullMemtable(memtablesToFlush,fullMemtable);
          applyIndexUpdates(mutation.key(),cf,cfs,mutatedIndexedColumns,oldIndexedColumns);
        }
      }
      ColumnFamily cachedRow=cfs.getRawCachedRow(key);
      if (cachedRow != null)       cachedRow.addAll(cf);
    }
  }
  finally {
    flusherLock.readLock().unlock();
  }
  for (  Memtable memtable : memtablesToFlush)   memtable.cfs.maybeSwitchMemtable(memtable,writeCommitLog);
}
