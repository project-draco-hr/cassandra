{
  HashMap<ColumnFamilyStore,Memtable> memtablesToFlush=new HashMap<ColumnFamilyStore,Memtable>(2);
  flusherLock.readLock().lock();
  try {
    if (writeCommitLog)     CommitLog.instance().add(mutation,serializedMutation);
    DecoratedKey key=StorageService.getPartitioner().decorateKey(mutation.key());
    for (    ColumnFamily cf : mutation.getColumnFamilies()) {
      ColumnFamilyStore cfs=columnFamilyStores.get(cf.id());
      if (cfs == null) {
        logger.error("Attempting to mutate non-existant column family " + cf.id());
        continue;
      }
      SortedSet<byte[]> mutatedIndexedColumns=null;
      for (      byte[] column : cfs.getIndexedColumns()) {
        if (cf.getColumnNames().contains(column)) {
          if (mutatedIndexedColumns == null)           mutatedIndexedColumns=new TreeSet<byte[]>(FBUtilities.byteArrayComparator);
          mutatedIndexedColumns.add(column);
        }
      }
      if (mutatedIndexedColumns == null) {
        applyCF(cfs,key,cf,memtablesToFlush);
      }
 else {
synchronized (indexLockFor(mutation.key())) {
          QueryFilter filter=QueryFilter.getNamesFilter(key,new QueryPath(cfs.getColumnFamilyName()),mutatedIndexedColumns);
          ColumnFamily oldIndexedColumns=cfs.getColumnFamily(filter);
          if (oldIndexedColumns != null) {
            for (            IColumn oldColumn : oldIndexedColumns) {
              if (cfs.metadata.reconciler.reconcile((Column)oldColumn,(Column)cf.getColumn(oldColumn.name())).equals(oldColumn)) {
                cf.remove(oldColumn.name());
                mutatedIndexedColumns.remove(oldColumn.name());
                oldIndexedColumns.remove(oldColumn.name());
              }
            }
          }
          applyCF(cfs,key,cf,memtablesToFlush);
          for (          byte[] columnName : mutatedIndexedColumns) {
            IColumn column=cf.getColumn(columnName);
            DecoratedKey<LocalToken> valueKey=cfs.getIndexKeyFor(columnName,column.value());
            ColumnFamily cfi=cfs.newIndexedColumnFamily(columnName);
            cfi.addColumn(new Column(mutation.key(),ArrayUtils.EMPTY_BYTE_ARRAY,column.clock()));
            applyCF(cfs.getIndexedColumnFamilyStore(columnName),valueKey,cfi,memtablesToFlush);
          }
          if (oldIndexedColumns != null) {
            int localDeletionTime=(int)(System.currentTimeMillis() / 1000);
            for (            Map.Entry<byte[],IColumn> entry : oldIndexedColumns.getColumnsMap().entrySet()) {
              byte[] columnName=entry.getKey();
              IColumn column=entry.getValue();
              DecoratedKey<LocalToken> valueKey=cfs.getIndexKeyFor(columnName,column.value());
              ColumnFamily cfi=cfs.newIndexedColumnFamily(columnName);
              cfi.deleteColumn(mutation.key(),localDeletionTime,column.clock());
              applyCF(cfs.getIndexedColumnFamilyStore(columnName),valueKey,cfi,memtablesToFlush);
            }
          }
        }
      }
      ColumnFamily cachedRow=cfs.getRawCachedRow(key);
      if (cachedRow != null)       cachedRow.addAll(cf);
    }
  }
  finally {
    flusherLock.readLock().unlock();
  }
  for (  Map.Entry<ColumnFamilyStore,Memtable> entry : memtablesToFlush.entrySet())   entry.getKey().maybeSwitchMemtable(entry.getValue(),writeCommitLog);
}
