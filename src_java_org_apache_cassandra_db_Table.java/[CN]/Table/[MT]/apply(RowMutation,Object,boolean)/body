{
  HashMap<ColumnFamilyStore,Memtable> memtablesToFlush=new HashMap<ColumnFamilyStore,Memtable>(2);
  flusherLock.readLock().lock();
  try {
    if (writeCommitLog)     CommitLog.instance().add(mutation,serializedMutation);
    DecoratedKey key=StorageService.getPartitioner().decorateKey(mutation.key());
    for (    ColumnFamily cf : mutation.getColumnFamilies()) {
      ColumnFamilyStore cfs=columnFamilyStores.get(cf.id());
      if (cfs == null) {
        logger.error("Attempting to mutate non-existant column family " + cf.id());
        continue;
      }
      SortedSet<byte[]> mutatedIndexedColumns=null;
      for (      byte[] column : cfs.getIndexedColumns()) {
        if (cf.getColumnNames().contains(column)) {
          if (mutatedIndexedColumns == null)           mutatedIndexedColumns=new TreeSet<byte[]>(FBUtilities.byteArrayComparator);
          mutatedIndexedColumns.add(column);
        }
      }
      if (mutatedIndexedColumns == null) {
        applyCF(cfs,key,cf,memtablesToFlush);
      }
 else {
synchronized (indexLockFor(mutation.key())) {
          ColumnFamily oldIndexedColumns=readCurrentIndexedColumns(key,cfs,mutatedIndexedColumns);
          ignoreObsoleteMutations(cf,cfs.metadata.reconciler,mutatedIndexedColumns,oldIndexedColumns);
          applyCF(cfs,key,cf,memtablesToFlush);
          applyIndexUpdates(mutation.key(),memtablesToFlush,cf,cfs,mutatedIndexedColumns,oldIndexedColumns);
        }
      }
      ColumnFamily cachedRow=cfs.getRawCachedRow(key);
      if (cachedRow != null)       cachedRow.addAll(cf);
    }
  }
  finally {
    flusherLock.readLock().unlock();
  }
  for (  Map.Entry<ColumnFamilyStore,Memtable> entry : memtablesToFlush.entrySet())   entry.getKey().maybeSwitchMemtable(entry.getValue(),writeCommitLog,null);
}
