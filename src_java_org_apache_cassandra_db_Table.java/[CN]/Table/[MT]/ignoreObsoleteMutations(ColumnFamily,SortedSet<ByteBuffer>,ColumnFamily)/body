{
  if (oldIndexedColumns == null)   return;
  for (Iterator<ByteBuffer> iter=mutatedIndexedColumns.iterator(); iter.hasNext(); ) {
    ByteBuffer name=iter.next();
    IColumn newColumn=cf.getColumn(name);
    if (newColumn != null && cf.isMarkedForDelete())     throw new UnsupportedOperationException("Index manager cannot support deleting and inserting into a row in the same mutation");
    IColumn oldColumn=oldIndexedColumns.getColumn(name);
    boolean bothDeleted=(newColumn == null || newColumn.isMarkedForDelete()) && (oldColumn == null || oldColumn.isMarkedForDelete());
    boolean obsoleteRowTombstone=newColumn == null && oldColumn != null && cf.getMarkedForDeleteAt() < oldColumn.timestamp();
    boolean obsoleteColumn=newColumn != null && (newColumn.timestamp() <= oldIndexedColumns.getMarkedForDeleteAt() || (oldColumn != null && oldColumn.reconcile(newColumn) == oldColumn));
    if (bothDeleted || obsoleteRowTombstone || obsoleteColumn) {
      if (logger.isDebugEnabled())       logger.debug("skipping index update for obsolete mutation of " + cf.getComparator().getString(oldColumn.name()));
      iter.remove();
      oldIndexedColumns.remove(name);
    }
  }
}
