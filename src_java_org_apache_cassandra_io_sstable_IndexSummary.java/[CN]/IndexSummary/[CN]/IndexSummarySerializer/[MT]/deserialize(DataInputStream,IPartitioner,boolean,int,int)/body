{
  int minIndexInterval=in.readInt();
  if (minIndexInterval != expectedMinIndexInterval) {
    throw new IOException(String.format("Cannot read index summary because min_index_interval changed from %d to %d.",minIndexInterval,expectedMinIndexInterval));
  }
  int summarySize=in.readInt();
  long offheapSize=in.readLong();
  int samplingLevel, fullSamplingSummarySize;
  if (haveSamplingLevel) {
    samplingLevel=in.readInt();
    fullSamplingSummarySize=in.readInt();
  }
 else {
    samplingLevel=BASE_SAMPLING_LEVEL;
    fullSamplingSummarySize=summarySize;
  }
  int effectiveIndexInterval=(int)Math.ceil((BASE_SAMPLING_LEVEL / (double)samplingLevel) * minIndexInterval);
  if (effectiveIndexInterval > maxIndexInterval) {
    throw new IOException(String.format("Rebuilding index summary because the effective index interval (%d) is higher than" + " the current max index interval (%d)",effectiveIndexInterval,maxIndexInterval));
  }
  RefCountedMemory memory=new RefCountedMemory(offheapSize);
  FBUtilities.copy(in,new MemoryOutputStream(memory),offheapSize);
  return new IndexSummary(partitioner,memory,summarySize,fullSamplingSummarySize,minIndexInterval,samplingLevel);
}
