{
  this.output=output;
  this.settings=settings;
  Callable<JmxCollector.GcStats> gcStatsCollector;
  totalGcStats=new JmxCollector.GcStats(0);
  try {
    gcStatsCollector=new JmxCollector(settings.node.resolveAllPermitted(settings),settings.port.jmxPort);
  }
 catch (  Throwable t) {
switch (settings.log.level) {
case VERBOSE:
      t.printStackTrace();
  }
  System.err.println("Failed to connect over JMX; not collecting these stats");
  gcStatsCollector=new Callable<JmxCollector.GcStats>(){
    public JmxCollector.GcStats call() throws Exception {
      return totalGcStats;
    }
  }
;
}
this.gcStatsCollector=gcStatsCollector;
this.timing=new Timing(settings.samples.historyCount,settings.samples.reportCount);
printHeader("",output);
thread=tf.newThread(new Runnable(){
  @Override public void run(){
    timing.start();
    try {
      while (!stop) {
        try {
          long sleepNanos=timing.getHistory().endNanos() - System.nanoTime();
          long sleep=(sleepNanos / 1000000) + logIntervalMillis;
          if (sleep < logIntervalMillis >>> 3)           Thread.sleep(logIntervalMillis);
 else           Thread.sleep(sleep);
          update();
        }
 catch (        InterruptedException e) {
          break;
        }
      }
      update();
    }
 catch (    InterruptedException e) {
    }
catch (    Exception e) {
      cancel();
      e.printStackTrace(StressMetrics.this.output);
    }
 finally {
      rowRateUncertainty.wakeAll();
      stopped.countDown();
    }
  }
}
);
}
