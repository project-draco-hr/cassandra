{
  this.output=output;
  Callable<JmxCollector.GcStats> gcStatsCollector;
  try {
    gcStatsCollector=new JmxCollector(settings.node.nodes,settings.port.jmxPort);
    totalGcStats=new JmxCollector.GcStats(0);
  }
 catch (  Throwable t) {
    t.printStackTrace();
    System.err.println("Failed to connect over JMX; not collecting these stats");
    totalGcStats=new JmxCollector.GcStats(Double.POSITIVE_INFINITY);
    gcStatsCollector=new Callable<JmxCollector.GcStats>(){
      public JmxCollector.GcStats call() throws Exception {
        return totalGcStats;
      }
    }
;
  }
  this.gcStatsCollector=gcStatsCollector;
  printHeader("",output);
  thread=tf.newThread(new Runnable(){
    @Override public void run(){
      timing.start();
      try {
        while (!stop) {
          try {
            long sleep=timing.getHistory().endMillis() + logIntervalMillis - System.currentTimeMillis();
            if (sleep < logIntervalMillis >>> 3)             Thread.sleep(logIntervalMillis);
 else             Thread.sleep(sleep);
            update();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        update();
      }
 catch (      InterruptedException e) {
      }
catch (      Exception e) {
        cancel();
        e.printStackTrace(StressMetrics.this.output);
      }
 finally {
        rowRateUncertainty.wakeAll();
        stopped.countDown();
      }
    }
  }
);
}
