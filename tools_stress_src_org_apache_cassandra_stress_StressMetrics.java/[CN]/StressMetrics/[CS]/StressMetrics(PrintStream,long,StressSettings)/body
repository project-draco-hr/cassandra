{
  this.output=output;
  if (settings.log.hdrFile != null) {
    try {
      histogramWriter=new HistogramLogWriter(settings.log.hdrFile);
      histogramWriter.outputComment("Logging op latencies for Cassandra Stress");
      histogramWriter.outputLogFormatVersion();
      histogramWriter.outputBaseTime(epochMs);
      histogramWriter.setBaseTime(epochMs);
      histogramWriter.outputStartTime(epochMs);
      histogramWriter.outputLegend();
    }
 catch (    FileNotFoundException e) {
      throw new IllegalArgumentException(e);
    }
  }
 else {
    histogramWriter=null;
  }
  Callable<JmxCollector.GcStats> gcStatsCollector;
  totalGcStats=new JmxCollector.GcStats(0);
  try {
    gcStatsCollector=new JmxCollector(settings.node.resolveAllPermitted(settings),settings.port.jmxPort);
  }
 catch (  Throwable t) {
switch (settings.log.level) {
case VERBOSE:
      t.printStackTrace();
  }
  System.err.println("Failed to connect over JMX; not collecting these stats");
  gcStatsCollector=new Callable<JmxCollector.GcStats>(){
    public JmxCollector.GcStats call() throws Exception {
      return totalGcStats;
    }
  }
;
}
this.gcStatsCollector=gcStatsCollector;
this.timing=new Timing(settings.rate.isFixed);
printHeader("",output);
thread=new Thread(new Runnable(){
  @Override public void run(){
    timing.start();
    try {
      while (!stop) {
        try {
          long sleepNanos=timing.getHistory().endNanos() - System.nanoTime();
          long sleep=(sleepNanos / 1000000) + logIntervalMillis;
          if (sleep < logIntervalMillis >>> 3)           Thread.sleep(logIntervalMillis);
 else           Thread.sleep(sleep);
          update();
        }
 catch (        InterruptedException e) {
          break;
        }
      }
      update();
    }
 catch (    InterruptedException e) {
    }
catch (    Exception e) {
      cancel();
      e.printStackTrace(StressMetrics.this.output);
    }
 finally {
      rowRateUncertainty.wakeAll();
      stopped.countDown();
    }
  }
}
);
thread.setName("StressMetrics");
}
