{
  boolean hasCommutativeOperation=false;
  if (columns != null) {
    for (    Map.Entry<ColumnIdentifier,Operation> column : columns.entrySet()) {
      if (!column.getValue().isUnary())       hasCommutativeOperation=true;
      if (hasCommutativeOperation && column.getValue().isUnary())       throw new InvalidRequestException("Mix of commutative and non-commutative operations is not allowed.");
    }
  }
  CFMetaData metadata=validateColumnFamily(keyspace(),columnFamily(),hasCommutativeOperation);
  if (hasCommutativeOperation)   validateCommutativeForWrite(metadata,cLevel);
  cfDef=metadata.getCfDef();
  if (columns == null) {
    if (columnNames.size() != columnValues.size())     throw new InvalidRequestException("unmatched column names/values");
    if (columnNames.size() < 1)     throw new InvalidRequestException("no columns specified for INSERT");
    for (int i=0; i < columnNames.size(); i++) {
      CFDefinition.Name name=cfDef.get(columnNames.get(i));
      if (name == null)       throw new InvalidRequestException(String.format("Unknown identifier %s",columnNames.get(i)));
      Term value=columnValues.get(i);
      if (value.isBindMarker())       boundTypes[value.bindIndex]=name.type;
switch (name.kind) {
case KEY_ALIAS:
case COLUMN_ALIAS:
        if (processedKeys.containsKey(name.name))         throw new InvalidRequestException(String.format("Multiple definition found for PRIMARY KEY part %s",name));
      processedKeys.put(name.name,Collections.singletonList(value));
    break;
case VALUE_ALIAS:
case COLUMN_METADATA:
  if (processedColumns.containsKey(name.name))   throw new InvalidRequestException(String.format("Multiple definition found for column %s",name));
processedColumns.put(name.name,new Operation(value));
break;
}
}
}
 else {
for (Map.Entry<ColumnIdentifier,Operation> entry : columns.entrySet()) {
CFDefinition.Name name=cfDef.get(entry.getKey());
if (name == null) throw new InvalidRequestException(String.format("Unknown identifier %s",entry.getKey()));
switch (name.kind) {
case KEY_ALIAS:
case COLUMN_ALIAS:
throw new InvalidRequestException(String.format("PRIMARY KEY part %s found in SET part",entry.getKey()));
case VALUE_ALIAS:
case COLUMN_METADATA:
if (processedColumns.containsKey(name.name)) throw new InvalidRequestException(String.format("Multiple definition found for column %s",name));
Operation op=entry.getValue();
if (op.value.isBindMarker()) boundTypes[op.value.bindIndex]=name.type;
processedColumns.put(name.name,op);
break;
}
}
processKeys(cfDef,whereClause,processedKeys,boundTypes);
}
return new ParsedStatement.Prepared(this,Arrays.<AbstractType<?>>asList(boundTypes));
}
