{
  StorageService ss=StorageService.instance;
  final int RING_SIZE=6;
  final int LEAVING_NODE=3;
  TokenMetadata tmd=ss.getTokenMetadata();
  tmd.clearUnsafe();
  IPartitioner partitioner=new RandomPartitioner();
  AbstractReplicationStrategy testStrategy=new RackUnawareStrategy(tmd,new SimpleSnitch());
  IPartitioner oldPartitioner=ss.setPartitionerUnsafe(partitioner);
  Map<String,AbstractReplicationStrategy> oldStrategies=ss.setReplicationStrategyUnsafe(createReplacements(testStrategy));
  ArrayList<Token> endpointTokens=new ArrayList<Token>();
  ArrayList<Token> keyTokens=new ArrayList<Token>();
  List<InetAddress> hosts=new ArrayList<InetAddress>();
  createInitialRing(ss,partitioner,endpointTokens,keyTokens,hosts,RING_SIZE);
  final Map<Pair<String,Token>,List<InetAddress>> expectedEndpoints=new HashMap<Pair<String,Token>,List<InetAddress>>();
  for (  String table : DatabaseDescriptor.getNonSystemTables()) {
    for (    Token token : keyTokens) {
      List<InetAddress> endpoints=new ArrayList<InetAddress>();
      Pair<String,Token> key=new Pair<String,Token>(table,token);
      Iterator<Token> tokenIter=TokenMetadata.ringIterator(tmd.sortedTokens(),token);
      while (tokenIter.hasNext()) {
        endpoints.add(tmd.getEndpoint(tokenIter.next()));
      }
      expectedEndpoints.put(key,endpoints);
    }
  }
  ss.onChange(hosts.get(LEAVING_NODE),StorageService.MOVE_STATE,new ApplicationState(StorageService.STATE_LEAVING + StorageService.Delimiter + partitioner.getTokenFactory().toString(endpointTokens.get(LEAVING_NODE))));
  assertTrue(tmd.isLeaving(hosts.get(LEAVING_NODE)));
  for (  String table : DatabaseDescriptor.getNonSystemTables()) {
    for (    Token token : keyTokens) {
      Pair<String,Token> key=new Pair<String,Token>(table,token);
      int replicationFactor=DatabaseDescriptor.getReplicationFactor(table);
      HashSet<InetAddress> actual=new HashSet<InetAddress>(tmd.getWriteEndpoints(token,table,testStrategy.calculateNaturalEndpoints(token,tmd,table)));
      HashSet<InetAddress> expected=new HashSet<InetAddress>();
      for (int i=0; i < replicationFactor; i++) {
        expected.add(expectedEndpoints.get(key).get(i));
      }
      if (expected.contains(hosts.get(LEAVING_NODE)))       expected.add(expectedEndpoints.get(key).get(replicationFactor));
      assertEquals("mismatched endpoint sets",expected,actual);
    }
  }
  ss.setPartitionerUnsafe(oldPartitioner);
  ss.setReplicationStrategyUnsafe(oldStrategies);
}
