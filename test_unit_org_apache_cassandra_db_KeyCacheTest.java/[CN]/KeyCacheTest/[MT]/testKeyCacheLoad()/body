{
  CompactionManager.instance.disableAutoCompaction();
  ColumnFamilyStore store=Keyspace.open(KEYSPACE1).getColumnFamilyStore(COLUMN_FAMILY2);
  CacheService.instance.invalidateKeyCache();
  assertKeyCacheSize(0,KEYSPACE1,COLUMN_FAMILY2);
  SchemaLoader.insertData(KEYSPACE1,COLUMN_FAMILY2,0,100);
  store.forceBlockingFlush();
  readData(KEYSPACE1,COLUMN_FAMILY2,0,100);
  assertKeyCacheSize(100,KEYSPACE1,COLUMN_FAMILY2);
  Map<KeyCacheKey,RowIndexEntry> savedMap=new HashMap<KeyCacheKey,RowIndexEntry>();
  for (Iterator<KeyCacheKey> iter=CacheService.instance.keyCache.keyIterator(); iter.hasNext(); ) {
    KeyCacheKey k=iter.next();
    if (k.desc.ksname.equals(KEYSPACE1) && k.desc.cfname.equals(COLUMN_FAMILY2))     savedMap.put(k,CacheService.instance.keyCache.get(k));
  }
  CacheService.instance.keyCache.submitWrite(Integer.MAX_VALUE).get();
  CacheService.instance.invalidateKeyCache();
  assertKeyCacheSize(0,KEYSPACE1,COLUMN_FAMILY2);
  CacheService.instance.keyCache.loadSaved();
  assertKeyCacheSize(savedMap.size(),KEYSPACE1,COLUMN_FAMILY2);
  for (  Map.Entry<KeyCacheKey,RowIndexEntry> entry : savedMap.entrySet()) {
    RowIndexEntry expected=entry.getValue();
    RowIndexEntry actual=CacheService.instance.keyCache.get(entry.getKey());
    assertEquals(expected.position,actual.position);
    assertEquals(expected.columnsIndex(),actual.columnsIndex());
    if (expected.isIndexed()) {
      assertEquals(expected.deletionTime(),actual.deletionTime());
    }
  }
}
