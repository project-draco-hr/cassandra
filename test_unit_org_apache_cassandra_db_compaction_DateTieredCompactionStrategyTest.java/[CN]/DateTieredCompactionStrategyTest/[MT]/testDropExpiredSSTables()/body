{
  Keyspace keyspace=Keyspace.open(KEYSPACE1);
  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(CF_STANDARD1);
  cfs.truncateBlocking();
  cfs.disableAutoCompaction();
  ByteBuffer value=ByteBuffer.wrap(new byte[100]);
  DecoratedKey key=Util.dk(String.valueOf("expired"));
  new RowUpdateBuilder(cfs.metadata,System.currentTimeMillis(),1,key.getKey()).clustering("column").add("val",value).build().applyUnsafe();
  cfs.forceBlockingFlush();
  SSTableReader expiredSSTable=cfs.getLiveSSTables().iterator().next();
  Thread.sleep(10);
  key=Util.dk(String.valueOf("nonexpired"));
  new RowUpdateBuilder(cfs.metadata,System.currentTimeMillis(),key.getKey()).clustering("column").add("val",value).build().applyUnsafe();
  cfs.forceBlockingFlush();
  assertEquals(cfs.getLiveSSTables().size(),2);
  Map<String,String> options=new HashMap<>();
  options.put(DateTieredCompactionStrategyOptions.BASE_TIME_KEY,"30");
  options.put(DateTieredCompactionStrategyOptions.TIMESTAMP_RESOLUTION_KEY,"MILLISECONDS");
  options.put(DateTieredCompactionStrategyOptions.MAX_SSTABLE_AGE_KEY,Double.toString((1d / (24 * 60 * 60))));
  DateTieredCompactionStrategy dtcs=new DateTieredCompactionStrategy(cfs,options);
  for (  SSTableReader sstable : cfs.getLiveSSTables())   dtcs.addSSTable(sstable);
  dtcs.startup();
  assertNull(dtcs.getNextBackgroundTask((int)(System.currentTimeMillis() / 1000)));
  dtcs.lastExpiredCheck=0;
  Thread.sleep(2000);
  AbstractCompactionTask t=dtcs.getNextBackgroundTask((int)(System.currentTimeMillis() / 1000));
  assertNotNull(t);
  assertEquals(1,Iterables.size(t.transaction.originals()));
  SSTableReader sstable=t.transaction.originals().iterator().next();
  assertEquals(sstable,expiredSSTable);
  t.transaction.abort();
}
