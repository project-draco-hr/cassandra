{
  Keyspace keyspace=Keyspace.open(KEYSPACE1);
  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(CF_STANDARD1);
  cfs.truncateBlocking();
  cfs.disableAutoCompaction();
  ByteBuffer value=ByteBuffer.wrap(new byte[100]);
  int numSSTables=3;
  for (int r=0; r < numSSTables; r++) {
    DecoratedKey key=Util.dk(String.valueOf(r));
    Mutation rm=new Mutation(KEYSPACE1,key.getKey());
    rm.add(CF_STANDARD1,Util.cellname("column"),value,r);
    rm.apply();
    cfs.forceBlockingFlush();
  }
  cfs.forceBlockingFlush();
  List<SSTableReader> sstrs=new ArrayList<>(cfs.getSSTables());
  List<SSTableReader> newBucket=newestBucket(Collections.singletonList(sstrs.subList(0,2)),4,32,9,10,new SizeTieredCompactionStrategyOptions());
  assertTrue("incoming bucket should not be accepted when it has below the min threshold SSTables",newBucket.isEmpty());
  newBucket=newestBucket(Collections.singletonList(sstrs.subList(0,2)),4,32,10,10,new SizeTieredCompactionStrategyOptions());
  assertFalse("non-incoming bucket should be accepted when it has at least 2 SSTables",newBucket.isEmpty());
  assertEquals("an sstable with a single value should have equal min/max timestamps",sstrs.get(0).getMinTimestamp(),sstrs.get(0).getMaxTimestamp());
  assertEquals("an sstable with a single value should have equal min/max timestamps",sstrs.get(1).getMinTimestamp(),sstrs.get(1).getMaxTimestamp());
  assertEquals("an sstable with a single value should have equal min/max timestamps",sstrs.get(2).getMinTimestamp(),sstrs.get(2).getMaxTimestamp());
}
