{
  logger.debug("Deleting old {} files.",cacheType);
  deleteOldCacheFiles();
  if (keys.isEmpty()) {
    logger.debug("Skipping {} save, cache is empty.",cacheType);
    return;
  }
  long start=System.nanoTime();
  HashMap<UUID,SequentialWriter> writers=new HashMap<>();
  try {
    for (    K key : keys) {
      UUID cfId=key.getCFId();
      if (!Schema.instance.hasCF(key.getCFId()))       continue;
      SequentialWriter writer=writers.get(cfId);
      if (writer == null) {
        writer=tempCacheFile(cfId);
        writers.put(cfId,writer);
      }
      try {
        cacheLoader.serialize(key,writer.stream);
      }
 catch (      IOException e) {
        throw new FSWriteError(e,writer.getPath());
      }
      keysWritten++;
    }
  }
  finally {
    for (    SequentialWriter writer : writers.values())     FileUtils.closeQuietly(writer);
  }
  for (  Map.Entry<UUID,SequentialWriter> entry : writers.entrySet()) {
    UUID cfId=entry.getKey();
    SequentialWriter writer=entry.getValue();
    File tmpFile=new File(writer.getPath());
    File cacheFile=getCachePath(cfId,CURRENT_VERSION);
    cacheFile.delete();
    if (!tmpFile.renameTo(cacheFile))     logger.error("Unable to rename {} to {}",tmpFile,cacheFile);
  }
  logger.info("Saved {} ({} items) in {} ms",cacheType,keys.size(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}
