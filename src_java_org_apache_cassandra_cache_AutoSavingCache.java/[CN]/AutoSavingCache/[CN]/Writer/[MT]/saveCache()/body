{
  logger.debug("Deleting old {} files.",cacheType);
  deleteOldCacheFiles();
  if (!keyIterator.hasNext()) {
    logger.debug("Skipping {} save, cache is empty.",cacheType);
    return;
  }
  long start=System.nanoTime();
  HashMap<UUID,DataOutputPlus> writers=new HashMap<>();
  HashMap<UUID,OutputStream> streams=new HashMap<>();
  HashMap<UUID,File> paths=new HashMap<>();
  try {
    while (keyIterator.hasNext()) {
      K key=keyIterator.next();
      UUID cfId=key.getCFId();
      if (!Schema.instance.hasCF(key.getCFId()))       continue;
      DataOutputPlus writer=writers.get(cfId);
      if (writer == null) {
        File writerPath=tempCacheFile(cfId);
        OutputStream stream;
        try {
          stream=streamFactory.getOutputStream(writerPath);
          writer=new WrappedDataOutputStreamPlus(stream);
        }
 catch (        FileNotFoundException e) {
          throw new RuntimeException(e);
        }
        paths.put(cfId,writerPath);
        streams.put(cfId,stream);
        writers.put(cfId,writer);
      }
      try {
        cacheLoader.serialize(key,writer);
      }
 catch (      IOException e) {
        throw new FSWriteError(e,paths.get(cfId));
      }
      keysWritten++;
      if (keysWritten >= keysEstimate)       break;
    }
  }
  finally {
    if (keyIterator instanceof Closeable)     try {
      ((Closeable)keyIterator).close();
    }
 catch (    IOException ignored) {
    }
    for (    OutputStream writer : streams.values())     FileUtils.closeQuietly(writer);
  }
  for (  Map.Entry<UUID,DataOutputPlus> entry : writers.entrySet()) {
    UUID cfId=entry.getKey();
    File tmpFile=paths.get(cfId);
    File cacheFile=getCachePath(cfId,CURRENT_VERSION);
    cacheFile.delete();
    if (!tmpFile.renameTo(cacheFile))     logger.error("Unable to rename {} to {}",tmpFile,cacheFile);
  }
  logger.info("Saved {} ({} items) in {} ms",cacheType,keysWritten,TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}
