{
  logger.debug("applying {} to {}",cf_def,this);
  if (!cf_def.keyspace.toString().equals(ksName))   throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",cf_def.keyspace,ksName));
  if (!cf_def.name.toString().equals(cfName))   throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",cf_def.name,cfName));
  if (!cf_def.id.equals(cfId))   throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",cf_def.id,cfId));
  if (!cf_def.column_type.toString().equals(cfType.name()))   throw new ConfigurationException("types do not match.");
  if (comparator != TypeParser.parse(cf_def.comparator_type))   throw new ConfigurationException("comparators do not match.");
  if (cf_def.subcomparator_type == null || cf_def.subcomparator_type.equals("")) {
    if (subcolumnComparator != null)     throw new ConfigurationException("subcolumncomparators do not match.");
  }
 else   if (subcolumnComparator != TypeParser.parse(cf_def.subcomparator_type))   throw new ConfigurationException("subcolumncomparators do not match.");
  validateMinMaxCompactionThresholds(cf_def);
  comment=enforceCommentNotNull(cf_def.comment);
  readRepairChance=cf_def.read_repair_chance;
  replicateOnWrite=cf_def.replicate_on_write;
  gcGraceSeconds=cf_def.gc_grace_seconds;
  defaultValidator=TypeParser.parse(cf_def.default_validation_class);
  keyValidator=TypeParser.parse(cf_def.key_validation_class);
  minCompactionThreshold=cf_def.min_compaction_threshold;
  maxCompactionThreshold=cf_def.max_compaction_threshold;
  mergeShardsChance=cf_def.merge_shards_chance;
  keyAlias=cf_def.key_alias;
  Set<ByteBuffer> toRemove=new HashSet<ByteBuffer>();
  Set<ByteBuffer> newColumns=new HashSet<ByteBuffer>();
  Set<org.apache.cassandra.db.migration.avro.ColumnDef> toAdd=new HashSet<org.apache.cassandra.db.migration.avro.ColumnDef>();
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : cf_def.column_metadata) {
    newColumns.add(def.name);
    if (!column_metadata.containsKey(def.name))     toAdd.add(def);
  }
  for (  ByteBuffer name : column_metadata.keySet())   if (!newColumns.contains(name))   toRemove.add(name);
  for (  ByteBuffer indexName : toRemove) {
    column_metadata.remove(indexName);
  }
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : cf_def.column_metadata) {
    ColumnDefinition oldDef=column_metadata.get(def.name);
    if (oldDef == null)     continue;
    oldDef.setValidator(TypeParser.parse(def.validation_class));
    oldDef.setIndexType(def.index_type == null ? null : org.apache.cassandra.thrift.IndexType.valueOf(def.index_type.name()),ColumnDefinition.getStringMap(def.index_options));
    oldDef.setIndexName(def.index_name == null ? null : def.index_name.toString());
  }
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : toAdd) {
    AbstractType dValidClass=TypeParser.parse(def.validation_class);
    ColumnDefinition cd=new ColumnDefinition(def.name,dValidClass,def.index_type == null ? null : org.apache.cassandra.thrift.IndexType.valueOf(def.index_type.toString()),ColumnDefinition.getStringMap(def.index_options),def.index_name == null ? null : def.index_name.toString());
    column_metadata.put(cd.name,cd);
  }
  if (cf_def.compaction_strategy != null)   compactionStrategyClass=createCompactionStrategy(cf_def.compaction_strategy.toString());
  if (null != cf_def.compaction_strategy_options) {
    compactionStrategyOptions=new HashMap<String,String>();
    for (    Map.Entry<CharSequence,CharSequence> e : cf_def.compaction_strategy_options.entrySet())     compactionStrategyOptions.put(e.getKey().toString(),e.getValue().toString());
  }
  compressionParameters=CompressionParameters.create(cf_def.compression_options);
  logger.debug("application result is {}",this);
}
