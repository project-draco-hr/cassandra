{
  if (!cf_def.keyspace.toString().equals(ksName))   throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",cf_def.keyspace,ksName));
  if (!cf_def.name.toString().equals(cfName))   throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",cf_def.name,cfName));
  if (!cf_def.id.equals(cfId))   throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",cf_def.id,cfId));
  if (!cf_def.column_type.toString().equals(cfType.name()))   throw new ConfigurationException("types do not match.");
  if (comparator != TypeParser.parse(cf_def.comparator_type))   throw new ConfigurationException("comparators do not match.");
  if (cf_def.subcomparator_type == null || cf_def.subcomparator_type.equals("")) {
    if (subcolumnComparator != null)     throw new ConfigurationException("subcolumncomparators do not match.");
  }
 else   if (subcolumnComparator != TypeParser.parse(cf_def.subcomparator_type))   throw new ConfigurationException("subcolumncomparators do not match.");
  validateMinMaxCompactionThresholds(cf_def);
  validateMemtableSettings(cf_def);
  comment=enforceCommentNotNull(cf_def.comment);
  rowCacheSize=cf_def.row_cache_size;
  keyCacheSize=cf_def.key_cache_size;
  readRepairChance=cf_def.read_repair_chance;
  replicateOnWrite=cf_def.replicate_on_write;
  gcGraceSeconds=cf_def.gc_grace_seconds;
  defaultValidator=TypeParser.parse(cf_def.default_validation_class);
  keyValidator=TypeParser.parse(cf_def.key_validation_class);
  minCompactionThreshold=cf_def.min_compaction_threshold;
  maxCompactionThreshold=cf_def.max_compaction_threshold;
  rowCacheSavePeriodInSeconds=cf_def.row_cache_save_period_in_seconds;
  keyCacheSavePeriodInSeconds=cf_def.key_cache_save_period_in_seconds;
  memtableFlushAfterMins=cf_def.memtable_flush_after_mins;
  memtableThroughputInMb=cf_def.memtable_throughput_in_mb;
  memtableOperationsInMillions=cf_def.memtable_operations_in_millions;
  mergeShardsChance=cf_def.merge_shards_chance;
  if (cf_def.row_cache_provider != null)   rowCacheProvider=FBUtilities.newCacheProvider(cf_def.row_cache_provider.toString());
  keyAlias=cf_def.key_alias;
  Set<ByteBuffer> toRemove=new HashSet<ByteBuffer>();
  Set<ByteBuffer> newColumns=new HashSet<ByteBuffer>();
  Set<org.apache.cassandra.db.migration.avro.ColumnDef> toAdd=new HashSet<org.apache.cassandra.db.migration.avro.ColumnDef>();
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : cf_def.column_metadata) {
    newColumns.add(def.name);
    if (!column_metadata.containsKey(def.name))     toAdd.add(def);
  }
  for (  ByteBuffer name : column_metadata.keySet())   if (!newColumns.contains(name))   toRemove.add(name);
  for (  ByteBuffer indexName : toRemove)   column_metadata.remove(indexName);
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : cf_def.column_metadata) {
    ColumnDefinition oldDef=column_metadata.get(def.name);
    if (oldDef == null)     continue;
    oldDef.setValidator(TypeParser.parse(def.validation_class));
    oldDef.setIndexType(def.index_type == null ? null : org.apache.cassandra.thrift.IndexType.valueOf(def.index_type.name()));
    oldDef.setIndexName(def.index_name == null ? null : def.index_name.toString());
  }
  for (  org.apache.cassandra.db.migration.avro.ColumnDef def : toAdd) {
    AbstractType dValidClass=TypeParser.parse(def.validation_class);
    ColumnDefinition cd=new ColumnDefinition(def.name,dValidClass,def.index_type == null ? null : org.apache.cassandra.thrift.IndexType.valueOf(def.index_type.toString()),def.index_name == null ? null : def.index_name.toString());
    column_metadata.put(cd.name,cd);
  }
}
