{
  if (!columnFamily().matches("\\w+"))   throw new InvalidRequestException(String.format("\"%s\" is not a valid table name (must be alphanumeric character only: [0-9A-Za-z]+)",columnFamily()));
  if (columnFamily().length() > Schema.NAME_LENGTH)   throw new InvalidRequestException(String.format("Table names shouldn't be more than %s characters long (got \"%s\")",Schema.NAME_LENGTH,columnFamily()));
  for (  Multiset.Entry<ColumnIdentifier> entry : definedNames.entrySet())   if (entry.getCount() > 1)   throw new InvalidRequestException(String.format("Multiple definition of identifier %s",entry.getElement()));
  properties.validate();
  CreateTableStatement stmt=new CreateTableStatement(cfName,properties.properties,ifNotExists,staticColumns);
  for (  Map.Entry<ColumnIdentifier,CQL3Type.Raw> entry : definitions.entrySet()) {
    ColumnIdentifier id=entry.getKey();
    CQL3Type pt=entry.getValue().prepare(keyspace());
    if (pt.isCollection() && ((CollectionType)pt.getType()).isMultiCell())     stmt.collections.put(id.bytes,(CollectionType)pt.getType());
    if (entry.getValue().isCounter())     stmt.hasCounters=true;
    stmt.columns.put(id,pt.getType());
  }
  if (keyAliases.isEmpty())   throw new InvalidRequestException("No PRIMARY KEY specifed (exactly one required)");
  if (keyAliases.size() > 1)   throw new InvalidRequestException("Multiple PRIMARY KEYs specifed (exactly one required)");
  if (stmt.hasCounters && properties.properties.getDefaultTimeToLive() > 0)   throw new InvalidRequestException("Cannot set default_time_to_live on a table with counters");
  List<ColumnIdentifier> kAliases=keyAliases.get(0);
  stmt.keyTypes=new ArrayList<AbstractType<?>>(kAliases.size());
  for (  ColumnIdentifier alias : kAliases) {
    stmt.keyAliases.add(alias);
    AbstractType<?> t=getTypeAndRemove(stmt.columns,alias);
    if (t instanceof CounterColumnType)     throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s",alias));
    if (staticColumns.contains(alias))     throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY",alias));
    stmt.keyTypes.add(t);
  }
  stmt.clusteringTypes=new ArrayList<>(columnAliases.size());
  for (  ColumnIdentifier t : columnAliases) {
    stmt.columnAliases.add(t);
    AbstractType<?> type=getTypeAndRemove(stmt.columns,t);
    if (type instanceof CounterColumnType)     throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s",t));
    if (staticColumns.contains(t))     throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY",t));
    stmt.clusteringTypes.add(type);
  }
  if (stmt.hasCounters) {
    for (    AbstractType<?> type : stmt.columns.values())     if (!type.isCounter())     throw new InvalidRequestException("Cannot mix counter and non counter columns in the same table");
  }
  boolean useCompactStorage=properties.useCompactStorage;
  stmt.isDense=useCompactStorage && !stmt.clusteringTypes.isEmpty();
  stmt.isCompound=!(useCompactStorage && stmt.clusteringTypes.size() <= 1);
  if (useCompactStorage) {
    if (!stmt.collections.isEmpty())     throw new InvalidRequestException("Non-frozen collection types are not supported with COMPACT STORAGE");
    if (!staticColumns.isEmpty())     throw new InvalidRequestException("Static columns are not supported in COMPACT STORAGE tables");
    if (stmt.clusteringTypes.isEmpty()) {
      if (stmt.columns.isEmpty())       throw new InvalidRequestException("No definition found that is not part of the PRIMARY KEY");
    }
    if (stmt.isDense) {
      if (stmt.columns.size() > 1)       throw new InvalidRequestException(String.format("COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)",StringUtils.join(stmt.columns.keySet(),", ")));
    }
 else {
      if (stmt.columns.isEmpty())       throw new InvalidRequestException("COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given");
    }
  }
 else {
    if (stmt.clusteringTypes.isEmpty() && !staticColumns.isEmpty()) {
      if (columnAliases.isEmpty())       throw new InvalidRequestException("Static columns are only useful (and thus allowed) if the table has at least one clustering column");
    }
  }
  if (!properties.definedOrdering.isEmpty()) {
    if (properties.definedOrdering.size() > columnAliases.size())     throw new InvalidRequestException("Only clustering key columns can be defined in CLUSTERING ORDER directive");
    int i=0;
    for (    ColumnIdentifier id : properties.definedOrdering.keySet()) {
      ColumnIdentifier c=columnAliases.get(i);
      if (!id.equals(c)) {
        if (properties.definedOrdering.containsKey(c))         throw new InvalidRequestException(String.format("The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)",c,id));
 else         throw new InvalidRequestException(String.format("Missing CLUSTERING ORDER for column %s",c));
      }
      ++i;
    }
  }
  return new ParsedStatement.Prepared(stmt);
}
