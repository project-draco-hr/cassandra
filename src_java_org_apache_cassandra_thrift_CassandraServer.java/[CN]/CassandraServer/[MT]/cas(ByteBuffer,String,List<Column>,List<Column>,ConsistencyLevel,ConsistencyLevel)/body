{
  if (startSessionIfRequested()) {
    Map<String,String> traceParameters=ImmutableMap.of("key",ByteBufferUtil.bytesToHex(key),"column_family",column_family,"old",expected.toString(),"updates",updates.toString());
    Tracing.instance.begin("cas",traceParameters);
  }
 else {
    logger.debug("cas");
  }
  try {
    ThriftClientState cState=state();
    String keyspace=cState.getKeyspace();
    cState.hasColumnFamilyAccess(keyspace,column_family,Permission.MODIFY);
    cState.hasColumnFamilyAccess(keyspace,column_family,Permission.SELECT);
    CFMetaData metadata=ThriftValidation.validateColumnFamily(keyspace,column_family,false);
    ThriftValidation.validateKey(metadata,key);
    if (metadata.isSuper())     throw new org.apache.cassandra.exceptions.InvalidRequestException("CAS does not support supercolumns");
    Iterable<ByteBuffer> names=Iterables.transform(updates,new Function<Column,ByteBuffer>(){
      public ByteBuffer apply(      Column column){
        return column.name;
      }
    }
);
    ThriftValidation.validateColumnNames(metadata,new ColumnParent(column_family),names);
    for (    Column column : updates)     ThriftValidation.validateColumnData(metadata,null,column);
    CFMetaData cfm=Schema.instance.getCFMetaData(cState.getKeyspace(),column_family);
    DecoratedKey dk=StorageService.getPartitioner().decorateKey(key);
    int nowInSec=FBUtilities.nowInSeconds();
    PartitionUpdate partitionUpdates=RowIterators.toUpdate(LegacyLayout.toRowIterator(metadata,dk,toLegacyCells(metadata,updates,nowInSec).iterator(),nowInSec));
    FilteredPartition partitionExpected=null;
    if (!expected.isEmpty())     partitionExpected=FilteredPartition.create(LegacyLayout.toRowIterator(metadata,dk,toLegacyCells(metadata,expected,nowInSec).iterator(),nowInSec));
    schedule(DatabaseDescriptor.getWriteRpcTimeout());
    try (RowIterator result=StorageProxy.cas(cState.getKeyspace(),column_family,dk,new ThriftCASRequest(partitionExpected,partitionUpdates),ThriftConversion.fromThrift(serial_consistency_level),ThriftConversion.fromThrift(commit_consistency_level),cState)){
      return result == null ? new CASResult(true) : new CASResult(false).setCurrent_values(thriftifyColumnsAsColumns(metadata,LegacyLayout.fromRowIterator(result)));
    }
   }
 catch (  UnknownColumnException e) {
    throw new InvalidRequestException(e.getMessage());
  }
catch (  RequestTimeoutException e) {
    throw ThriftConversion.toThrift(e);
  }
catch (  RequestValidationException e) {
    throw ThriftConversion.toThrift(e);
  }
catch (  RequestExecutionException e) {
    throw ThriftConversion.rethrow(e);
  }
 finally {
    Tracing.instance.stopSession();
  }
}
