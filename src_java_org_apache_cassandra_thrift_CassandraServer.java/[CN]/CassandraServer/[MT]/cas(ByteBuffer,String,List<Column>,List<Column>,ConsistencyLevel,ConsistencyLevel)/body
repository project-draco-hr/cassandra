{
  if (startSessionIfRequested()) {
    Map<String,String> traceParameters=ImmutableMap.of("key",ByteBufferUtil.bytesToHex(key),"column_family",column_family,"old",expected.toString(),"updates",updates.toString());
    Tracing.instance.begin("cas",traceParameters);
  }
 else {
    logger.debug("cas");
  }
  try {
    ThriftClientState cState=state();
    String keyspace=cState.getKeyspace();
    cState.hasColumnFamilyAccess(keyspace,column_family,Permission.MODIFY);
    cState.hasColumnFamilyAccess(keyspace,column_family,Permission.SELECT);
    CFMetaData metadata=ThriftValidation.validateColumnFamily(keyspace,column_family,false);
    ThriftValidation.validateKey(metadata,key);
    if (metadata.cfType == ColumnFamilyType.Super)     throw new org.apache.cassandra.exceptions.InvalidRequestException("CAS does not support supercolumns");
    Iterable<ByteBuffer> names=Iterables.transform(updates,new Function<Column,ByteBuffer>(){
      public ByteBuffer apply(      Column column){
        return column.name;
      }
    }
);
    ThriftValidation.validateColumnNames(metadata,new ColumnParent(column_family),names);
    for (    Column column : updates)     ThriftValidation.validateColumnData(metadata,null,column);
    CFMetaData cfm=Schema.instance.getCFMetaData(cState.getKeyspace(),column_family);
    ColumnFamily cfUpdates=ArrayBackedSortedColumns.factory.create(cfm);
    for (    Column column : updates)     cfUpdates.addColumn(cfm.comparator.cellFromByteBuffer(column.name),column.value,column.timestamp);
    ColumnFamily cfExpected;
    if (expected.isEmpty()) {
      cfExpected=null;
    }
 else {
      cfExpected=ArrayBackedSortedColumns.factory.create(cfm);
      for (      Column column : expected)       cfExpected.addColumn(cfm.comparator.cellFromByteBuffer(column.name),column.value,column.timestamp);
    }
    schedule(DatabaseDescriptor.getWriteRpcTimeout());
    ColumnFamily result=StorageProxy.cas(cState.getKeyspace(),column_family,key,new ThriftCASConditions(cfExpected),cfUpdates,ThriftConversion.fromThrift(serial_consistency_level),ThriftConversion.fromThrift(commit_consistency_level));
    return result == null ? new CASResult(true) : new CASResult(false).setCurrent_values(thriftifyColumnsAsColumns(result.getSortedColumns(),System.currentTimeMillis()));
  }
 catch (  RequestTimeoutException e) {
    throw ThriftConversion.toThrift(e);
  }
catch (  RequestValidationException e) {
    throw ThriftConversion.toThrift(e);
  }
catch (  RequestExecutionException e) {
    throw ThriftConversion.rethrow(e);
  }
 finally {
    Tracing.instance.stopSession();
  }
}
