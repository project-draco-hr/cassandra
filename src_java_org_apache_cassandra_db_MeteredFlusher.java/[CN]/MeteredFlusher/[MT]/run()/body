{
  long allowedSize=calculateAllowedSize();
  long flushingSize=calculateFlushingSize();
  if (flushingSize > 0)   logger.debug("Currently flushing {} bytes of {} max",flushingSize,allowedSize);
  List<ColumnFamilyStore> affectedCFs=affectedColumnFamilies();
  long liveSize=0;
  for (  ColumnFamilyStore cfs : affectedCFs) {
    int maxInFlight=(int)Math.ceil((double)(1 + 1 + DatabaseDescriptor.getFlushWriters()+ DatabaseDescriptor.getFlushQueueSize()) / (1 + cfs.indexManager.getIndexesBackedByCfs().size()));
    long size=cfs.getTotalMemtableLiveSize();
    if (allowedSize > flushingSize && size > (allowedSize - flushingSize) / maxInFlight) {
      logger.info("flushing high-traffic column family {} (estimated {} bytes)",cfs,size);
      cfs.forceFlush();
    }
 else {
      liveSize+=size;
    }
  }
  if (liveSize + flushingSize <= allowedSize)   return;
  logger.info("estimated {} live and {} flushing bytes used by all memtables",liveSize,flushingSize);
  Collections.sort(affectedCFs,new Comparator<ColumnFamilyStore>(){
    public int compare(    ColumnFamilyStore lhs,    ColumnFamilyStore rhs){
      return Long.compare(lhs.getTotalMemtableLiveSize(),rhs.getTotalMemtableLiveSize());
    }
  }
);
  while (!affectedCFs.isEmpty()) {
    flushingSize=calculateFlushingSize();
    if (liveSize + flushingSize <= allowedSize)     break;
    ColumnFamilyStore cfs=affectedCFs.remove(affectedCFs.size() - 1);
    long size=cfs.getTotalMemtableLiveSize();
    if (size > 0) {
      logger.info("flushing {} to free up {} bytes",cfs,size);
      liveSize-=size;
      cfs.forceFlush();
    }
  }
  logger.trace("memtable memory usage is {} bytes with {} live",liveSize + flushingSize,liveSize);
}
