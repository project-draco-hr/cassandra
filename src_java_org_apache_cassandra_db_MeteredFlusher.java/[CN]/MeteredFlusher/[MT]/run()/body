{
  long totalMemtableBytesAllowed=DatabaseDescriptor.getTotalMemtableSpaceInMB() * 1048576L;
  ColumnFamilyStore measuredCfs=Memtable.activelyMeasuring;
  long flushingBytes=measuredCfs == null ? 0 : measuredCfs.getMemtableThreadSafe().getLiveSize();
  flushingBytes+=countFlushingBytes();
  if (flushingBytes > 0)   logger.debug("Currently flushing {} bytes of {} max",flushingBytes,totalMemtableBytesAllowed);
  long liveBytes=0;
  try {
    long totalMemtableBytesUnused=totalMemtableBytesAllowed - flushingBytes;
    for (    ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
      long size=cfs.getTotalMemtableLiveSize();
      int maxInFlight=(int)Math.ceil((double)(1 + 1 + DatabaseDescriptor.getFlushWriters()+ DatabaseDescriptor.getFlushQueueSize()) / (1 + cfs.indexManager.getIndexesBackedByCfs().size()));
      if (cfs.getCompactionStrategy().isAffectedByMeteredFlusher() && totalMemtableBytesUnused > 0 && size > totalMemtableBytesUnused / maxInFlight) {
        logger.info("flushing high-traffic column family {} (estimated {} bytes)",cfs,size);
        cfs.forceFlush();
      }
 else {
        liveBytes+=size;
      }
    }
    if (flushingBytes + liveBytes <= totalMemtableBytesAllowed)     return;
    logger.info("estimated {} live and {} flushing bytes used by all memtables",liveBytes,flushingBytes);
    List<ColumnFamilyStore> sorted=new ArrayList<ColumnFamilyStore>();
    Iterables.addAll(sorted,ColumnFamilyStore.all());
    Collections.sort(sorted,new Comparator<ColumnFamilyStore>(){
      public int compare(      ColumnFamilyStore o1,      ColumnFamilyStore o2){
        long size1=o1.getTotalMemtableLiveSize();
        long size2=o2.getTotalMemtableLiveSize();
        if (size1 < size2)         return -1;
        if (size1 > size2)         return 1;
        return 0;
      }
    }
);
    while (!sorted.isEmpty()) {
      flushingBytes=countFlushingBytes();
      if (liveBytes + flushingBytes <= totalMemtableBytesAllowed)       break;
      ColumnFamilyStore cfs=sorted.remove(sorted.size() - 1);
      if (cfs.getCompactionStrategy().isAffectedByMeteredFlusher()) {
        long size=cfs.getTotalMemtableLiveSize();
        if (size == 0)         break;
        logger.info("flushing {} to free up {} bytes",cfs,size);
        liveBytes-=size;
        cfs.forceFlush();
      }
    }
  }
  finally {
    logger.trace("memtable memory usage is {} bytes with {} live",liveBytes + flushingBytes,liveBytes);
  }
}
