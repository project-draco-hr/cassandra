{
  if (!(DatabaseDescriptor.getAuthenticator() instanceof AllowAllAuthenticator))   throw newInvalidRequestException("Unable to create new keyspace while authentication is enabled.");
  int totalNodes=Gossiper.instance.getLiveMembers().size() + Gossiper.instance.getUnreachableMembers().size();
  if (totalNodes < ksDef.replication_factor)   throw newInvalidRequestException(String.format("%s live nodes are not enough to support replication factor %s",totalNodes,ksDef.replication_factor));
  for (  CfDef cf : ksDef.cf_defs) {
    if (!cf.keyspace.equals(ksDef.name)) {
      throw newInvalidRequestException("CsDef (" + cf.name + ") had a keyspace definition that did not match KsDef");
    }
  }
  try {
    Collection<CFMetaData> cfDefs=new ArrayList<CFMetaData>((int)ksDef.cf_defs.size());
    for (    CfDef cfDef : ksDef.cf_defs) {
      cfDefs.add(convertToCFMetaData(cfDef));
    }
    Map<String,String> strategyOptions=null;
    if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty()) {
      strategyOptions=new HashMap<String,String>();
      for (      Map.Entry<CharSequence,CharSequence> option : ksDef.strategy_options.entrySet()) {
        strategyOptions.put(option.getKey().toString(),option.getValue().toString());
      }
    }
    KSMetaData ksmeta=new KSMetaData(ksDef.name.toString(),FBUtilities.<AbstractReplicationStrategy>classForName(ksDef.strategy_class.toString(),"keyspace replication strategy"),strategyOptions,ksDef.replication_factor,cfDefs.toArray(new CFMetaData[cfDefs.size()]));
    applyMigrationOnStage(new AddKeyspace(ksmeta));
    return DatabaseDescriptor.getDefsVersion().toString();
  }
 catch (  ConfigurationException e) {
    throw newInvalidRequestException(e);
  }
catch (  IOException e) {
    throw newInvalidRequestException(e);
  }
}
