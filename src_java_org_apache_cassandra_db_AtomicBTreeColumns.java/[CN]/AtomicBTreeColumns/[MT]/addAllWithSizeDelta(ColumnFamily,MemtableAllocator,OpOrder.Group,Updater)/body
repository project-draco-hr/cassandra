{
  ColumnUpdater updater=new ColumnUpdater(this,cm.metadata,allocator,writeOp,indexer);
  DeletionInfo inputDeletionInfoCopy=null;
  boolean monitorOwned=false;
  try {
    if (usePessimisticLocking()) {
      Locks.monitorEnterUnsafe(this);
      monitorOwned=true;
    }
    while (true) {
      Holder current=ref;
      updater.ref=current;
      updater.reset();
      DeletionInfo deletionInfo;
      if (cm.deletionInfo().mayModify(current.deletionInfo)) {
        if (inputDeletionInfoCopy == null)         inputDeletionInfoCopy=cm.deletionInfo().copy(HeapAllocator.instance);
        deletionInfo=current.deletionInfo.copy().add(inputDeletionInfoCopy);
        updater.allocated(deletionInfo.unsharedHeapSize() - current.deletionInfo.unsharedHeapSize());
      }
 else {
        deletionInfo=current.deletionInfo;
      }
      Object[] tree=BTree.update(current.tree,metadata.comparator.columnComparator(Memtable.MEMORY_POOL instanceof NativePool),cm,cm.getColumnCount(),true,updater);
      if (tree != null && refUpdater.compareAndSet(this,current,new Holder(tree,deletionInfo))) {
        indexer.updateRowLevelIndexes();
        updater.finish();
        return Pair.create(updater.dataSize,updater.colUpdateTimeDelta);
      }
 else       if (!monitorOwned) {
        boolean shouldLock=usePessimisticLocking();
        if (!shouldLock) {
          shouldLock=updateWastedAllocationTracker(updater.heapSize);
        }
        if (shouldLock) {
          Locks.monitorEnterUnsafe(this);
          monitorOwned=true;
        }
      }
    }
  }
  finally {
    if (monitorOwned)     Locks.monitorExitUnsafe(this);
  }
}
