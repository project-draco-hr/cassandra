{
  List<CounterColumn> columns=new ArrayList<>();
  for (  ByteBuffer name : randomNames())   columns.add(new CounterColumn(name,state.counteradd.next()));
  Map<String,List<Mutation>> row;
  if (state.settings.columns.useSuperColumns) {
    List<Mutation> mutations=new ArrayList<>();
    for (    ColumnParent parent : state.columnParents) {
      CounterSuperColumn csc=new CounterSuperColumn(ByteBuffer.wrap(parent.getSuper_column()),columns);
      ColumnOrSuperColumn cosc=new ColumnOrSuperColumn().setCounter_super_column(csc);
      mutations.add(new Mutation().setColumn_or_supercolumn(cosc));
    }
    row=Collections.singletonMap(state.type.supertable,mutations);
  }
 else {
    List<Mutation> mutations=new ArrayList<>(columns.size());
    for (    CounterColumn c : columns) {
      ColumnOrSuperColumn cosc=new ColumnOrSuperColumn().setCounter_column(c);
      mutations.add(new Mutation().setColumn_or_supercolumn(cosc));
    }
    row=Collections.singletonMap(state.type.table,mutations);
  }
  final ByteBuffer key=getKey();
  final Map<ByteBuffer,Map<String,List<Mutation>>> record=Collections.singletonMap(key,row);
  timeWithRetry(new RunOp(){
    @Override public boolean run() throws Exception {
      client.batch_mutate(record,state.settings.command.consistencyLevel);
      return true;
    }
    @Override public String key(){
      return new String(key.array());
    }
    @Override public int keyCount(){
      return 1;
    }
  }
);
}
