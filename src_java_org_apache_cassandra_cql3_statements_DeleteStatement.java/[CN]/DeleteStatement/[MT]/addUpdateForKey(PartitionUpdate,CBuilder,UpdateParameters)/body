{
  List<Operation> regularDeletions=getRegularOperations();
  List<Operation> staticDeletions=getStaticOperations();
  if (regularDeletions.isEmpty() && staticDeletions.isEmpty()) {
    if (cbuilder.count() == 0) {
      update.addPartitionDeletion(params.deletionTime());
    }
 else     if (cbuilder.remainingCount() == 0) {
      Clustering clustering=cbuilder.build();
      Row.Writer writer=update.writer();
      params.writeClustering(clustering,writer);
      params.writeRowDeletion(writer);
      writer.endOfRow();
    }
 else {
      update.addRangeTombstone(params.makeRangeTombstone(cbuilder));
    }
  }
 else {
    if (!regularDeletions.isEmpty()) {
      if (cbuilder.remainingCount() > 0)       throw new InvalidRequestException(String.format("Primary key column '%s' must be specified in order to delete column '%s'",getFirstEmptyKey().name,regularDeletions.get(0).column.name));
      Clustering clustering=cbuilder.build();
      Row.Writer writer=update.writer();
      params.writeClustering(clustering,writer);
      for (      Operation op : regularDeletions)       op.execute(update.partitionKey(),clustering,writer,params);
      writer.endOfRow();
    }
    if (!staticDeletions.isEmpty()) {
      Row.Writer writer=update.staticWriter();
      for (      Operation op : staticDeletions)       op.execute(update.partitionKey(),Clustering.STATIC_CLUSTERING,writer,params);
      writer.endOfRow();
    }
  }
}
