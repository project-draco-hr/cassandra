{
  double targetp=1;
  for (  SampleOfLongs sampleOfLongs : merge)   targetp=Math.min(targetp,sampleOfLongs.p);
  int maxLength=0;
  for (  SampleOfLongs sampleOfLongs : merge)   maxLength+=sampleOfLongs.sample.length * (targetp / sampleOfLongs.p);
  if (maxLength > maxSamples) {
    targetp*=maxSamples / (double)maxLength;
    maxLength=maxSamples;
  }
  long[] sample=new long[maxLength];
  int count=0;
  out:   for (  SampleOfLongs latencies : merge) {
    long[] in=latencies.sample;
    double p=targetp / latencies.p;
    for (int i=0; i < in.length; i++) {
      if (rnd.nextDouble() < p) {
        sample[count++]=in[i];
        if (count == maxLength)         break out;
      }
    }
  }
  if (count != maxLength)   sample=Arrays.copyOf(sample,count);
  Arrays.sort(sample);
  return new SampleOfLongs(sample,targetp);
}
