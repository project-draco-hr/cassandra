{
  int maxLength=0;
  double targetp=1;
  for (  SampleOfLongs sampleOfLongs : merge) {
    maxLength+=sampleOfLongs.sample.length;
    targetp=Math.min(targetp,sampleOfLongs.p);
  }
  long[] sample=new long[maxLength];
  int count=0;
  for (  SampleOfLongs latencies : merge) {
    long[] in=latencies.sample;
    double p=targetp / latencies.p;
    for (int i=0; i < in.length; i++)     if (rnd.nextDouble() < p)     sample[count++]=in[i];
  }
  if (count > maxSamples) {
    targetp=subsample(rnd,maxSamples,sample,count,targetp);
    count=maxSamples;
  }
  sample=Arrays.copyOf(sample,count);
  Arrays.sort(sample);
  return new SampleOfLongs(sample,targetp);
}
