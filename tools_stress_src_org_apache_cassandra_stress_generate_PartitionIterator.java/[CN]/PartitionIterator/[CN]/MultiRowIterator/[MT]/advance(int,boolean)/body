{
  clusteringComponents[depth].poll();
  position[depth]++;
  while (true) {
    if (clusteringComponents[depth].isEmpty()) {
      if (depth == 0)       return false;
      depth--;
      clusteringComponents[depth].poll();
      if (++position[depth] > limit[depth])       return false;
      continue;
    }
    int compareToLastRow=compareToLastRow();
    if (compareToLastRow > 0 && !first)     return false;
    boolean forceReturnOne=first && compareToLastRow >= 0;
    double thischance=useChance * chancemodifier[depth];
    if (forceReturnOne || thischance > 0.99999f || thischance >= random.nextDouble()) {
      row.row[depth]=clusteringComponents[depth].peek();
      depth++;
      if (depth == clusteringComponents.length)       return true;
      if (useChance < 1d) {
        rollmodifier[depth]=rollmodifier[depth - 1] / Math.min(1d,thischance);
        chancemodifier[depth]=generator.clusteringDescendantAverages[depth] * rollmodifier[depth];
      }
      position[depth]=0;
      fill(depth);
      continue;
    }
    if (compareToLastRow >= 0)     return false;
    clusteringComponents[depth].poll();
    position[depth]++;
  }
}
