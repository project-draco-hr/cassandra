{
  this.isWrite=isWrite;
  if (this.useChance < 1d) {
    Arrays.fill(rollmodifier,1d);
    Arrays.fill(chancemodifier,1d);
  }
  generator.clusteringComponents.get(0).setSeed(idseed);
  int firstComponentCount=(int)generator.clusteringComponents.get(0).clusteringDistribution.next();
  int expectedRowCount;
  int position=seed.position();
  if (isWrite)   expectedRowCount=firstComponentCount * generator.clusteringDescendantAverages[0];
 else   if (position != 0)   expectedRowCount=setLastRow(position - 1);
 else   expectedRowCount=setNoLastRow(firstComponentCount);
  if (Double.isNaN(useChance))   useChance=Math.max(0d,Math.min(1d,targetCount / (double)expectedRowCount));
  this.useChance=useChance;
  while (true) {
    for (    Queue<?> q : clusteringComponents)     q.clear();
    clusteringSeeds[0]=idseed;
    fill(clusteringComponents[0],firstComponentCount,generator.clusteringComponents.get(0));
    if (!isWrite) {
      if (seek(0) != State.SUCCESS)       throw new IllegalStateException();
      return true;
    }
    int count=Math.max(1,expectedRowCount / seed.visits);
    position=seed.moveForwards(count);
    isFirstWrite=position == 0;
    setLastRow(position + count - 1);
switch (seek(position)) {
case END_OF_PARTITION:
      return false;
case SUCCESS:
    return true;
}
}
}
