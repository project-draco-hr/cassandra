{
  if (coldReadsToOmit == 0.0)   return sstables;
  final Map<SSTableReader,Double> hotnessSnapshot=getHotnessMap(sstables);
  Collections.sort(sstables,new Comparator<SSTableReader>(){
    public int compare(    SSTableReader o1,    SSTableReader o2){
      int comparison=Double.compare(hotnessSnapshot.get(o1),hotnessSnapshot.get(o2));
      if (comparison != 0)       return comparison;
      comparison=Long.compare(o1.bytesOnDisk(),o2.bytesOnDisk());
      if (comparison != 0)       return comparison;
      return o1.descriptor.generation - o2.descriptor.generation;
    }
  }
);
  double totalReads=0.0;
  for (  SSTableReader sstr : sstables)   if (sstr.readMeter != null)   totalReads+=sstr.readMeter.twoHourRate();
  if (totalReads == 0.0)   return sstables;
  double maxColdReads=coldReadsToOmit * totalReads;
  double totalColdReads=0.0;
  int cutoffIndex=0;
  while (cutoffIndex < sstables.size()) {
    SSTableReader sstable=sstables.get(cutoffIndex);
    if (sstable.readMeter == null) {
      throw new AssertionError("If you're seeing this exception, please attach your logs to CASSANDRA-8238 to help us debug. " + sstable);
    }
    double reads=sstable.readMeter.twoHourRate();
    if (totalColdReads + reads > maxColdReads)     break;
    totalColdReads+=reads;
    cutoffIndex++;
  }
  List<SSTableReader> hotSSTables=new ArrayList<>(sstables.subList(cutoffIndex,sstables.size()));
  List<SSTableReader> coldSSTables=sstables.subList(0,cutoffIndex);
  logger.debug("hotSSTables={}, coldSSTables={}",hotSSTables.size(),coldSSTables.size());
  if (hotSSTables.size() >= minThreshold)   return hotSSTables;
  if (coldSSTables.size() < minThreshold)   return Collections.emptyList();
  Map<SSTableReader,Set<SSTableReader>> overlapMap=new HashMap<>();
  for (int i=0; i < coldSSTables.size(); i++) {
    SSTableReader sstable=coldSSTables.get(i);
    Set<SSTableReader> overlaps=new HashSet<>();
    for (int j=0; j < coldSSTables.size(); j++) {
      SSTableReader innerSSTable=coldSSTables.get(j);
      if (ColumnNameHelper.overlaps(sstable.getSSTableMetadata().minColumnNames,sstable.getSSTableMetadata().maxColumnNames,innerSSTable.getSSTableMetadata().minColumnNames,innerSSTable.getSSTableMetadata().maxColumnNames,sstable.metadata.comparator)) {
        overlaps.add(innerSSTable);
      }
    }
    overlapMap.put(sstable,overlaps);
  }
  List<Set<SSTableReader>> overlapChains=new ArrayList<>();
  for (  SSTableReader sstable : overlapMap.keySet())   overlapChains.add(createOverlapChain(sstable,overlapMap));
  Collections.sort(overlapChains,new Comparator<Set<SSTableReader>>(){
    @Override public int compare(    Set<SSTableReader> o1,    Set<SSTableReader> o2){
      return Longs.compare(SSTableReader.getTotalBytes(o2),SSTableReader.getTotalBytes(o1));
    }
  }
);
  for (  Set<SSTableReader> overlapping : overlapChains) {
    if (SSTableReader.estimateCompactionGain(overlapping) < 0.7)     return new ArrayList<>(overlapping);
  }
  return Collections.emptyList();
}
