{
  if (!usesSecondaryIndexing || restrictedColumns.isEmpty())   return Collections.emptyList();
  List<IndexExpression> expressions=new ArrayList<IndexExpression>();
  for (  ColumnDefinition def : restrictedColumns.keySet()) {
    Restriction restriction;
switch (def.kind) {
case PARTITION_KEY:
      restriction=keyRestrictions[def.position()];
    break;
case CLUSTERING_COLUMN:
  restriction=columnRestrictions[def.position()];
break;
case REGULAR:
case STATIC:
restriction=metadataRestrictions.get(def.name);
break;
default :
throw new AssertionError();
}
if (restriction.isSlice()) {
Restriction.Slice slice=(Restriction.Slice)restriction;
for (Bound b : Bound.values()) {
if (slice.hasBound(b)) {
ByteBuffer value=validateIndexedValue(def,slice.bound(b,options));
Operator op=slice.getIndexOperator(b);
if (def.type instanceof ReversedType) op=reverse(op);
expressions.add(new IndexExpression(def.name.bytes,op,value));
}
}
}
 else if (restriction.isContains()) {
SingleColumnRestriction.Contains contains=(SingleColumnRestriction.Contains)restriction;
for (ByteBuffer value : contains.values(options)) {
validateIndexedValue(def,value);
expressions.add(new IndexExpression(def.name.bytes,Operator.CONTAINS,value));
}
for (ByteBuffer key : contains.keys(options)) {
validateIndexedValue(def,key);
expressions.add(new IndexExpression(def.name.bytes,Operator.CONTAINS_KEY,key));
}
}
 else {
ByteBuffer value;
if (restriction.isMultiColumn()) {
List<ByteBuffer> values=restriction.values(options);
value=values.get(def.position());
}
 else {
List<ByteBuffer> values=restriction.values(options);
if (values.size() != 1) throw new InvalidRequestException("IN restrictions are not supported on indexed columns");
value=values.get(0);
}
validateIndexedValue(def,value);
expressions.add(new IndexExpression(def.name.bytes,Operator.EQ,value));
}
}
if (usesSecondaryIndexing) {
ColumnFamilyStore cfs=Keyspace.open(keyspace()).getColumnFamilyStore(columnFamily());
SecondaryIndexManager secondaryIndexManager=cfs.indexManager;
secondaryIndexManager.validateIndexSearchersForQuery(expressions);
}
return expressions;
}
