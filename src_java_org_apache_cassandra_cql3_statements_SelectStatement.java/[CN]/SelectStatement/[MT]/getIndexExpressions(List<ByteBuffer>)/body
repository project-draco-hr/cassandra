{
  if (!usesSecondaryIndexing || restrictedNames.isEmpty())   return Collections.emptyList();
  List<IndexExpression> expressions=new ArrayList<IndexExpression>();
  for (  CFDefinition.Name name : restrictedNames.keySet()) {
    Restriction restriction;
switch (name.kind) {
case KEY_ALIAS:
      restriction=keyRestrictions[name.position];
    break;
case COLUMN_ALIAS:
  restriction=columnRestrictions[name.position];
break;
case COLUMN_METADATA:
case STATIC:
restriction=metadataRestrictions.get(name);
break;
default :
throw new AssertionError();
}
if (restriction.isSlice()) {
Restriction.Slice slice=(Restriction.Slice)restriction;
for (Bound b : Bound.values()) {
if (slice.hasBound(b)) {
ByteBuffer value=slice.bound(b,variables);
validateIndexExpressionValue(value,name);
IndexOperator op=slice.getIndexOperator(b);
if (name.type instanceof ReversedType) op=reverse(op);
expressions.add(new IndexExpression(name.name.key,op,value));
}
}
}
 else {
ByteBuffer value;
if (restriction.isMultiColumn()) {
List<ByteBuffer> values=restriction.values(variables);
value=values.get(name.position);
}
 else {
List<ByteBuffer> values=restriction.values(variables);
if (values.size() != 1) throw new InvalidRequestException("IN restrictions are not supported on indexed columns");
value=values.get(0);
}
validateIndexExpressionValue(value,name);
expressions.add(new IndexExpression(name.name.key,IndexOperator.EQ,value));
}
}
return expressions;
}
