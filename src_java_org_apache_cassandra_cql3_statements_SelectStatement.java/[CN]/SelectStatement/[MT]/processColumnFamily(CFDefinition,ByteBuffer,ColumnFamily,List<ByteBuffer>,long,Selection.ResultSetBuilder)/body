{
  ByteBuffer[] keyComponents=cfDef.hasCompositeKey ? ((CompositeType)cfm.getKeyValidator()).split(key) : new ByteBuffer[]{key};
  if (parameters.isDistinct && !selectsStaticColumns) {
    if (!cf.hasOnlyTombstones(now)) {
      result.newRow();
      for (      CFDefinition.Name name : selection.getColumns())       result.add(keyComponents[name.position]);
    }
  }
 else   if (cfDef.isCompact) {
    for (    Column c : cf) {
      if (c.isMarkedForDelete(now))       continue;
      ByteBuffer[] components=null;
      if (cfDef.isComposite) {
        components=((CompositeType)cfm.comparator).split(c.name());
      }
 else       if (sliceRestriction != null) {
        Comparator<ByteBuffer> comp=cfm.comparator;
        if (!sliceRestriction.isInclusive(Bound.START)) {
          ByteBuffer bounds=sliceRestriction.isMultiColumn() ? ((MultiColumnRestriction.Slice)sliceRestriction).componentBounds(Bound.START,variables).get(0) : sliceRestriction.bound(Bound.START,variables);
          if (comp.compare(c.name(),bounds) == 0)           continue;
        }
        if (!sliceRestriction.isInclusive(Bound.END)) {
          ByteBuffer bounds=sliceRestriction.isMultiColumn() ? ((MultiColumnRestriction.Slice)sliceRestriction).componentBounds(Bound.END,variables).get(0) : sliceRestriction.bound(Bound.END,variables);
          if (comp.compare(c.name(),bounds) == 0)           continue;
        }
      }
      result.newRow();
      for (      CFDefinition.Name name : selection.getColumns()) {
switch (name.kind) {
case KEY_ALIAS:
          result.add(keyComponents[name.position]);
        break;
case COLUMN_ALIAS:
      ByteBuffer val=cfDef.isComposite ? (name.position < components.length ? components[name.position] : null) : c.name();
    result.add(val);
  break;
case VALUE_ALIAS:
result.add(c);
break;
case COLUMN_METADATA:
case STATIC:
throw new AssertionError();
default :
throw new AssertionError();
}
}
}
}
 else if (cfDef.isComposite) {
CompositeType composite=(CompositeType)cfm.comparator;
ColumnGroupMap.Builder builder=new ColumnGroupMap.Builder(composite,cfDef.hasCollections,now);
for (Column c : cf) {
if (c.isMarkedForDelete(now)) continue;
builder.add(c);
}
ColumnGroupMap staticGroup=null;
if (!builder.isEmpty() && builder.firstGroup().isStatic) {
staticGroup=builder.firstGroup();
builder.discardFirst();
if (builder.isEmpty() && !usesSecondaryIndexing && hasNoClusteringColumnsRestriction()&& hasValueForQuery(staticGroup)) {
handleGroup(result,keyComponents,ColumnGroupMap.EMPTY,staticGroup);
return;
}
}
for (ColumnGroupMap group : builder.groups()) handleGroup(result,keyComponents,group,staticGroup);
}
 else {
if (cf.hasOnlyTombstones(now)) return;
result.newRow();
for (CFDefinition.Name name : selection.getColumns()) {
if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS) result.add(keyComponents[name.position]);
 else result.add(cf.getColumn(name.name.key));
}
}
}
