{
  List<ColumnDefinition> restrictedColumns=new ArrayList<>();
  Set<ColumnDefinition> seen=new HashSet<>();
  Restriction existing=null;
  int previousPosition=defs.get(0).position() - 1;
  for (int i=0, m=defs.size(); i < m; i++) {
    ColumnDefinition def=defs.get(i);
    if (def.kind != ColumnDefinition.Kind.CLUSTERING_COLUMN)     throw new InvalidRequestException(String.format("Multi-column relations can only be applied to clustering columns: %s",def.name));
    if (seen.contains(def))     throw new InvalidRequestException(String.format("Column \"%s\" appeared twice in a relation: %s",def.name,relation));
    seen.add(def);
    if (def.position() != previousPosition + 1) {
      if (previousPosition == -1)       throw new InvalidRequestException(String.format("Clustering columns may not be skipped in multi-column relations. " + "They should appear in the PRIMARY KEY order. Got %s",relation));
      throw new InvalidRequestException(String.format("Clustering columns must appear in the PRIMARY KEY order in multi-column relations: %s",relation));
    }
    previousPosition++;
    Restriction previous=existing;
    existing=getExistingRestriction(stmt,def);
    Operator operator=relation.operator();
    if (existing != null) {
      if (operator == Operator.EQ || operator == Operator.IN) {
        throw new InvalidRequestException(String.format("Column \"%s\" cannot be restricted by more than one relation if it is in an %s relation",def.name,operator));
      }
 else       if (!existing.isSlice()) {
        throw new InvalidRequestException(String.format("Column \"%s\" cannot be restricted by an equality relation and an inequality relation",def.name));
      }
 else {
        if (!existing.isMultiColumn()) {
          throw new InvalidRequestException(String.format("Column \"%s\" cannot have both tuple-notation inequalities and single-column inequalities: %s",def.name,relation));
        }
        boolean existingRestrictionStartBefore=(i == 0 && def.position() != 0 && stmt.columnRestrictions[def.position() - 1] == existing);
        boolean existingRestrictionStartAfter=(i != 0 && previous != existing);
        if (existingRestrictionStartBefore || existingRestrictionStartAfter) {
          throw new InvalidRequestException(String.format("Column \"%s\" cannot be restricted by two tuple-notation inequalities not starting with the same column: %s",def.name,relation));
        }
        checkBound(existing,def,operator);
      }
    }
    restrictedColumns.add(def);
  }
switch (relation.operator()) {
case EQ:
{
      Term t=relation.getValue().prepare(keyspace(),defs);
      t.collectMarkerSpecification(boundNames);
      Restriction restriction=new MultiColumnRestriction.EQ(t,false);
      for (      ColumnDefinition def : restrictedColumns)       stmt.columnRestrictions[def.position()]=restriction;
      break;
    }
case IN:
{
    Restriction restriction;
    List<? extends Term.MultiColumnRaw> inValues=relation.getInValues();
    if (inValues != null) {
      List<Term> terms=new ArrayList<>(inValues.size());
      for (      Term.MultiColumnRaw tuple : inValues) {
        Term t=tuple.prepare(keyspace(),defs);
        t.collectMarkerSpecification(boundNames);
        terms.add(t);
      }
      restriction=new MultiColumnRestriction.InWithValues(terms);
    }
 else {
      Tuples.INRaw rawMarker=relation.getInMarker();
      AbstractMarker t=rawMarker.prepare(keyspace(),defs);
      t.collectMarkerSpecification(boundNames);
      restriction=new MultiColumnRestriction.InWithMarker(t);
    }
    for (    ColumnDefinition def : restrictedColumns)     stmt.columnRestrictions[def.position()]=restriction;
    break;
  }
case LT:
case LTE:
case GT:
case GTE:
{
  Term t=relation.getValue().prepare(keyspace(),defs);
  t.collectMarkerSpecification(boundNames);
  Restriction.Slice restriction=(Restriction.Slice)getExistingRestriction(stmt,defs.get(0));
  if (restriction == null)   restriction=new MultiColumnRestriction.Slice(false);
  restriction.setBound(relation.operator(),t);
  for (  ColumnDefinition def : defs) {
    stmt.columnRestrictions[def.position()]=restriction;
  }
  break;
}
case NEQ:
throw new InvalidRequestException(String.format("Unsupported \"!=\" relation: %s",relation));
}
}
