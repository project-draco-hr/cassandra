{
  boolean canRestrictFurtherComponents=true;
  ColumnDefinition previous=null;
  Restriction previousRestriction=null;
  Iterator<ColumnDefinition> iter=cfm.clusteringColumns().iterator();
  for (int i=0; i < stmt.columnRestrictions.length; i++) {
    ColumnDefinition cdef=iter.next();
    Restriction restriction=stmt.columnRestrictions[i];
    if (restriction == null) {
      canRestrictFurtherComponents=false;
    }
 else     if (!canRestrictFurtherComponents) {
      if (restriction != previousRestriction) {
        if (hasQueriableIndex) {
          stmt.usesSecondaryIndexing=true;
          break;
        }
        if (previousRestriction == null)         throw new InvalidRequestException(String.format("PRIMARY KEY column \"%s\" cannot be restricted (preceding column \"%s\" is not restricted)",cdef.name,previous.name));
        if (previousRestriction.isMultiColumn() && previousRestriction.isIN())         throw new InvalidRequestException(String.format("PRIMARY KEY column \"%s\" cannot be restricted (preceding column \"%s\" is restricted by an IN tuple notation)",cdef.name,previous.name));
        throw new InvalidRequestException(String.format("PRIMARY KEY column \"%s\" cannot be restricted (preceding column \"%s\" is restricted by a non-EQ relation)",cdef.name,previous.name));
      }
    }
 else     if (restriction.isSlice()) {
      canRestrictFurtherComponents=false;
      Restriction.Slice slice=(Restriction.Slice)restriction;
      if (!cfm.comparator.isCompound() && (!slice.isInclusive(Bound.START) || !slice.isInclusive(Bound.END)))       stmt.sliceRestriction=slice;
    }
 else     if (restriction.isIN()) {
      if (!restriction.isMultiColumn() && i != stmt.columnRestrictions.length - 1)       throw new InvalidRequestException(String.format("Clustering column \"%s\" cannot be restricted by an IN relation",cdef.name));
      if (stmt.selectACollection())       throw new InvalidRequestException(String.format("Cannot restrict column \"%s\" by IN relation as a collection is selected by the query",cdef.name));
      if (restriction.isMultiColumn())       canRestrictFurtherComponents=false;
    }
 else     if (restriction.isContains()) {
      if (!hasQueriableIndex)       throw new InvalidRequestException(String.format("Cannot restrict column \"%s\" by a CONTAINS relation without a secondary index",cdef.name));
      stmt.usesSecondaryIndexing=true;
    }
    previous=cdef;
    previousRestriction=restriction;
  }
}
