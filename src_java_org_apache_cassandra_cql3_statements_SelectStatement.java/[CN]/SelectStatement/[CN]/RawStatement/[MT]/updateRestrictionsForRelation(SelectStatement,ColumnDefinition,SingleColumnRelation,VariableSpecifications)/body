{
switch (def.kind) {
case PARTITION_KEY:
{
      Restriction existingRestriction=stmt.keyRestrictions[def.position()];
      Restriction previousRestriction=def.position() == 0 ? null : stmt.keyRestrictions[def.position() - 1];
      stmt.keyRestrictions[def.position()]=updateSingleColumnRestriction(def,existingRestriction,previousRestriction,relation,names);
      break;
    }
case CLUSTERING_COLUMN:
{
    Restriction existingRestriction=stmt.columnRestrictions[def.position()];
    Restriction previousRestriction=def.position() == 0 ? null : stmt.columnRestrictions[def.position() - 1];
    stmt.columnRestrictions[def.position()]=updateSingleColumnRestriction(def,existingRestriction,previousRestriction,relation,names);
    break;
  }
case COMPACT_VALUE:
{
  throw new InvalidRequestException(String.format("Predicates on the non-primary-key column (%s) of a COMPACT table are not yet supported",def.name));
}
case REGULAR:
case STATIC:
{
Restriction r=updateSingleColumnRestriction(def,stmt.metadataRestrictions.get(def.name),null,relation,names);
if (r.isIN() && !((Restriction.IN)r).canHaveOnlyOneValue()) throw new InvalidRequestException(String.format("IN predicates on non-primary-key columns (%s) is not yet supported",def.name));
stmt.metadataRestrictions.put(def.name,r);
break;
}
}
}
