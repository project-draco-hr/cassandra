{
  ColumnSpecification receiver=name;
  if (newRel.onToken) {
    if (name.kind != CFDefinition.Name.Kind.KEY_ALIAS)     throw new InvalidRequestException(String.format("The token() function is only supported on the partition key, found on %s",name));
    receiver=new ColumnSpecification(name.ksName,name.cfName,new ColumnIdentifier("partition key token",true),StorageService.instance.getPartitioner().getTokenValidator());
  }
switch (newRel.operator()) {
case EQ:
{
      if (restriction != null)       throw new InvalidRequestException(String.format("%s cannot be restricted by more than one relation if it includes an Equal",name));
      Term t=newRel.getValue().prepare(receiver);
      t.collectMarkerSpecification(boundNames);
      restriction=new Restriction(t,newRel.onToken);
    }
  break;
case IN:
if (restriction != null) throw new InvalidRequestException(String.format("%s cannot be restricted by more than one relation if it includes a IN",name));
List<Term> inValues=new ArrayList<Term>(newRel.getInValues().size());
for (Term.Raw raw : newRel.getInValues()) {
Term t=raw.prepare(receiver);
t.collectMarkerSpecification(boundNames);
inValues.add(t);
}
restriction=new Restriction(inValues);
break;
case GT:
case GTE:
case LT:
case LTE:
{
if (restriction == null) restriction=new Restriction(newRel.onToken);
Term t=newRel.getValue().prepare(receiver);
t.collectMarkerSpecification(boundNames);
restriction.setBound(name.name,newRel.operator(),t);
}
break;
}
return restriction;
}
