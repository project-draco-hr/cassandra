{
  CFMetaData cfm=ThriftValidation.validateColumnFamily(keyspace(),columnFamily());
  CFDefinition cfDef=cfm.getCfDef();
  VariableSpecifications boundNames=getBoundVariables();
  if (parameters.isCount && !selectClause.isEmpty())   throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
  Selection selection=selectClause.isEmpty() ? Selection.wildcard(cfDef) : Selection.fromSelectors(cfDef,selectClause);
  SelectStatement stmt=new SelectStatement(cfDef,boundNames.size(),parameters,selection,prepareLimit(boundNames));
  boolean hasQueriableIndex=false;
  boolean hasQueriableClusteringColumnIndex=false;
  for (  Relation relation : whereClause) {
    if (relation.isMultiColumn()) {
      MultiColumnRelation rel=(MultiColumnRelation)relation;
      List<CFDefinition.Name> names=new ArrayList<>(rel.getEntities().size());
      for (      ColumnIdentifier.Raw rawEntity : rel.getEntities()) {
        ColumnIdentifier entity=rawEntity.prepare(cfm);
        boolean[] queriable=processRelationEntity(stmt,relation,entity,cfDef);
        hasQueriableIndex|=queriable[0];
        hasQueriableClusteringColumnIndex|=queriable[1];
        Name name=cfDef.get(entity);
        names.add(name);
      }
      updateRestrictionsForRelation(stmt,names,rel,boundNames);
    }
 else {
      SingleColumnRelation rel=(SingleColumnRelation)relation;
      ColumnIdentifier entity=rel.getEntity().prepare(cfm);
      boolean[] queriable=processRelationEntity(stmt,relation,entity,cfDef);
      hasQueriableIndex|=queriable[0];
      hasQueriableClusteringColumnIndex|=queriable[1];
      Name name=cfDef.get(entity);
      updateRestrictionsForRelation(stmt,name,rel,boundNames);
    }
  }
  processPartitionKeyRestrictions(stmt,cfDef,hasQueriableIndex);
  if (!stmt.usesSecondaryIndexing)   stmt.restrictedNames.keySet().removeAll(cfDef.partitionKeys());
  if (stmt.selectsOnlyStaticColumns && stmt.hasClusteringColumnsRestriction())   throw new InvalidRequestException("Cannot restrict clustering columns when selecting only static columns");
  processColumnRestrictions(stmt,cfDef,hasQueriableIndex);
  if (stmt.isKeyRange && hasQueriableClusteringColumnIndex)   stmt.usesSecondaryIndexing=true;
  for (  Name clusteringColumn : cfDef.clusteringColumns()) {
    Boolean indexed=stmt.restrictedNames.get(clusteringColumn);
    if (indexed == null)     break;
    if (!indexed)     stmt.restrictedNames.remove(clusteringColumn);
  }
  if (!stmt.metadataRestrictions.isEmpty()) {
    if (!hasQueriableIndex)     throw new InvalidRequestException("No indexed columns present in by-columns clause with Equal operator");
    stmt.usesSecondaryIndexing=true;
  }
  if (stmt.usesSecondaryIndexing)   validateSecondaryIndexSelections(stmt);
  if (!stmt.parameters.orderings.isEmpty())   processOrderingClause(stmt,cfDef);
  checkNeedsFiltering(stmt);
  if (parameters.isDistinct)   stmt.validateDistinctSelection();
  return new ParsedStatement.Prepared(stmt,boundNames);
}
