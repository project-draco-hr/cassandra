{
  CFMetaData cfm=ThriftValidation.validateColumnFamily(keyspace(),columnFamily());
  VariableSpecifications boundNames=getBoundVariables();
  if (parameters.isCount && !selectClause.isEmpty())   throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
  Selection selection=selectClause.isEmpty() ? Selection.wildcard(cfm,parameters.isCount,parameters.countAlias) : Selection.fromSelectors(cfm,selectClause);
  SelectStatement stmt=new SelectStatement(cfm,boundNames.size(),parameters,selection,prepareLimit(boundNames));
  boolean hasQueriableIndex=false;
  boolean hasQueriableClusteringColumnIndex=false;
  ColumnFamilyStore cfs=Keyspace.open(keyspace()).getColumnFamilyStore(columnFamily());
  SecondaryIndexManager indexManager=cfs.indexManager;
  for (  Relation relation : whereClause) {
    if (relation.isMultiColumn()) {
      MultiColumnRelation rel=(MultiColumnRelation)relation;
      List<ColumnDefinition> names=new ArrayList<>(rel.getEntities().size());
      for (      ColumnIdentifier.Raw rawEntity : rel.getEntities()) {
        ColumnIdentifier entity=rawEntity.prepare(cfm);
        ColumnDefinition def=cfm.getColumnDefinition(entity);
        boolean[] queriable=processRelationEntity(stmt,indexManager,relation,entity,def);
        hasQueriableIndex|=queriable[0];
        hasQueriableClusteringColumnIndex|=queriable[1];
        names.add(def);
      }
      updateRestrictionsForRelation(stmt,names,rel,boundNames);
    }
 else {
      SingleColumnRelation rel=(SingleColumnRelation)relation;
      ColumnIdentifier entity=rel.getEntity().prepare(cfm);
      ColumnDefinition def=cfm.getColumnDefinition(entity);
      boolean[] queriable=processRelationEntity(stmt,indexManager,relation,entity,def);
      hasQueriableIndex|=queriable[0];
      hasQueriableClusteringColumnIndex|=queriable[1];
      updateRestrictionsForRelation(stmt,def,rel,boundNames);
    }
  }
  processPartitionKeyRestrictions(stmt,hasQueriableIndex,cfm);
  if (!stmt.usesSecondaryIndexing)   stmt.restrictedColumns.keySet().removeAll(cfm.partitionKeyColumns());
  if (stmt.selectsOnlyStaticColumns && stmt.hasClusteringColumnsRestriction())   throw new InvalidRequestException("Cannot restrict clustering columns when selecting only static columns");
  processColumnRestrictions(stmt,hasQueriableIndex,cfm);
  if (stmt.isKeyRange && hasQueriableClusteringColumnIndex)   stmt.usesSecondaryIndexing=true;
  int numberOfRestrictionsEvaluatedWithSlices=0;
  for (  ColumnDefinition def : cfm.clusteringColumns()) {
    Boolean indexed=stmt.restrictedColumns.get(def);
    if (indexed == null)     break;
    if (!(indexed && stmt.usesSecondaryIndexing) && stmt.columnRestrictions[def.position()].canEvaluateWithSlices()) {
      stmt.restrictedColumns.remove(def);
      numberOfRestrictionsEvaluatedWithSlices++;
    }
  }
  if (!stmt.metadataRestrictions.isEmpty())   stmt.usesSecondaryIndexing=true;
  if (stmt.usesSecondaryIndexing)   validateSecondaryIndexSelections(stmt);
  if (!stmt.parameters.orderings.isEmpty())   processOrderingClause(stmt,cfm);
  checkNeedsFiltering(stmt,numberOfRestrictionsEvaluatedWithSlices);
  if (parameters.isDistinct)   stmt.validateDistinctSelection();
  return new ParsedStatement.Prepared(stmt,boundNames);
}
