{
  verifyOrderingIsAllowed(stmt);
  if (stmt.keyIsInRelation) {
    stmt.orderingIndexes=new HashMap<CFDefinition.Name,Integer>();
    for (    ColumnIdentifier.Raw rawColumn : stmt.parameters.orderings.keySet()) {
      ColumnIdentifier column=rawColumn.prepare(cfDef.cfm);
      final CFDefinition.Name name=cfDef.get(column);
      if (name == null)       handleUnrecognizedOrderingColumn(column);
      if (selectClause.isEmpty()) {
        stmt.orderingIndexes.put(name,Iterables.indexOf(cfDef,new Predicate<CFDefinition.Name>(){
          public boolean apply(          CFDefinition.Name n){
            return name.equals(n);
          }
        }
));
      }
 else {
        boolean hasColumn=false;
        List<Name> selectedColumns=stmt.selection.getColumns();
        for (int i=0; i < selectedColumns.size(); i++) {
          Name selected=selectedColumns.get(i);
          if (name.equals(selected)) {
            stmt.orderingIndexes.put(name,i);
            hasColumn=true;
            break;
          }
        }
        if (!hasColumn)         throw new InvalidRequestException(String.format("ORDER BY can only be performed on columns in the select clause (got %s)",name.name));
      }
    }
  }
  stmt.isReversed=isReversed(stmt,cfDef);
}
