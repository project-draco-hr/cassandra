{
  CFMetaData cfm=ThriftValidation.validateColumnFamily(keyspace(),columnFamily());
  ThriftValidation.validateConsistencyLevel(keyspace(),parameters.consistencyLevel,RequestType.READ);
  if (parameters.limit <= 0)   throw new InvalidRequestException("LIMIT must be strictly positive");
  CFDefinition cfDef=cfm.getCfDef();
  SelectStatement stmt=new SelectStatement(cfDef,parameters);
  stmt.setBoundTerms(getBoundsTerms());
  if (parameters.isCount) {
    if (selectClause.size() != 1)     throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
    String columnName=selectClause.get(0).toString();
    if (!columnName.equals("*") && !columnName.equals("1"))     throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
  }
 else {
    for (    ColumnIdentifier t : selectClause) {
      CFDefinition.Name name=cfDef.get(t);
      if (name == null)       throw new InvalidRequestException(String.format("Undefined name %s in selection clause",t));
      stmt.selectedNames.add(Pair.create(name,t));
    }
  }
  for (  Relation rel : whereClause) {
    CFDefinition.Name name=cfDef.get(rel.getEntity());
    if (name == null)     throw new InvalidRequestException(String.format("Undefined name %s in where clause ('%s')",rel.getEntity(),rel));
    if (name.kind == CFDefinition.Name.Kind.VALUE_ALIAS)     throw new InvalidRequestException(String.format("Restricting the value of a compact CF (%s) is not supported",name.name));
    Restriction restriction=stmt.restrictions.get(name.name);
switch (rel.operator()) {
case EQ:
      if (restriction != null)       throw new InvalidRequestException(String.format("%s cannot be restricted by more than one relation if it includes an Equal",name));
    stmt.restrictions.put(name.name,new Restriction(Collections.singletonList(rel.getValue())));
  break;
case GT:
case GTE:
if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS && !StorageService.getPartitioner().preservesOrder()) throw new InvalidRequestException("Only EQ and IN relation are supported on first component of the PRIMARY KEY for RandomPartitioner");
if (restriction == null) {
restriction=new Restriction();
stmt.restrictions.put(name.name,restriction);
}
if (restriction.start != null) throw new InvalidRequestException(String.format("%s cannot be restricted by more than one Greater-Than relation",name));
restriction.start=rel.getValue();
if (rel.operator() == Relation.Type.GTE) restriction.startInclusive=true;
break;
case LT:
case LTE:
if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS && !StorageService.getPartitioner().preservesOrder()) throw new InvalidRequestException("Only EQ and IN relation are supported on first component of the PRIMARY KEY for RandomPartitioner");
if (restriction == null) {
restriction=new Restriction();
stmt.restrictions.put(name.name,restriction);
}
if (restriction.end != null) throw new InvalidRequestException(String.format("%s cannot be restricted by more than one Lesser-Than relation",name));
restriction.end=rel.getValue();
if (rel.operator() == Relation.Type.LTE) restriction.endInclusive=true;
break;
case IN:
if (restriction != null) throw new InvalidRequestException(String.format("%s cannot be restricted by more than one reation if it includes a IN",name));
if (name.kind != CFDefinition.Name.Kind.KEY_ALIAS) throw new InvalidRequestException("IN relation can only be applied to the first component of the PRIMARY KEY");
stmt.restrictions.put(name.name,new Restriction(rel.getInValues()));
break;
}
}
boolean shouldBeDone=false;
CFDefinition.Name previous=null;
for (CFDefinition.Name cname : cfDef.columns.values()) {
Restriction restriction=stmt.restrictions.get(cname.name);
if (restriction == null) shouldBeDone=true;
 else if (shouldBeDone) throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)",cname,previous));
 else if (!restriction.isEquality()) shouldBeDone=true;
 else if (restriction.eqValues.size() > 1) throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation",cname));
previous=cname;
}
if (!cfDef.metadata.values().isEmpty()) {
boolean hasEq=false;
Set<ByteBuffer> indexed=Table.open(keyspace()).getColumnFamilyStore(columnFamily()).indexManager.getIndexedColumns();
for (CFDefinition.Name name : cfDef.metadata.values()) {
Restriction restriction=stmt.restrictions.get(name.name);
if (restriction == null) continue;
stmt.hasIndexedExpression=true;
if (restriction.isEquality() && indexed.contains(name.name.key)) {
hasEq=true;
break;
}
}
if (stmt.hasIndexedExpression && !hasEq) throw new InvalidRequestException("No indexed columns present in by-columns clause with Equal operator");
Restriction r=stmt.restrictions.get(cfDef.key.name);
if (r != null && r.isEquality()) {
if (r.eqValues.size() > 1) throw new InvalidRequestException("Select on indexed columns and with IN clause for the PRIMARY KEY are not supported");
r.start=r.eqValues.get(0);
r.startInclusive=true;
r.end=r.eqValues.get(0);
r.endInclusive=true;
r.eqValues=null;
}
}
if (stmt.parameters.isColumnsReversed) {
Restriction r=stmt.restrictions.get(cfDef.key.name);
if (r == null || !r.isEquality()) throw new InvalidRequestException("Descending order is only supported is the first part of the PRIMARY KEY is restricted by an Equal or a IN");
}
return stmt;
}
