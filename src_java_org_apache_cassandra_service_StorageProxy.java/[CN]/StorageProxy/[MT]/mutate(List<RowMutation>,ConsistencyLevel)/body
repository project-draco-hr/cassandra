{
  long startTime=System.nanoTime();
  List<IWriteResponseHandler> responseHandlers=new ArrayList<IWriteResponseHandler>();
  RowMutation mostRecentRowMutation=null;
  StorageService ss=StorageService.instance;
  String localDataCenter=DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());
  try {
    for (    RowMutation rm : mutations) {
      mostRecentRowMutation=rm;
      String table=rm.getTable();
      AbstractReplicationStrategy rs=Table.open(table).getReplicationStrategy();
      List<InetAddress> naturalEndpoints=ss.getNaturalEndpoints(table,rm.key());
      Collection<InetAddress> writeEndpoints=ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()),table,naturalEndpoints);
      Multimap<InetAddress,InetAddress> hintedEndpoints=rs.getHintedEndpoints(writeEndpoints);
      final IWriteResponseHandler responseHandler=rs.getWriteResponseHandler(writeEndpoints,hintedEndpoints,consistency_level);
      responseHandler.assureSufficientLiveNodes();
      responseHandlers.add(responseHandler);
      Multimap<String,Pair<Message,InetAddress>> dcMessages=HashMultimap.create(hintedEndpoints.size(),10);
      Message unhintedMessage=null;
      updateDestinationForCommutativeTypes(consistency_level,rm,hintedEndpoints);
      for (      Map.Entry<InetAddress,Collection<InetAddress>> entry : hintedEndpoints.asMap().entrySet()) {
        InetAddress destination=entry.getKey();
        Collection<InetAddress> targets=entry.getValue();
        String dc=DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);
        if (targets.size() == 1 && targets.iterator().next().equals(destination)) {
          rm.updateCommutativeTypes(destination);
          if (destination.equals(FBUtilities.getLocalAddress())) {
            insertLocalMessage(rm,responseHandler);
          }
 else {
            if (unhintedMessage == null) {
              unhintedMessage=rm.makeRowMutationMessage();
              MessagingService.instance().addCallback(responseHandler,unhintedMessage.getMessageId());
            }
            if (logger.isDebugEnabled())             logger.debug("insert writing key " + FBUtilities.bytesToHex(rm.key()) + " to "+ unhintedMessage.getMessageId()+ "@"+ destination);
            dcMessages.put(dc,new Pair<Message,InetAddress>(unhintedMessage,destination));
          }
        }
 else {
          Message hintedMessage=rm.makeRowMutationMessage();
          for (          InetAddress target : targets) {
            if (!target.equals(destination)) {
              addHintHeader(hintedMessage,target);
              if (logger.isDebugEnabled())               logger.debug("insert writing key " + FBUtilities.bytesToHex(rm.key()) + " to "+ hintedMessage.getMessageId()+ "@"+ destination+ " for "+ target);
            }
          }
          responseHandler.addHintCallback(hintedMessage,destination);
          dcMessages.put(dc,new Pair<Message,InetAddress>(hintedMessage,destination));
        }
      }
      sendMessages(localDataCenter,dcMessages);
    }
    for (    IWriteResponseHandler responseHandler : responseHandlers)     responseHandler.get();
  }
 catch (  IOException e) {
    if (mostRecentRowMutation == null)     throw new RuntimeException("no mutations were seen but found an error during write anyway",e);
 else     throw new RuntimeException("error writing key " + FBUtilities.bytesToHex(mostRecentRowMutation.key()),e);
  }
 finally {
    writeStats.addNano(System.nanoTime() - startTime);
  }
}
