{
  long startTime=System.currentTimeMillis();
  TokenMetadata tokenMetadata=StorageService.instance().getTokenMetadata();
  InetAddress endPoint=StorageService.instance().getPrimary(command.startKey.token);
  InetAddress startEndpoint=endPoint;
  int responseCount=determineBlockFor(DatabaseDescriptor.getReplicationFactor(),DatabaseDescriptor.getReplicationFactor(),consistency_level);
  Map<String,ColumnFamily> rows=new HashMap<String,ColumnFamily>(command.max_keys);
  do {
    Range primaryRange=StorageService.instance().getPrimaryRangeForEndPoint(endPoint);
    List<InetAddress> endpoints=StorageService.instance().getLiveNaturalEndpoints(primaryRange.right());
    if (endpoints.size() < responseCount)     throw new UnavailableException();
    DecoratedKey<?> startKey;
    DecoratedKey<?> finishKey;
    if (primaryRange.left().equals(primaryRange.right())) {
      startKey=command.startKey;
      finishKey=command.finishKey;
    }
 else {
      startKey=(DecoratedKey<?>)ObjectUtils.max(command.startKey,new DecoratedKey<Token<?>>(primaryRange.left(),null));
      finishKey=command.finishKey.isEmpty() ? new DecoratedKey<Token<?>>(primaryRange.right(),null) : (DecoratedKey<?>)ObjectUtils.min(command.finishKey,new DecoratedKey<Token<?>>(primaryRange.right(),null));
    }
    RangeSliceCommand c2=new RangeSliceCommand(command.keyspace,command.column_family,command.super_column,command.predicate,startKey,finishKey,command.max_keys);
    Message message=c2.getMessage();
    RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(command.keyspace,primaryRange,endpoints);
    QuorumResponseHandler<Map<String,ColumnFamily>> handler=new QuorumResponseHandler<Map<String,ColumnFamily>>(responseCount,resolver);
    if (logger.isDebugEnabled())     logger.debug("reading " + command + " for "+ primaryRange+ " from "+ message.getMessageId()+ "@"+ endPoint);
    for (    InetAddress replicaEndpoint : endpoints) {
      MessagingService.instance().sendRR(message,replicaEndpoint,handler);
    }
    try {
      rows.putAll(handler.get());
    }
 catch (    TimeoutException e) {
      throw new TimedOutException();
    }
catch (    DigestMismatchException e) {
      throw new AssertionError(e);
    }
    if (rows.size() >= command.max_keys || resolver.completed())     break;
    endPoint=tokenMetadata.getSuccessor(endPoint);
  }
 while (!endPoint.equals(startEndpoint));
  List<Pair<String,ColumnFamily>> results=new ArrayList<Pair<String,ColumnFamily>>(rows.size());
  for (  Map.Entry<String,ColumnFamily> entry : rows.entrySet()) {
    ColumnFamily cf=entry.getValue();
    results.add(new Pair<String,ColumnFamily>(entry.getKey(),cf));
  }
  Collections.sort(results,new Comparator<Pair<String,ColumnFamily>>(){
    public int compare(    Pair<String,ColumnFamily> o1,    Pair<String,ColumnFamily> o2){
      return keyComparator.compare(o1.left,o2.left);
    }
  }
);
  rangeStats.add(System.currentTimeMillis() - startTime);
  return results;
}
