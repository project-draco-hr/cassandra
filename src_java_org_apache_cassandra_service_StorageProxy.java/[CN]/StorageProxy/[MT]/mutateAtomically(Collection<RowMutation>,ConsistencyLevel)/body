{
  Tracing.trace("Determining replicas for atomic batch");
  long startTime=System.nanoTime();
  List<WriteResponseHandlerWrapper> wrappers=new ArrayList<WriteResponseHandlerWrapper>(mutations.size());
  String localDataCenter=DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());
  try {
    for (    RowMutation mutation : mutations) {
      WriteResponseHandlerWrapper wrapper=wrapResponseHandler(mutation,consistency_level,WriteType.BATCH);
      wrapper.handler.assureSufficientLiveNodes();
      wrappers.add(wrapper);
    }
    Collection<InetAddress> batchlogEndpoints=getBatchlogEndpoints(localDataCenter,consistency_level);
    UUID batchUUID=UUID.randomUUID();
    syncWriteToBatchlog(mutations,batchlogEndpoints,batchUUID);
    syncWriteBatchedMutations(wrappers,localDataCenter,consistency_level);
    asyncRemoveFromBatchlog(batchlogEndpoints,batchUUID);
  }
 catch (  UnavailableException e) {
    writeMetrics.unavailables.mark();
    ClientRequestMetrics.writeUnavailables.inc();
    Tracing.trace("Unavailable");
    throw e;
  }
catch (  WriteTimeoutException e) {
    writeMetrics.timeouts.mark();
    ClientRequestMetrics.writeTimeouts.inc();
    Tracing.trace("Write timeout; received {} of {} required replies",e.received,e.blockFor);
    throw e;
  }
 finally {
    writeMetrics.addNano(System.nanoTime() - startTime);
  }
}
