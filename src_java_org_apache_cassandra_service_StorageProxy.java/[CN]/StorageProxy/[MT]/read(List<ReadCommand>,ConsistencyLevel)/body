{
  if (StorageService.instance.isBootstrapMode() && !systemKeyspaceQuery(commands)) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    throw new IsBootstrappingException();
  }
  long start=System.nanoTime();
  List<Row> rows=null;
  try {
    if (consistency_level == ConsistencyLevel.SERIAL) {
      if (commands.size() > 1)       throw new InvalidRequestException("SERIAL consistency may only be requested for one row at a time");
      ReadCommand command=commands.get(0);
      CFMetaData metadata=Schema.instance.getCFMetaData(command.ksName,command.cfName);
      long timeout=TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getCasContentionTimeout());
      while (true) {
        Pair<List<InetAddress>,Integer> p=getPaxosParticipants(command.ksName,command.key);
        List<InetAddress> liveEndpoints=p.left;
        int requiredParticipants=p.right;
        if (beginAndRepairPaxos(command.key,metadata,liveEndpoints,requiredParticipants) != null)         break;
        if (System.nanoTime() - start >= timeout)         throw new WriteTimeoutException(WriteType.CAS,ConsistencyLevel.SERIAL,-1,-1);
      }
      rows=fetchRows(commands,ConsistencyLevel.QUORUM);
    }
 else {
      rows=fetchRows(commands,consistency_level);
    }
  }
 catch (  UnavailableException e) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    throw e;
  }
catch (  ReadTimeoutException e) {
    readMetrics.timeouts.mark();
    ClientRequestMetrics.readTimeouts.inc();
    throw e;
  }
 finally {
    readMetrics.addNano(System.nanoTime() - start);
  }
  return rows;
}
