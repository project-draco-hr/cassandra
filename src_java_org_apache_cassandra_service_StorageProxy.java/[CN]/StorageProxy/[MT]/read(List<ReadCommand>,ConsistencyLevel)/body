{
  if (StorageService.instance.isBootstrapMode() && !systemKeyspaceQuery(commands)) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    throw new IsBootstrappingException();
  }
  long start=System.nanoTime();
  List<Row> rows=null;
  try {
    if (consistency_level == ConsistencyLevel.SERIAL) {
      if (commands.size() > 1)       throw new InvalidRequestException("SERIAL consistency may only be requested for one row at a time");
      ReadCommand command=commands.get(0);
      CFMetaData metadata=Schema.instance.getCFMetaData(command.ksName,command.cfName);
      Pair<List<InetAddress>,Integer> p=getPaxosParticipants(command.ksName,command.key);
      List<InetAddress> liveEndpoints=p.left;
      int requiredParticipants=p.right;
      try {
        beginAndRepairPaxos(start,command.key,metadata,liveEndpoints,requiredParticipants);
      }
 catch (      WriteTimeoutException e) {
        throw new ReadTimeoutException(ConsistencyLevel.SERIAL,-1,-1,false);
      }
      rows=fetchRows(commands,ConsistencyLevel.QUORUM);
    }
 else {
      rows=fetchRows(commands,consistency_level);
    }
  }
 catch (  UnavailableException e) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    throw e;
  }
catch (  ReadTimeoutException e) {
    readMetrics.timeouts.mark();
    ClientRequestMetrics.readTimeouts.inc();
    throw e;
  }
 finally {
    readMetrics.addNano(System.nanoTime() - start);
  }
  return rows;
}
