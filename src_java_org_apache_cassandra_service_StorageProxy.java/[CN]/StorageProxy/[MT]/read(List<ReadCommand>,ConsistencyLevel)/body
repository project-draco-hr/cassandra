{
  if (StorageService.instance.isBootstrapMode() && !systemKeyspaceQuery(commands)) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    throw new IsBootstrappingException();
  }
  long start=System.nanoTime();
  List<Row> rows=null;
  try {
    if (consistency_level.isSerialConsistency()) {
      if (commands.size() > 1)       throw new InvalidRequestException("SERIAL/LOCAL_SERIAL consistency may only be requested for one row at a time");
      ReadCommand command=commands.get(0);
      CFMetaData metadata=Schema.instance.getCFMetaData(command.ksName,command.cfName);
      Pair<List<InetAddress>,Integer> p=getPaxosParticipants(command.ksName,command.key,consistency_level);
      List<InetAddress> liveEndpoints=p.left;
      int requiredParticipants=p.right;
      final ConsistencyLevel consistencyForCommitOrFetch=consistency_level == ConsistencyLevel.LOCAL_SERIAL ? ConsistencyLevel.LOCAL_QUORUM : ConsistencyLevel.QUORUM;
      try {
        final Pair<UUID,Integer> pair=beginAndRepairPaxos(start,command.key,metadata,liveEndpoints,requiredParticipants,consistency_level,consistencyForCommitOrFetch,false);
        if (pair.right > 0)         casReadMetrics.contention.update(pair.right);
      }
 catch (      WriteTimeoutException e) {
        throw new ReadTimeoutException(consistency_level,0,consistency_level.blockFor(Keyspace.open(command.ksName)),false);
      }
      rows=fetchRows(commands,consistencyForCommitOrFetch);
    }
 else {
      rows=fetchRows(commands,consistency_level);
    }
  }
 catch (  UnavailableException e) {
    readMetrics.unavailables.mark();
    ClientRequestMetrics.readUnavailables.inc();
    if (consistency_level.isSerialConsistency())     casReadMetrics.unavailables.mark();
    throw e;
  }
catch (  ReadTimeoutException e) {
    readMetrics.timeouts.mark();
    ClientRequestMetrics.readTimeouts.inc();
    if (consistency_level.isSerialConsistency())     casReadMetrics.timeouts.mark();
    throw e;
  }
 finally {
    long latency=System.nanoTime() - start;
    readMetrics.addNano(latency);
    if (consistency_level.isSerialConsistency())     casReadMetrics.addNano(latency);
    for (    ReadCommand command : commands)     Keyspace.open(command.ksName).getColumnFamilyStore(command.cfName).metric.coordinatorReadLatency.update(latency,TimeUnit.NANOSECONDS);
  }
  return rows;
}
