{
  long startTime=System.nanoTime();
  TokenMetadata tokenMetadata=StorageService.instance.getTokenMetadata();
  Iterator<Token> iter=TokenMetadata.ringIterator(tokenMetadata.sortedTokens(),command.range.left);
  final String table=command.keyspace;
  int responseCount=determineBlockFor(DatabaseDescriptor.getReplicationFactor(table),DatabaseDescriptor.getReplicationFactor(table),consistency_level);
  Map<String,ColumnFamily> rows=new HashMap<String,ColumnFamily>(command.max_keys);
  outer:   while (iter.hasNext()) {
    Token currentToken=iter.next();
    Range currentRange=new Range(tokenMetadata.getPredecessor(currentToken),currentToken);
    List<InetAddress> endpoints=StorageService.instance.getLiveNaturalEndpoints(command.keyspace,currentToken);
    if (endpoints.size() < responseCount)     throw new UnavailableException();
    DatabaseDescriptor.getEndPointSnitch(command.keyspace).sortByProximity(FBUtilities.getLocalAddress(),endpoints);
    List<AbstractBounds> restricted=command.range.restrictTo(currentRange);
    for (    AbstractBounds range : restricted) {
      RangeSliceCommand c2=new RangeSliceCommand(command.keyspace,command.column_family,command.super_column,command.predicate,range,command.max_keys);
      Message message=c2.getMessage();
      RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(command.keyspace,currentRange,endpoints);
      QuorumResponseHandler<Map<String,ColumnFamily>> handler=new QuorumResponseHandler<Map<String,ColumnFamily>>(responseCount,resolver);
      Iterator<InetAddress> endpointIter=endpoints.iterator();
      for (int i=0; i < responseCount; i++) {
        InetAddress endpoint=endpointIter.next();
        MessagingService.instance.sendRR(message,endpoint,handler);
        if (logger.isDebugEnabled())         logger.debug("reading " + c2 + " for "+ range+ " from "+ message.getMessageId()+ "@"+ endpoint);
      }
      try {
        rows.putAll(handler.get());
      }
 catch (      DigestMismatchException e) {
        throw new AssertionError(e);
      }
      if (rows.size() >= command.max_keys || resolver.completed())       break outer;
    }
  }
  List<Pair<String,ColumnFamily>> results=new ArrayList<Pair<String,ColumnFamily>>(rows.size());
  for (  Map.Entry<String,ColumnFamily> entry : rows.entrySet()) {
    ColumnFamily cf=entry.getValue();
    results.add(new Pair<String,ColumnFamily>(entry.getKey(),cf));
  }
  Collections.sort(results,new Comparator<Pair<String,ColumnFamily>>(){
    public int compare(    Pair<String,ColumnFamily> o1,    Pair<String,ColumnFamily> o2){
      return keyComparator.compare(o1.left,o2.left);
    }
  }
);
  rangeStats.addNano(System.nanoTime() - startTime);
  return results;
}
