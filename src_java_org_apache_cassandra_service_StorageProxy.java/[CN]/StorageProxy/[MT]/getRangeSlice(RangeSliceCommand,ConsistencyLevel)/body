{
  long startTime=System.nanoTime();
  TokenMetadata tokenMetadata=StorageService.instance.getTokenMetadata();
  InetAddress endPoint=StorageService.instance.getPrimary(command.range.left);
  InetAddress startEndpoint=endPoint;
  final String table=command.keyspace;
  int responseCount=determineBlockFor(DatabaseDescriptor.getReplicationFactor(table),DatabaseDescriptor.getReplicationFactor(table),consistency_level);
  Map<String,ColumnFamily> rows=new HashMap<String,ColumnFamily>(command.max_keys);
  outer:   do {
    Range primaryRange=StorageService.instance.getPrimaryRangeForEndPoint(endPoint);
    List<InetAddress> endpoints=StorageService.instance.getLiveNaturalEndpoints(command.keyspace,primaryRange.right);
    if (endpoints.size() < responseCount)     throw new UnavailableException();
    List<AbstractBounds> restricted=command.range.restrictTo(primaryRange);
    for (    AbstractBounds range : restricted) {
      RangeSliceCommand c2=new RangeSliceCommand(command.keyspace,command.column_family,command.super_column,command.predicate,range,command.max_keys);
      Message message=c2.getMessage();
      RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(command.keyspace,primaryRange,endpoints);
      QuorumResponseHandler<Map<String,ColumnFamily>> handler=new QuorumResponseHandler<Map<String,ColumnFamily>>(responseCount,resolver);
      if (logger.isDebugEnabled())       logger.debug("reading " + c2 + " for "+ range+ " from "+ message.getMessageId()+ "@"+ endPoint);
      for (      InetAddress replicaEndpoint : endpoints) {
        MessagingService.instance.sendRR(message,replicaEndpoint,handler);
      }
      try {
        rows.putAll(handler.get());
      }
 catch (      DigestMismatchException e) {
        throw new AssertionError(e);
      }
      if (rows.size() >= command.max_keys || resolver.completed())       break outer;
    }
    endPoint=tokenMetadata.getSuccessor(endPoint);
  }
 while (!endPoint.equals(startEndpoint));
  List<Pair<String,ColumnFamily>> results=new ArrayList<Pair<String,ColumnFamily>>(rows.size());
  for (  Map.Entry<String,ColumnFamily> entry : rows.entrySet()) {
    ColumnFamily cf=entry.getValue();
    results.add(new Pair<String,ColumnFamily>(entry.getKey(),cf));
  }
  Collections.sort(results,new Comparator<Pair<String,ColumnFamily>>(){
    public int compare(    Pair<String,ColumnFamily> o1,    Pair<String,ColumnFamily> o2){
      return keyComparator.compare(o1.left,o2.left);
    }
  }
);
  rangeStats.addNano(System.nanoTime() - startTime);
  return results;
}
