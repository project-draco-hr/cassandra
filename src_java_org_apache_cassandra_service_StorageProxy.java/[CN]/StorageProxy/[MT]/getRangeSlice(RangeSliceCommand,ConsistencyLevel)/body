{
  if (logger.isDebugEnabled())   logger.debug(command);
  long startTime=System.nanoTime();
  final String table=command.keyspace;
  int responseCount=determineBlockFor(DatabaseDescriptor.getReplicationFactor(table),consistency_level);
  List<Pair<AbstractBounds,List<InetAddress>>> ranges=getRestrictedRanges(command.range,command.keyspace,responseCount);
  List<Row> rows=new ArrayList<Row>(command.max_keys);
  for (  Pair<AbstractBounds,List<InetAddress>> pair : getRangeIterator(ranges,command.range.left)) {
    AbstractBounds range=pair.left;
    List<InetAddress> endpoints=pair.right;
    RangeSliceCommand c2=new RangeSliceCommand(command.keyspace,command.column_family,command.super_column,command.predicate,range,command.max_keys);
    Message message=c2.getMessage();
    RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(command.keyspace,endpoints);
    QuorumResponseHandler<List<Row>> handler=new QuorumResponseHandler<List<Row>>(responseCount,resolver);
    for (    InetAddress endpoint : endpoints) {
      MessagingService.instance.sendRR(message,endpoint,handler);
      if (logger.isDebugEnabled())       logger.debug("reading " + c2 + " from "+ message.getMessageId()+ "@"+ endpoint);
    }
    try {
      if (logger.isDebugEnabled()) {
        for (        Row row : handler.get()) {
          logger.debug("range slices read " + row.key);
        }
      }
      rows.addAll(handler.get());
    }
 catch (    DigestMismatchException e) {
      throw new AssertionError(e);
    }
    if (rows.size() >= command.max_keys)     break;
  }
  rangeStats.addNano(System.nanoTime() - startTime);
  return rows.size() > command.max_keys ? rows.subList(0,command.max_keys) : rows;
}
