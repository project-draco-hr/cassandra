{
  if (logger.isDebugEnabled())   logger.debug("Command/ConsistencyLevel is {}/{}",command.toString(),consistency_level);
  long startTime=System.nanoTime();
  List<Row> rows;
  try {
    int columnsCount=0;
    rows=new ArrayList<Row>();
    List<AbstractBounds<RowPosition>> ranges=getRestrictedRanges(command.range);
    long estimatedKeys=Table.open(command.keyspace).getColumnFamilyStore(command.column_family).estimateKeys();
    int concurrencyFactor=(int)command.maxResults / ((int)estimatedKeys + 1);
    if (concurrencyFactor <= 0)     concurrencyFactor=1;
    if (concurrencyFactor > ranges.size())     concurrencyFactor=ranges.size();
    List<ReadCallback<RangeSliceReply,Iterable<Row>>> scanHandlers=new ArrayList<ReadCallback<RangeSliceReply,Iterable<Row>>>(concurrencyFactor);
    for (    AbstractBounds<RowPosition> range : ranges) {
      RangeSliceCommand nodeCmd=new RangeSliceCommand(command.keyspace,command.column_family,command.super_column,command.predicate,range,command.row_filter,command.maxResults,command.maxIsColumns,command.isPaging);
      List<InetAddress> liveEndpoints=StorageService.instance.getLiveNaturalEndpoints(nodeCmd.keyspace,range.right);
      DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(),liveEndpoints);
      if (consistency_level == ConsistencyLevel.ONE && !liveEndpoints.isEmpty() && liveEndpoints.get(0).equals(FBUtilities.getBroadcastAddress())) {
        if (logger.isDebugEnabled())         logger.debug("local range slice");
        try {
          rows.addAll(RangeSliceVerbHandler.executeLocally(nodeCmd));
          for (          Row row : rows)           columnsCount+=row.getLiveColumnCount();
        }
 catch (        ExecutionException e) {
          throw new RuntimeException(e.getCause());
        }
catch (        InterruptedException e) {
          throw new AssertionError(e);
        }
      }
 else {
        RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(nodeCmd.keyspace);
        ReadCallback<RangeSliceReply,Iterable<Row>> handler=getReadCallback(resolver,nodeCmd,consistency_level,liveEndpoints);
        handler.assureSufficientLiveNodes();
        resolver.setSources(handler.endpoints);
        MessageOut<RangeSliceCommand> message=nodeCmd.createMessage();
        for (        InetAddress endpoint : handler.endpoints) {
          MessagingService.instance().sendRR(message,endpoint,handler);
          if (logger.isDebugEnabled())           logger.debug("reading " + nodeCmd + " from "+ endpoint);
        }
        scanHandlers.add(handler);
        if (scanHandlers.size() >= concurrencyFactor) {
          for (          ReadCallback<RangeSliceReply,Iterable<Row>> scanHandler : scanHandlers) {
            try {
              for (              Row row : scanHandler.get()) {
                rows.add(row);
                columnsCount+=row.getLiveColumnCount();
                logger.debug("range slices read {}",row.key);
              }
              FBUtilities.waitOnFutures(resolver.repairResults,DatabaseDescriptor.getRangeRpcTimeout());
            }
 catch (            TimeoutException ex) {
              if (logger.isDebugEnabled())               logger.debug("Range slice timeout: {}",ex.toString());
              throw ex;
            }
catch (            DigestMismatchException e) {
              throw new AssertionError(e);
            }
            int count=nodeCmd.maxIsColumns ? columnsCount : rows.size();
            if (count >= nodeCmd.maxResults)             break;
          }
          scanHandlers.clear();
        }
      }
    }
  }
  finally {
    rangeStats.addNano(System.nanoTime() - startTime);
  }
  return trim(command,rows);
}
