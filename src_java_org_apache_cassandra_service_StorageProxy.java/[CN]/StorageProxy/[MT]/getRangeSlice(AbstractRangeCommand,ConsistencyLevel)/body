{
  Tracing.trace("Determining replicas to query");
  long startTime=System.nanoTime();
  Keyspace keyspace=Keyspace.open(command.keyspace);
  List<Row> rows;
  try {
    int cql3RowCount=0;
    rows=new ArrayList<>();
    List<? extends AbstractBounds<RowPosition>> ranges;
    if (keyspace.getReplicationStrategy() instanceof LocalStrategy)     ranges=command.keyRange.unwrap();
 else     ranges=getRestrictedRanges(command.keyRange);
    float resultRowsPerRange=estimateResultRowsPerRange(command,keyspace);
    resultRowsPerRange-=resultRowsPerRange * CONCURRENT_SUBREQUESTS_MARGIN;
    int concurrencyFactor=resultRowsPerRange == 0.0 ? 1 : Math.max(1,Math.min(ranges.size(),(int)Math.ceil(command.limit() / resultRowsPerRange)));
    logger.debug("Estimated result rows per range: {}; requested rows: {}, ranges.size(): {}; concurrent range requests: {}",resultRowsPerRange,command.limit(),ranges.size(),concurrencyFactor);
    boolean haveSufficientRows=false;
    int i=0;
    AbstractBounds<RowPosition> nextRange=null;
    List<InetAddress> nextEndpoints=null;
    List<InetAddress> nextFilteredEndpoints=null;
    while (i < ranges.size()) {
      List<Pair<AbstractRangeCommand,ReadCallback<RangeSliceReply,Iterable<Row>>>> scanHandlers=new ArrayList<>(concurrencyFactor);
      int concurrentFetchStartingIndex=i;
      while ((i - concurrentFetchStartingIndex) < concurrencyFactor) {
        AbstractBounds<RowPosition> range=nextRange == null ? ranges.get(i) : nextRange;
        List<InetAddress> liveEndpoints=nextEndpoints == null ? getLiveSortedEndpoints(keyspace,range.right) : nextEndpoints;
        List<InetAddress> filteredEndpoints=nextFilteredEndpoints == null ? consistency_level.filterForQuery(keyspace,liveEndpoints) : nextFilteredEndpoints;
        ++i;
        while (i < ranges.size()) {
          nextRange=ranges.get(i);
          nextEndpoints=getLiveSortedEndpoints(keyspace,nextRange.right);
          nextFilteredEndpoints=consistency_level.filterForQuery(keyspace,nextEndpoints);
          if (range.right.isMinimum())           break;
          List<InetAddress> merged=intersection(liveEndpoints,nextEndpoints);
          if (!consistency_level.isSufficientLiveNodes(keyspace,merged))           break;
          List<InetAddress> filteredMerged=consistency_level.filterForQuery(keyspace,merged);
          if (!DatabaseDescriptor.getEndpointSnitch().isWorthMergingForRangeQuery(filteredMerged,filteredEndpoints,nextFilteredEndpoints))           break;
          range=range.withNewRight(nextRange.right);
          liveEndpoints=merged;
          filteredEndpoints=filteredMerged;
          ++i;
        }
        AbstractRangeCommand nodeCmd=command.forSubRange(range);
        RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(nodeCmd.keyspace,command.timestamp);
        List<InetAddress> minimalEndpoints=filteredEndpoints.subList(0,Math.min(filteredEndpoints.size(),consistency_level.blockFor(keyspace)));
        ReadCallback<RangeSliceReply,Iterable<Row>> handler=new ReadCallback<>(resolver,consistency_level,nodeCmd,minimalEndpoints);
        handler.assureSufficientLiveNodes();
        resolver.setSources(filteredEndpoints);
        if (filteredEndpoints.size() == 1 && filteredEndpoints.get(0).equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS) {
          StageManager.getStage(Stage.READ).execute(new LocalRangeSliceRunnable(nodeCmd,handler));
        }
 else {
          MessageOut<? extends AbstractRangeCommand> message=nodeCmd.createMessage();
          for (          InetAddress endpoint : filteredEndpoints) {
            Tracing.trace("Enqueuing request to {}",endpoint);
            MessagingService.instance().sendRR(message,endpoint,handler);
          }
        }
        scanHandlers.add(Pair.create(nodeCmd,handler));
      }
      List<AsyncOneResponse> repairResponses=new ArrayList<>();
      for (      Pair<AbstractRangeCommand,ReadCallback<RangeSliceReply,Iterable<Row>>> cmdPairHandler : scanHandlers) {
        AbstractRangeCommand nodeCmd=cmdPairHandler.left;
        ReadCallback<RangeSliceReply,Iterable<Row>> handler=cmdPairHandler.right;
        RangeSliceResponseResolver resolver=(RangeSliceResponseResolver)handler.resolver;
        try {
          for (          Row row : handler.get()) {
            rows.add(row);
            if (nodeCmd.countCQL3Rows())             cql3RowCount+=row.getLiveCount(command.predicate,command.timestamp);
          }
          repairResponses.addAll(resolver.repairResults);
        }
 catch (        ReadTimeoutException ex) {
          int blockFor=consistency_level.blockFor(keyspace);
          int responseCount=resolver.responses.size();
          String gotData=responseCount > 0 ? resolver.isDataPresent() ? " (including data)" : " (only digests)" : "";
          if (Tracing.isTracing()) {
            Tracing.trace("Timed out; received {} of {} responses{} for range {} of {}",new Object[]{responseCount,blockFor,gotData,i,ranges.size()});
          }
 else           if (logger.isDebugEnabled()) {
            logger.debug("Range slice timeout; received {} of {} responses{} for range {} of {}",responseCount,blockFor,gotData,i,ranges.size());
          }
          throw ex;
        }
catch (        DigestMismatchException e) {
          throw new AssertionError(e);
        }
        int count=nodeCmd.countCQL3Rows() ? cql3RowCount : rows.size();
        if (count >= nodeCmd.limit()) {
          haveSufficientRows=true;
          break;
        }
      }
      try {
        FBUtilities.waitOnFutures(repairResponses,DatabaseDescriptor.getWriteRpcTimeout());
      }
 catch (      TimeoutException ex) {
        int blockFor=consistency_level.blockFor(keyspace);
        if (Tracing.isTracing())         Tracing.trace("Timed out while read-repairing after receiving all {} data and digest responses",blockFor);
 else         logger.debug("Range slice timeout while read-repairing after receiving all {} data and digest responses",blockFor);
        throw new ReadTimeoutException(consistency_level,blockFor - 1,blockFor,true);
      }
      if (haveSufficientRows)       return trim(command,rows);
      if (i < ranges.size()) {
        float fetchedRows=command.countCQL3Rows() ? cql3RowCount : rows.size();
        float remainingRows=command.limit() - fetchedRows;
        float actualRowsPerRange;
        if (fetchedRows == 0.0) {
          actualRowsPerRange=0.0f;
          concurrencyFactor=ranges.size() - i;
        }
 else {
          actualRowsPerRange=i / fetchedRows;
          concurrencyFactor=Math.max(1,Math.min(ranges.size() - i,Math.round(remainingRows / actualRowsPerRange)));
        }
        logger.debug("Didn't get enough response rows; actual rows per range: {}; remaining rows: {}, new concurrent requests: {}",actualRowsPerRange,(int)remainingRows,concurrencyFactor);
      }
    }
  }
  finally {
    long latency=System.nanoTime() - startTime;
    rangeMetrics.addNano(latency);
    Keyspace.open(command.keyspace).getColumnFamilyStore(command.columnFamily).metric.coordinatorScanLatency.update(latency,TimeUnit.NANOSECONDS);
  }
  return trim(command,rows);
}
