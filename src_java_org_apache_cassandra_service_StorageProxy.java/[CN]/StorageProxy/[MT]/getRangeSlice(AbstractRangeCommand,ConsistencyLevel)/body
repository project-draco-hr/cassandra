{
  Tracing.trace("Determining replicas to query");
  long startTime=System.nanoTime();
  Keyspace keyspace=Keyspace.open(command.keyspace);
  List<Row> rows;
  try {
    int cql3RowCount=0;
    rows=new ArrayList<Row>();
    List<AbstractBounds<RowPosition>> ranges=getRestrictedRanges(command.keyRange);
    int i=0;
    AbstractBounds<RowPosition> nextRange=null;
    List<InetAddress> nextEndpoints=null;
    List<InetAddress> nextFilteredEndpoints=null;
    while (i < ranges.size()) {
      AbstractBounds<RowPosition> range=nextRange == null ? ranges.get(i) : nextRange;
      List<InetAddress> liveEndpoints=nextEndpoints == null ? getLiveSortedEndpoints(keyspace,range.right) : nextEndpoints;
      List<InetAddress> filteredEndpoints=nextFilteredEndpoints == null ? consistency_level.filterForQuery(keyspace,liveEndpoints) : nextFilteredEndpoints;
      ++i;
      while (i < ranges.size()) {
        nextRange=ranges.get(i);
        nextEndpoints=getLiveSortedEndpoints(keyspace,nextRange.right);
        nextFilteredEndpoints=consistency_level.filterForQuery(keyspace,nextEndpoints);
        if (range.right.isMinimum())         break;
        List<InetAddress> merged=intersection(liveEndpoints,nextEndpoints);
        if (!consistency_level.isSufficientLiveNodes(keyspace,merged))         break;
        List<InetAddress> filteredMerged=consistency_level.filterForQuery(keyspace,merged);
        if (!DatabaseDescriptor.getEndpointSnitch().isWorthMergingForRangeQuery(filteredMerged,filteredEndpoints,nextFilteredEndpoints))         break;
        range=range.withNewRight(nextRange.right);
        liveEndpoints=merged;
        filteredEndpoints=filteredMerged;
        ++i;
      }
      AbstractRangeCommand nodeCmd=command.forSubRange(range);
      RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(nodeCmd.keyspace,command.timestamp);
      ReadCallback<RangeSliceReply,Iterable<Row>> handler=new ReadCallback(resolver,consistency_level,nodeCmd,filteredEndpoints);
      handler.assureSufficientLiveNodes();
      resolver.setSources(filteredEndpoints);
      if (filteredEndpoints.size() == 1 && filteredEndpoints.get(0).equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS) {
        StageManager.getStage(Stage.READ).execute(new LocalRangeSliceRunnable(nodeCmd,handler));
      }
 else {
        MessageOut<? extends AbstractRangeCommand> message=nodeCmd.createMessage();
        for (        InetAddress endpoint : filteredEndpoints) {
          Tracing.trace("Enqueuing request to {}",endpoint);
          MessagingService.instance().sendRR(message,endpoint,handler);
        }
      }
      try {
        for (        Row row : handler.get()) {
          rows.add(row);
          if (nodeCmd.countCQL3Rows())           cql3RowCount+=row.getLiveCount(command.predicate,command.timestamp);
        }
        FBUtilities.waitOnFutures(resolver.repairResults,DatabaseDescriptor.getWriteRpcTimeout());
      }
 catch (      ReadTimeoutException ex) {
        int blockFor=consistency_level.blockFor(keyspace);
        int responseCount=resolver.responses.size();
        String gotData=responseCount > 0 ? resolver.isDataPresent() ? " (including data)" : " (only digests)" : "";
        if (Tracing.isTracing()) {
          Tracing.trace("Timed out; received {} of {} responses{} for range {} of {}",new Object[]{responseCount,blockFor,gotData,i,ranges.size()});
        }
 else         if (logger.isDebugEnabled()) {
          logger.debug("Range slice timeout; received {} of {} responses{} for range {} of {}",responseCount,blockFor,gotData,i,ranges.size());
        }
        throw ex;
      }
catch (      TimeoutException ex) {
        int blockFor=consistency_level.blockFor(keyspace);
        if (Tracing.isTracing())         Tracing.trace("Timed out while read-repairing after receiving all {} data and digest responses",blockFor);
 else         logger.debug("Range slice timeout while read-repairing after receiving all {} data and digest responses",blockFor);
        throw new ReadTimeoutException(consistency_level,blockFor,blockFor,true);
      }
catch (      DigestMismatchException e) {
        throw new AssertionError(e);
      }
      int count=nodeCmd.countCQL3Rows() ? cql3RowCount : rows.size();
      if (count >= nodeCmd.limit())       break;
    }
  }
  finally {
    long latency=System.nanoTime() - startTime;
    rangeMetrics.addNano(latency);
    Keyspace.open(command.keyspace).getColumnFamilyStore(command.columnFamily).metric.coordinatorScanLatency.update(latency,TimeUnit.NANOSECONDS);
  }
  return trim(command,rows);
}
