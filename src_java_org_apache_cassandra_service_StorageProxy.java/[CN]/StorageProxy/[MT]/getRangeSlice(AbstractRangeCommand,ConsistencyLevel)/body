{
  Tracing.trace("Computing ranges to query");
  long startTime=System.nanoTime();
  Keyspace keyspace=Keyspace.open(command.keyspace);
  List<Row> rows;
  try {
    int liveRowCount=0;
    boolean countLiveRows=command.countCQL3Rows() || command.ignoredTombstonedPartitions();
    rows=new ArrayList<>();
    List<? extends AbstractBounds<RowPosition>> ranges;
    if (keyspace.getReplicationStrategy() instanceof LocalStrategy)     ranges=command.keyRange.unwrap();
 else     ranges=getRestrictedRanges(command.keyRange);
    int rowsToBeFetched=command.limit();
    int concurrencyFactor;
    if (command.requiresScanningAllRanges()) {
      rowsToBeFetched*=ranges.size();
      concurrencyFactor=ranges.size();
      logger.debug("Requested rows: {}, ranges.size(): {}; concurrent range requests: {}",command.limit(),ranges.size(),concurrencyFactor);
      Tracing.trace("Submitting range requests on {} ranges with a concurrency of {}",ranges.size(),concurrencyFactor);
    }
 else {
      float resultRowsPerRange=estimateResultRowsPerRange(command,keyspace);
      resultRowsPerRange-=resultRowsPerRange * CONCURRENT_SUBREQUESTS_MARGIN;
      concurrencyFactor=resultRowsPerRange == 0.0 ? 1 : Math.max(1,Math.min(ranges.size(),(int)Math.ceil(command.limit() / resultRowsPerRange)));
      logger.trace("Estimated result rows per range: {}; requested rows: {}, ranges.size(): {}; concurrent range requests: {}",resultRowsPerRange,command.limit(),ranges.size(),concurrencyFactor);
      Tracing.trace("Submitting range requests on {} ranges with a concurrency of {} ({} rows per range expected)",ranges.size(),concurrencyFactor,resultRowsPerRange);
    }
    boolean haveSufficientRows=false;
    int i=0;
    AbstractBounds<RowPosition> nextRange=null;
    List<InetAddress> nextEndpoints=null;
    List<InetAddress> nextFilteredEndpoints=null;
    while (i < ranges.size()) {
      List<Pair<AbstractRangeCommand,ReadCallback<RangeSliceReply,Iterable<Row>>>> scanHandlers=new ArrayList<>(concurrencyFactor);
      int concurrentFetchStartingIndex=i;
      int concurrentRequests=0;
      while ((i - concurrentFetchStartingIndex) < concurrencyFactor) {
        AbstractBounds<RowPosition> range=nextRange == null ? ranges.get(i) : nextRange;
        List<InetAddress> liveEndpoints=nextEndpoints == null ? getLiveSortedEndpoints(keyspace,range.right) : nextEndpoints;
        List<InetAddress> filteredEndpoints=nextFilteredEndpoints == null ? consistency_level.filterForQuery(keyspace,liveEndpoints) : nextFilteredEndpoints;
        ++i;
        ++concurrentRequests;
        while (i < ranges.size()) {
          nextRange=ranges.get(i);
          nextEndpoints=getLiveSortedEndpoints(keyspace,nextRange.right);
          nextFilteredEndpoints=consistency_level.filterForQuery(keyspace,nextEndpoints);
          if (range.right.isMinimum())           break;
          List<InetAddress> merged=intersection(liveEndpoints,nextEndpoints);
          if (!consistency_level.isSufficientLiveNodes(keyspace,merged))           break;
          List<InetAddress> filteredMerged=consistency_level.filterForQuery(keyspace,merged);
          if (!DatabaseDescriptor.getEndpointSnitch().isWorthMergingForRangeQuery(filteredMerged,filteredEndpoints,nextFilteredEndpoints))           break;
          range=range.withNewRight(nextRange.right);
          liveEndpoints=merged;
          filteredEndpoints=filteredMerged;
          ++i;
        }
        AbstractRangeCommand nodeCmd=command.forSubRange(range);
        RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(nodeCmd.keyspace,command.timestamp);
        List<InetAddress> minimalEndpoints=filteredEndpoints.subList(0,Math.min(filteredEndpoints.size(),consistency_level.blockFor(keyspace)));
        ReadCallback<RangeSliceReply,Iterable<Row>> handler=new ReadCallback<>(resolver,consistency_level,nodeCmd,minimalEndpoints);
        handler.assureSufficientLiveNodes();
        resolver.setSources(filteredEndpoints);
        if (filteredEndpoints.size() == 1 && filteredEndpoints.get(0).equals(FBUtilities.getBroadcastAddress())) {
          StageManager.getStage(Stage.READ).execute(new LocalRangeSliceRunnable(nodeCmd,handler));
        }
 else {
          MessageOut<? extends AbstractRangeCommand> message=nodeCmd.createMessage();
          for (          InetAddress endpoint : filteredEndpoints) {
            Tracing.trace("Enqueuing request to {}",endpoint);
            MessagingService.instance().sendRRWithFailure(message,endpoint,handler);
          }
        }
        scanHandlers.add(Pair.create(nodeCmd,handler));
      }
      Tracing.trace("Submitted {} concurrent range requests covering {} ranges",concurrentRequests,i - concurrentFetchStartingIndex);
      List<AsyncOneResponse> repairResponses=new ArrayList<>();
      for (      Pair<AbstractRangeCommand,ReadCallback<RangeSliceReply,Iterable<Row>>> cmdPairHandler : scanHandlers) {
        ReadCallback<RangeSliceReply,Iterable<Row>> handler=cmdPairHandler.right;
        RangeSliceResponseResolver resolver=(RangeSliceResponseResolver)handler.resolver;
        try {
          for (          Row row : handler.get()) {
            rows.add(row);
            if (countLiveRows)             liveRowCount+=row.getLiveCount(command.predicate,command.timestamp);
          }
          repairResponses.addAll(resolver.repairResults);
        }
 catch (        ReadTimeoutException|ReadFailureException ex) {
          int blockFor=consistency_level.blockFor(keyspace);
          int responseCount=resolver.responses.size();
          String gotData=responseCount > 0 ? resolver.isDataPresent() ? " (including data)" : " (only digests)" : "";
          boolean isTimeout=ex instanceof ReadTimeoutException;
          if (Tracing.isTracing()) {
            Tracing.trace("{}; received {} of {} responses{} for range {} of {}",(isTimeout ? "Timed out" : "Failed"),responseCount,blockFor,gotData,i,ranges.size());
          }
 else           if (logger.isDebugEnabled()) {
            logger.debug("Range slice {}; received {} of {} responses{} for range {} of {}",(isTimeout ? "timeout" : "failure"),responseCount,blockFor,gotData,i,ranges.size());
          }
          throw ex;
        }
catch (        DigestMismatchException e) {
          throw new AssertionError(e);
        }
        int count=countLiveRows ? liveRowCount : rows.size();
        if (count >= rowsToBeFetched) {
          haveSufficientRows=true;
          break;
        }
      }
      try {
        FBUtilities.waitOnFutures(repairResponses,DatabaseDescriptor.getWriteRpcTimeout());
      }
 catch (      TimeoutException ex) {
        int blockFor=consistency_level.blockFor(keyspace);
        if (Tracing.isTracing())         Tracing.trace("Timed out while read-repairing after receiving all {} data and digest responses",blockFor);
 else         logger.debug("Range slice timeout while read-repairing after receiving all {} data and digest responses",blockFor);
        throw new ReadTimeoutException(consistency_level,blockFor - 1,blockFor,true);
      }
      if (haveSufficientRows)       return command.postReconciliationProcessing(rows);
      if (i < ranges.size()) {
        float fetchedRows=countLiveRows ? liveRowCount : rows.size();
        float remainingRows=rowsToBeFetched - fetchedRows;
        float actualRowsPerRange;
        if (fetchedRows == 0.0) {
          actualRowsPerRange=0.0f;
          concurrencyFactor=ranges.size() - i;
        }
 else {
          actualRowsPerRange=fetchedRows / i;
          concurrencyFactor=Math.max(1,Math.min(ranges.size() - i,Math.round(remainingRows / actualRowsPerRange)));
        }
        logger.trace("Didn't get enough response rows; actual rows per range: {}; remaining rows: {}, new concurrent requests: {}",actualRowsPerRange,(int)remainingRows,concurrencyFactor);
      }
    }
  }
 catch (  ReadTimeoutException e) {
    rangeMetrics.timeouts.mark();
    throw e;
  }
catch (  UnavailableException e) {
    rangeMetrics.unavailables.mark();
    throw e;
  }
catch (  ReadFailureException e) {
    rangeMetrics.failures.mark();
    throw e;
  }
 finally {
    long latency=System.nanoTime() - startTime;
    rangeMetrics.addNano(latency);
    Keyspace.open(command.keyspace).getColumnFamilyStore(command.columnFamily).metric.coordinatorScanLatency.update(latency,TimeUnit.NANOSECONDS);
  }
  return command.postReconciliationProcessing(rows);
}
