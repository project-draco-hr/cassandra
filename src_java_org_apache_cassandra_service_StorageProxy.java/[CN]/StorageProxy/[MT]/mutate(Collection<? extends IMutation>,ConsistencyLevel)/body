{
  Tracing.trace("Determining replicas for mutation");
  final String localDataCenter=DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());
  long startTime=System.nanoTime();
  List<AbstractWriteResponseHandler> responseHandlers=new ArrayList<>(mutations.size());
  try {
    for (    IMutation mutation : mutations) {
      if (mutation instanceof CounterMutation) {
        responseHandlers.add(mutateCounter((CounterMutation)mutation,localDataCenter));
      }
 else {
        WriteType wt=mutations.size() <= 1 ? WriteType.SIMPLE : WriteType.UNLOGGED_BATCH;
        responseHandlers.add(performWrite(mutation,consistency_level,localDataCenter,standardWritePerformer,null,wt));
      }
    }
    for (    AbstractWriteResponseHandler responseHandler : responseHandlers) {
      responseHandler.get();
    }
  }
 catch (  WriteTimeoutException ex) {
    if (consistency_level == ConsistencyLevel.ANY) {
      for (      IMutation mutation : mutations) {
        if (mutation instanceof CounterMutation)         continue;
        Token tk=StorageService.getPartitioner().getToken(mutation.key());
        List<InetAddress> naturalEndpoints=StorageService.instance.getNaturalEndpoints(mutation.getKeyspaceName(),tk);
        Collection<InetAddress> pendingEndpoints=StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk,mutation.getKeyspaceName());
        for (        InetAddress target : Iterables.concat(naturalEndpoints,pendingEndpoints)) {
          if (!target.equals(FBUtilities.getBroadcastAddress()) && shouldHint(target))           submitHint((Mutation)mutation,target,null);
        }
      }
      Tracing.trace("Wrote hint to satisfy CL.ANY after no replicas acknowledged the write");
    }
 else {
      writeMetrics.timeouts.mark();
      Tracing.trace("Write timeout; received {} of {} required replies",ex.received,ex.blockFor);
      throw ex;
    }
  }
catch (  UnavailableException e) {
    writeMetrics.unavailables.mark();
    Tracing.trace("Unavailable");
    throw e;
  }
catch (  OverloadedException e) {
    writeMetrics.unavailables.mark();
    Tracing.trace("Overloaded");
    throw e;
  }
 finally {
    writeMetrics.addNano(System.nanoTime() - startTime);
  }
}
