{
  long startTime=System.nanoTime();
  ArrayList<IWriteResponseHandler> responseHandlers=new ArrayList<IWriteResponseHandler>();
  CounterMutation mostRecentMutation=null;
  StorageService ss=StorageService.instance;
  try {
    for (    CounterMutation cm : mutations) {
      mostRecentMutation=cm;
      InetAddress endpoint=findSuitableEndpoint(cm.getTable(),cm.key());
      if (endpoint.equals(FBUtilities.getLocalAddress())) {
        applyCounterMutationOnLeader(cm);
      }
 else {
        String table=cm.getTable();
        AbstractReplicationStrategy rs=Table.open(table).getReplicationStrategy();
        Collection<InetAddress> writeEndpoints=getWriteEndpoints(table,cm.key());
        Multimap<InetAddress,InetAddress> hintedEndpoints=rs.getHintedEndpoints(writeEndpoints);
        rs.getWriteResponseHandler(writeEndpoints,hintedEndpoints,cm.consistency()).assureSufficientLiveNodes();
        IWriteResponseHandler responseHandler=WriteResponseHandler.create(endpoint);
        responseHandlers.add(responseHandler);
        Message message=cm.makeMutationMessage(Gossiper.instance.getVersion(endpoint));
        if (logger.isDebugEnabled())         logger.debug("forwarding counter update of key " + ByteBufferUtil.bytesToHex(cm.key()) + " to "+ endpoint);
        MessagingService.instance().sendRR(message,endpoint,responseHandler);
      }
    }
    for (    IWriteResponseHandler responseHandler : responseHandlers) {
      responseHandler.get();
    }
  }
 catch (  IOException e) {
    if (mostRecentMutation == null)     throw new RuntimeException("no mutations were seen but found an error during write anyway",e);
 else     throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentMutation.key()),e);
  }
 finally {
    counterWriteStats.addNano(System.nanoTime() - startTime);
  }
}
