{
  Map<String,Collection<InetAddress>> dcGroups=null;
  MessageOut<Mutation> message=null;
  boolean insertLocal=false;
  for (  InetAddress destination : targets) {
    if (StorageMetrics.totalHintsInProgress.getCount() > maxHintsInProgress && (getHintsInProgressFor(destination).get() > 0 && shouldHint(destination))) {
      throw new OverloadedException("Too many in flight hints: " + StorageMetrics.totalHintsInProgress.getCount());
    }
    if (FailureDetector.instance.isAlive(destination)) {
      if (canDoLocalRequest(destination)) {
        insertLocal=true;
      }
 else {
        if (message == null)         message=mutation.createMessage();
        String dc=DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);
        if (localDataCenter.equals(dc)) {
          MessagingService.instance().sendRR(message,destination,responseHandler,true);
        }
 else {
          Collection<InetAddress> messages=(dcGroups != null) ? dcGroups.get(dc) : null;
          if (messages == null) {
            messages=new ArrayList<InetAddress>(3);
            if (dcGroups == null)             dcGroups=new HashMap<String,Collection<InetAddress>>();
            dcGroups.put(dc,messages);
          }
          messages.add(destination);
        }
      }
    }
 else {
      if (!shouldHint(destination))       continue;
      submitHint(mutation,destination,responseHandler);
    }
  }
  if (insertLocal)   insertLocal(mutation,responseHandler);
  if (dcGroups != null) {
    if (message == null)     message=mutation.createMessage();
    for (    Collection<InetAddress> dcTargets : dcGroups.values())     sendMessagesToNonlocalDC(message,dcTargets,responseHandler);
  }
}
