{
  UUID ballot=UUIDGen.getTimeUUID();
  Tracing.trace("Preparing {}",ballot);
  Commit toPrepare=Commit.newPrepare(key,metadata,ballot);
  PrepareCallback summary=preparePaxos(toPrepare,liveEndpoints,requiredParticipants);
  if (!summary.promised) {
    Tracing.trace("Some replicas have already promised a higher ballot than ours; aborting");
    Uninterruptibles.sleepUninterruptibly(FBUtilities.threadLocalRandom().nextInt(100),TimeUnit.MILLISECONDS);
    return null;
  }
  Commit inProgress=summary.inProgressCommit;
  Commit mostRecent=summary.mostRecentCommit;
  if (!inProgress.update.isEmpty() && inProgress.isAfter(mostRecent)) {
    Tracing.trace("Finishing incomplete paxos round {}",inProgress);
    if (proposePaxos(inProgress,liveEndpoints,requiredParticipants)) {
      try {
        commitPaxos(inProgress,ConsistencyLevel.QUORUM);
      }
 catch (      WriteTimeoutException e) {
        return null;
      }
    }
    return null;
  }
  Iterable<InetAddress> missingMRC=summary.replicasMissingMostRecentCommit();
  if (Iterables.size(missingMRC) > 0) {
    Tracing.trace("Repairing replicas that missed the most recent commit");
    sendCommit(mostRecent,missingMRC);
    return null;
  }
  return ballot;
}
