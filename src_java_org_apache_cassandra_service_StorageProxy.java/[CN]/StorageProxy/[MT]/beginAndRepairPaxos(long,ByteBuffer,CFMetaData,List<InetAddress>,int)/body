{
  long timeout=TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getCasContentionTimeout());
  PrepareCallback summary=null;
  while (start - System.nanoTime() < timeout) {
    long ballotMillis=summary == null ? System.currentTimeMillis() : Math.max(System.currentTimeMillis(),1 + UUIDGen.unixTimestamp(summary.inProgressCommit.ballot));
    UUID ballot=UUIDGen.getTimeUUID(ballotMillis);
    Tracing.trace("Preparing {}",ballot);
    Commit toPrepare=Commit.newPrepare(key,metadata,ballot);
    summary=preparePaxos(toPrepare,liveEndpoints,requiredParticipants);
    if (!summary.promised) {
      Tracing.trace("Some replicas have already promised a higher ballot than ours; aborting");
      Uninterruptibles.sleepUninterruptibly(FBUtilities.threadLocalRandom().nextInt(100),TimeUnit.MILLISECONDS);
      continue;
    }
    Commit inProgress=summary.inProgressCommit;
    Commit mostRecent=summary.mostRecentCommit;
    if (!inProgress.update.isEmpty() && inProgress.isAfter(mostRecent)) {
      Tracing.trace("Finishing incomplete paxos round {}",inProgress);
      if (proposePaxos(inProgress,liveEndpoints,requiredParticipants))       commitPaxos(inProgress,ConsistencyLevel.QUORUM);
      continue;
    }
    Iterable<InetAddress> missingMRC=summary.replicasMissingMostRecentCommit();
    if (Iterables.size(missingMRC) > 0) {
      Tracing.trace("Repairing replicas that missed the most recent commit");
      sendCommit(mostRecent,missingMRC);
      continue;
    }
    return ballot;
  }
  throw new WriteTimeoutException(WriteType.CAS,ConsistencyLevel.SERIAL,-1,-1);
}
