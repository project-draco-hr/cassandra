{
  Map<String,Multimap<Message,InetAddress>> dcMessages=new HashMap<String,Multimap<Message,InetAddress>>(targets.size());
  MessageProducer producer=new CachingMessageProducer(rm);
  for (  InetAddress destination : targets) {
    if (totalHintsInProgress.get() > maxHintsInProgress && (hintsInProgress.get(destination).get() > 0 && shouldHint(destination))) {
      throw new TimeoutException();
    }
    if (FailureDetector.instance.isAlive(destination)) {
      if (destination.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS) {
        insertLocal(rm,responseHandler);
      }
 else {
        if (logger.isDebugEnabled())         logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to "+ destination);
        String dc=DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);
        Multimap<Message,InetAddress> messages=dcMessages.get(dc);
        if (messages == null) {
          messages=HashMultimap.create();
          dcMessages.put(dc,messages);
        }
        messages.put(producer.getMessage(Gossiper.instance.getVersion(destination)),destination);
      }
    }
 else {
      if (!shouldHint(destination))       continue;
      Future<Void> hintfuture=scheduleLocalHint(rm,destination,responseHandler,consistency_level);
      responseHandler.addFutureForHint(new CreationTimeAwareFuture<Void>(hintfuture));
    }
  }
  sendMessages(localDataCenter,dcMessages,responseHandler);
}
