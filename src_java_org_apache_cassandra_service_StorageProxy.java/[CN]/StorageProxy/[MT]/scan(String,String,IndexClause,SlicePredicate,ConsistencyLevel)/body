{
  IPartitioner p=StorageService.getPartitioner();
  Token leftToken=index_clause.start_key == null ? p.getMinimumToken() : p.getToken(index_clause.start_key);
  List<AbstractBounds> ranges=getRestrictedRanges(new Bounds(leftToken,p.getMinimumToken()));
  logger.debug("scan ranges are " + StringUtils.join(ranges,","));
  List<Row> rows=new ArrayList<Row>(index_clause.count);
  for (  AbstractBounds range : ranges) {
    List<InetAddress> liveEndpoints=StorageService.instance.getLiveNaturalEndpoints(keyspace,range.right);
    DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(),liveEndpoints);
    RangeSliceResponseResolver resolver=new RangeSliceResponseResolver(keyspace,liveEndpoints);
    IReadCommand iCommand=new IReadCommand(){
      public String getKeyspace(){
        return keyspace;
      }
    }
;
    ReadCallback<Iterable<Row>> handler=getReadCallback(resolver,iCommand,consistency_level,liveEndpoints);
    handler.assureSufficientLiveNodes();
    IndexScanCommand command=new IndexScanCommand(keyspace,column_family,index_clause,column_predicate,range);
    MessageProducer producer=new CachingMessageProducer(command);
    for (    InetAddress endpoint : liveEndpoints) {
      MessagingService.instance().sendRR(producer,endpoint,handler);
      if (logger.isDebugEnabled())       logger.debug("reading " + command + " from "+ endpoint);
    }
    try {
      for (      Row row : handler.get()) {
        rows.add(row);
        logger.debug("read {}",row);
      }
    }
 catch (    DigestMismatchException e) {
      throw new RuntimeException(e);
    }
    if (rows.size() >= index_clause.count)     return rows.subList(0,index_clause.count);
  }
  return rows;
}
