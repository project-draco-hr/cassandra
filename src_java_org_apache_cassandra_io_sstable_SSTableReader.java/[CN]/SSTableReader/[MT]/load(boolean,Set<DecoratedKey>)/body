{
  boolean cacheLoading=keyCache != null && !keysToLoadInCache.isEmpty();
  SegmentedFile.Builder ibuilder=SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
  SegmentedFile.Builder dbuilder=SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());
  BufferedRandomAccessFile input=new BufferedRandomAccessFile(descriptor.filenameFor(Component.PRIMARY_INDEX),"r");
  try {
    if (keyCache != null && keyCache.getCapacity() - keyCache.getSize() < keysToLoadInCache.size())     keyCache.updateCapacity(keyCache.getSize() + keysToLoadInCache.size());
    long indexSize=input.length();
    long estimatedKeys=SSTable.estimateRowsFromIndex(input);
    indexSummary=new IndexSummary(estimatedKeys);
    if (recreatebloom)     bf=BloomFilter.getFilter(estimatedKeys,15);
    while (true) {
      long indexPosition=input.getFilePointer();
      if (indexPosition == indexSize)       break;
      boolean shouldAddEntry=indexSummary.shouldAddEntry();
      byte[] key=(shouldAddEntry || cacheLoading || recreatebloom) ? FBUtilities.readShortByteArray(input) : FBUtilities.skipShortByteArray(input);
      long dataPosition=input.readLong();
      if (key != null) {
        DecoratedKey decoratedKey=decodeKey(partitioner,descriptor,key);
        if (recreatebloom)         bf.add(decoratedKey.key);
        if (shouldAddEntry)         indexSummary.addEntry(decoratedKey,indexPosition);
        if (cacheLoading && keysToLoadInCache.contains(decoratedKey))         keyCache.put(new Pair(descriptor,decoratedKey),dataPosition);
      }
      indexSummary.incrementRowid();
      ibuilder.addPotentialBoundary(indexPosition);
      dbuilder.addPotentialBoundary(dataPosition);
    }
    indexSummary.complete();
  }
  finally {
    input.close();
  }
  ifile=ibuilder.complete(descriptor.filenameFor(Component.PRIMARY_INDEX));
  dfile=dbuilder.complete(descriptor.filenameFor(Component.DATA));
}
