{
  boolean cacheLoading=keyCache != null && !keysToLoadInCache.isEmpty();
  SegmentedFile.Builder ibuilder=SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
  SegmentedFile.Builder dbuilder=SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());
  BufferedRandomAccessFile input=new BufferedRandomAccessFile(new File(descriptor.filenameFor(Component.PRIMARY_INDEX)),"r",BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE,true);
  try {
    if (keyCache != null && keyCache.getCapacity() - keyCache.size() < keysToLoadInCache.size())     keyCache.updateCapacity(keyCache.size() + keysToLoadInCache.size());
    long indexSize=input.length();
    long estimatedKeys=SSTable.estimateRowsFromIndex(input);
    indexSummary=new IndexSummary(estimatedKeys);
    if (recreatebloom)     bf=LegacyBloomFilter.getFilter(estimatedKeys,15);
    while (true) {
      long indexPosition=input.getFilePointer();
      if (indexPosition == indexSize)       break;
      boolean shouldAddEntry=indexSummary.shouldAddEntry();
      ByteBuffer key=(shouldAddEntry || cacheLoading || recreatebloom) ? ByteBufferUtil.readWithShortLength(input) : ByteBufferUtil.skipShortLength(input);
      long dataPosition=input.readLong();
      if (key != null) {
        DecoratedKey decoratedKey=decodeKey(partitioner,descriptor,key);
        if (recreatebloom)         bf.add(decoratedKey.key);
        if (shouldAddEntry)         indexSummary.addEntry(decoratedKey,indexPosition);
        if (cacheLoading && keysToLoadInCache.contains(decoratedKey))         cacheKey(decoratedKey,dataPosition);
      }
      indexSummary.incrementRowid();
      ibuilder.addPotentialBoundary(indexPosition);
      dbuilder.addPotentialBoundary(dataPosition);
    }
    indexSummary.complete();
  }
  finally {
    FileUtils.closeQuietly(input);
  }
  ifile=ibuilder.complete(descriptor.filenameFor(Component.PRIMARY_INDEX));
  dfile=dbuilder.complete(descriptor.filenameFor(Component.DATA));
}
