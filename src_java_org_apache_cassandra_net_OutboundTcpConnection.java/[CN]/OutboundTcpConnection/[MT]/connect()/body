{
  if (logger.isDebugEnabled())   logger.debug("attempting to connect to {}",poolReference.endPoint());
  long start=System.nanoTime();
  long timeout=TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getRpcTimeout());
  while (System.nanoTime() - start < timeout) {
    targetVersion=MessagingService.instance().getVersion(poolReference.endPoint());
    try {
      socket=poolReference.newSocket();
      socket.setKeepAlive(true);
      if (isLocalDC(poolReference.endPoint())) {
        socket.setTcpNoDelay(true);
      }
 else {
        socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());
      }
      if (DatabaseDescriptor.getInternodeSendBufferSize() != null) {
        try {
          socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize());
        }
 catch (        SocketException se) {
          logger.warn("Failed to set send buffer size on internode socket.",se);
        }
      }
      out=new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(),4096));
      out.writeInt(MessagingService.PROTOCOL_MAGIC);
      writeHeader(out,targetVersion,shouldCompressConnection());
      out.flush();
      DataInputStream in=new DataInputStream(socket.getInputStream());
      int maxTargetVersion=handshakeVersion(in);
      if (maxTargetVersion == NO_VERSION) {
        logger.debug("Target max version is {}; no version information yet, will retry",maxTargetVersion);
        disconnect();
        continue;
      }
      if (targetVersion > maxTargetVersion) {
        logger.debug("Target max version is {}; will reconnect with that version",maxTargetVersion);
        MessagingService.instance().setVersion(poolReference.endPoint(),maxTargetVersion);
        disconnect();
        return false;
      }
      if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version) {
        logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",maxTargetVersion,targetVersion);
        MessagingService.instance().setVersion(poolReference.endPoint(),Math.min(MessagingService.current_version,maxTargetVersion));
        softCloseSocket();
      }
      out.writeInt(MessagingService.current_version);
      CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(),out);
      if (shouldCompressConnection()) {
        out.flush();
        logger.trace("Upgrading OutputStream to be compressed");
        if (targetVersion < MessagingService.VERSION_21) {
          out=new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));
        }
 else {
          LZ4Compressor compressor=LZ4Factory.fastestInstance().fastCompressor();
          Checksum checksum=XXHashFactory.fastestInstance().newStreamingHash32(LZ4_HASH_SEED).asChecksum();
          out=new DataOutputStream(new LZ4BlockOutputStream(new BufferedOutputStream(socket.getOutputStream()),1 << 14,compressor,checksum,true));
        }
      }
      return true;
    }
 catch (    IOException e) {
      socket=null;
      if (logger.isTraceEnabled())       logger.trace("unable to connect to " + poolReference.endPoint(),e);
      Uninterruptibles.sleepUninterruptibly(OPEN_RETRY_DELAY,TimeUnit.MILLISECONDS);
    }
  }
  return false;
}
