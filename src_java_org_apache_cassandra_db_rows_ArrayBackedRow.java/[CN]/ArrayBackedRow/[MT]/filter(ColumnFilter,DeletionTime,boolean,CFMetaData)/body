{
  Map<ByteBuffer,CFMetaData.DroppedColumn> droppedColumns=metadata.getDroppedColumns();
  if (filter.includesAllColumns() && (activeDeletion.isLive() || deletion.supersedes(activeDeletion)) && droppedColumns.isEmpty())   return this;
  boolean mayHaveShadowed=activeDeletion.supersedes(deletion);
  LivenessInfo newInfo=primaryKeyLivenessInfo;
  DeletionTime newDeletion=deletion;
  if (mayHaveShadowed) {
    if (activeDeletion.deletes(newInfo.timestamp()))     newInfo=LivenessInfo.EMPTY;
    newDeletion=setActiveDeletionToRow ? activeDeletion : DeletionTime.LIVE;
  }
  ColumnData[] newData=new ColumnData[size];
  int newMinDeletionTime=Math.min(minDeletionTime(newInfo),minDeletionTime(newDeletion));
  Columns columns=filter.fetchedColumns().columns(isStatic());
  Predicate<ColumnDefinition> inclusionTester=columns.inOrderInclusionTester();
  int newSize=0;
  for (int i=0; i < size; i++) {
    ColumnData cd=data[i];
    ColumnDefinition column=cd.column();
    if (!inclusionTester.test(column))     continue;
    CFMetaData.DroppedColumn dropped=droppedColumns.get(column.name.bytes);
    if (column.isSimple()) {
      Cell cell=(Cell)cd;
      if ((dropped == null || cell.timestamp() > dropped.droppedTime) && !(mayHaveShadowed && activeDeletion.deletes(cell))) {
        newData[newSize++]=cell;
        newMinDeletionTime=Math.min(newMinDeletionTime,minDeletionTime(cell));
      }
    }
 else {
      ColumnData newCd=((ComplexColumnData)cd).filter(filter,mayHaveShadowed ? activeDeletion : DeletionTime.LIVE,dropped);
      if (newCd != null) {
        newData[newSize++]=newCd;
        newMinDeletionTime=Math.min(newMinDeletionTime,minDeletionTime(newCd));
      }
    }
  }
  if (newSize == 0 && newInfo.isEmpty() && newDeletion.isLive())   return null;
  return new ArrayBackedRow(clustering,columns,newInfo,newDeletion,newSize,newData,newMinDeletionTime);
}
