{
  try {
    String type=cf.contains(".") ? "IndexColumnFamily" : "ColumnFamily";
    ObjectName oName=new ObjectName(String.format("org.apache.cassandra.metrics:type=%s,keyspace=%s,scope=%s,name=%s",type,ks,cf,metricName));
switch (metricName) {
case "BloomFilterDiskSpaceUsed":
case "BloomFilterFalsePositives":
case "BloomFilterFalseRatio":
case "BloomFilterOffHeapMemoryUsed":
case "IndexSummaryOffHeapMemoryUsed":
case "CompressionMetadataOffHeapMemoryUsed":
case "CompressionRatio":
case "EstimatedColumnCountHistogram":
case "EstimatedRowSizeHistogram":
case "KeyCacheHitRate":
case "LiveSSTableCount":
case "MaxRowSize":
case "MeanRowSize":
case "MemtableColumnsCount":
case "MemtableLiveDataSize":
case "MemtableOffHeapSize":
case "MinRowSize":
case "RecentBloomFilterFalsePositives":
case "RecentBloomFilterFalseRatio":
case "SnapshotsSize":
      return JMX.newMBeanProxy(mbeanServerConn,oName,JmxReporter.GaugeMBean.class).getValue();
case "LiveDiskSpaceUsed":
case "MemtableSwitchCount":
case "SpeculativeRetries":
case "TotalDiskSpaceUsed":
case "WriteTotalLatency":
case "ReadTotalLatency":
case "PendingFlushes":
    return JMX.newMBeanProxy(mbeanServerConn,oName,JmxReporter.CounterMBean.class).getCount();
case "ReadLatency":
case "CoordinatorReadLatency":
case "CoordinatorScanLatency":
case "WriteLatency":
  return JMX.newMBeanProxy(mbeanServerConn,oName,JmxReporter.TimerMBean.class);
case "LiveScannedHistogram":
case "SSTablesPerReadHistogram":
case "TombstoneScannedHistogram":
return JMX.newMBeanProxy(mbeanServerConn,oName,JmxReporter.HistogramMBean.class);
default :
throw new RuntimeException("Unknown column family metric.");
}
}
 catch (MalformedObjectNameException e) {
throw new RuntimeException(e);
}
}
