{
  Table table=Table.open(TABLE1);
  ColumnFamilyStore store=table.getColumnFamilyStore("Standard1");
  final int ROWS_PER_SSTABLE=10;
  final int SSTABLES=(DatabaseDescriptor.getIndexInterval() * 3 / ROWS_PER_SSTABLE);
  store.disableAutoCompaction();
  Set<DecoratedKey> inserted=new HashSet<DecoratedKey>();
  for (int j=0; j < SSTABLES; j++) {
    for (int i=0; i < ROWS_PER_SSTABLE; i++) {
      DecoratedKey key=Util.dk(String.valueOf(i % 2));
      RowMutation rm=new RowMutation(TABLE1,key.key);
      rm.add(new QueryPath("Standard1",null,ByteBufferUtil.bytes(String.valueOf(i / 2))),ByteBufferUtil.EMPTY_BYTE_BUFFER,j * ROWS_PER_SSTABLE + i);
      rm.apply();
      inserted.add(key);
    }
    store.forceBlockingFlush();
    assertEquals(inserted.toString(),inserted.size(),Util.getRangeSlice(store).size());
  }
  store.setMinimumCompactionThreshold(2);
  store.setMaximumCompactionThreshold(4);
  while (true) {
    ArrayList<Future<Integer>> compactions=new ArrayList<Future<Integer>>();
    for (int i=0; i < 10; i++)     compactions.add(CompactionManager.instance.submitMinorIfNeeded(store));
    boolean progress=false;
    for (    Future<Integer> compaction : compactions)     if (compaction.get() > 0)     progress=true;
    if (!progress)     break;
  }
  if (store.getSSTables().size() > 1) {
    CompactionManager.instance.performMajor(store);
  }
  assertEquals(inserted.size(),Util.getRangeSlice(store).size());
}
