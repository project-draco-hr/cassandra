{
  Table table=Table.open(TABLE1);
  final ColumnFamilyStore cfs=table.getColumnFamilyStore("Standard1");
  final int ROWS_PER_SSTABLE=10;
  final int SSTABLES=cfs.metadata.getIndexInterval() * 2 / ROWS_PER_SSTABLE;
  cfs.setCompactionStrategyClass(compactionStrategy);
  cfs.disableAutoCompaction();
  long maxTimestampExpected=Long.MIN_VALUE;
  Set<DecoratedKey> inserted=new HashSet<DecoratedKey>();
  for (int j=0; j < SSTABLES; j++) {
    for (int i=0; i < ROWS_PER_SSTABLE; i++) {
      DecoratedKey key=Util.dk(String.valueOf(i % 2));
      RowMutation rm=new RowMutation(TABLE1,key.key);
      long timestamp=j * ROWS_PER_SSTABLE + i;
      rm.add("Standard1",ByteBufferUtil.bytes(String.valueOf(i / 2)),ByteBufferUtil.EMPTY_BYTE_BUFFER,timestamp);
      maxTimestampExpected=Math.max(timestamp,maxTimestampExpected);
      rm.apply();
      inserted.add(key);
    }
    cfs.forceBlockingFlush();
    assertMaxTimestamp(cfs,maxTimestampExpected);
    assertEquals(inserted.toString(),inserted.size(),Util.getRangeSlice(cfs).size());
  }
  Collection<SSTableReader> sstables=cfs.getSSTables();
  int currentSSTable=0;
  int sstablesToCorrupt=8;
  for (  SSTableReader sstable : sstables) {
    if (currentSSTable + 1 > sstablesToCorrupt)     break;
    RandomAccessFile raf=null;
    try {
      raf=new RandomAccessFile(sstable.getFilename(),"rw");
      assertNotNull(raf);
      raf.write(0xFFFFFF);
    }
  finally {
      FileUtils.closeQuietly(raf);
    }
    currentSSTable++;
  }
  int failures=0;
  System.err.close();
  try {
    for (int i=0; i < sstables.size(); i++) {
      try {
        cfs.forceMajorCompaction();
      }
 catch (      Exception e) {
        failures++;
        continue;
      }
      assertEquals(sstablesToCorrupt + 1,cfs.getSSTables().size());
      break;
    }
  }
  finally {
    System.setErr(new PrintStream(new ByteArrayOutputStream()));
  }
  cfs.truncateBlocking();
  assertEquals(failures,sstablesToCorrupt);
}
