{
  int importedKeys=0;
  long start=System.nanoTime();
  JsonParser parser=getParser(jsonFile);
  Object[] data=parser.readValueAs(new TypeReference<Object[]>(){
  }
);
  keyCountToImport=(keyCountToImport == null) ? data.length : keyCountToImport;
  SSTableWriter writer=new SSTableWriter(ssTablePath,keyCountToImport,ActiveRepairService.UNREPAIRED_SSTABLE);
  System.out.printf("Importing %s keys...%n",keyCountToImport);
  SortedMap<DecoratedKey,Map<?,?>> decoratedKeys=new TreeMap<DecoratedKey,Map<?,?>>();
  for (  Object row : data) {
    Map<?,?> rowAsMap=(Map<?,?>)row;
    decoratedKeys.put(partitioner.decorateKey(hexToBytes((String)rowAsMap.get("key"))),rowAsMap);
  }
  for (  Map.Entry<DecoratedKey,Map<?,?>> row : decoratedKeys.entrySet()) {
    if (row.getValue().containsKey("metadata")) {
      parseMeta((Map<?,?>)row.getValue().get("metadata"),columnFamily,null);
    }
    Object columns=row.getValue().get("columns");
    if (columnFamily.getType() == ColumnFamilyType.Super && oldSCFormat)     addToSuperCF((Map<?,?>)columns,columnFamily);
 else     addToStandardCF((List<?>)columns,columnFamily);
    writer.append(row.getKey(),columnFamily);
    columnFamily.clear();
    importedKeys++;
    long current=System.nanoTime();
    if (TimeUnit.NANOSECONDS.toSeconds(current - start) >= 5) {
      System.out.printf("Currently imported %d keys.%n",importedKeys);
      start=current;
    }
    if (keyCountToImport == importedKeys)     break;
  }
  writer.closeAndOpenReader();
  return importedKeys;
}
