{
  TOKEN_SCALE=new BigInteger("16");
  Range full=new Range(tok(0),tok(0));
  Iterator<TreeRange> ranges;
  MerkleTree mt2=new MerkleTree(partitioner,RECOMMENDED_DEPTH,Integer.MAX_VALUE);
  mt.split(tok(8));
  mt.split(tok(4));
  mt.split(tok(12));
  mt.split(tok(6));
  mt.split(tok(10));
  ranges=mt.invalids(full);
  ranges.next().addAll(new HIterator(2,4));
  ranges.next().addAll(new HIterator(6));
  ranges.next().addAll(new HIterator(8));
  ranges.next().addAll(new HIterator(new int[0]));
  ranges.next().addAll(new HIterator(12));
  ranges.next().addAll(new HIterator(14,0));
  mt2.split(tok(8));
  mt2.split(tok(4));
  mt2.split(tok(12));
  mt2.split(tok(2));
  mt2.split(tok(10));
  mt2.split(tok(9));
  mt2.split(tok(11));
  ranges=mt2.invalids(full);
  ranges.next().addAll(new HIterator(2));
  ranges.next().addAll(new HIterator(4));
  ranges.next().addAll(new HIterator(6,8));
  ranges.next().addAll(new HIterator(new int[0]));
  ranges.next().addAll(new HIterator(new int[0]));
  ranges.next().addAll(new HIterator(new int[0]));
  ranges.next().addAll(new HIterator(12));
  ranges.next().addAll(new HIterator(14,0));
  byte[] mthash=mt.hash(full);
  byte[] mt2hash=mt2.hash(full);
  assertHashEquals("Tree hashes did not match: " + mt + " && "+ mt2,mthash,mt2hash);
}
