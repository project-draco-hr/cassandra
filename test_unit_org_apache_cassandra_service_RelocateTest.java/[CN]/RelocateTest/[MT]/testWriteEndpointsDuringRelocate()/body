{
  Map<Token<?>,InetAddress> tokenMap=createInitialRing(5);
  Map<Token,List<InetAddress>> expectedEndpoints=new HashMap<Token,List<InetAddress>>();
  for (  Token<?> token : tokenMap.keySet()) {
    BigIntegerToken keyToken=new BigIntegerToken(((BigInteger)token.token).add(new BigInteger("5")));
    List<InetAddress> endpoints=new ArrayList<InetAddress>();
    Iterator<Token> tokenIter=TokenMetadata.ringIterator(tmd.sortedTokens(),keyToken,false);
    while (tokenIter.hasNext()) {
      InetAddress ep=tmd.getEndpoint(tokenIter.next());
      if (!endpoints.contains(ep))       endpoints.add(ep);
    }
    expectedEndpoints.put(keyToken,endpoints);
  }
  Token relocateToken=new BigIntegerToken(String.valueOf(TOKEN_STEP));
  ss.onChange(InetAddress.getByName("127.0.0.2"),ApplicationState.STATUS,vvFactory.relocating(Collections.singleton(relocateToken)));
  assertTrue(tmd.isRelocating(relocateToken));
  AbstractReplicationStrategy strategy;
  for (  String table : Schema.instance.getNonSystemTables()) {
    strategy=getStrategy(table,tmd);
    for (    Token token : tokenMap.keySet()) {
      BigIntegerToken keyToken=new BigIntegerToken(((BigInteger)token.token).add(new BigInteger("5")));
      HashSet<InetAddress> actual=new HashSet<InetAddress>(tmd.getWriteEndpoints(keyToken,table,strategy.calculateNaturalEndpoints(keyToken,tmd.cloneOnlyTokenMap())));
      HashSet<InetAddress> expected=new HashSet<InetAddress>();
      for (int i=0; i < actual.size(); i++)       expected.add(expectedEndpoints.get(keyToken).get(i));
      assertEquals("mismatched endpoint sets",expected,actual);
    }
  }
}
