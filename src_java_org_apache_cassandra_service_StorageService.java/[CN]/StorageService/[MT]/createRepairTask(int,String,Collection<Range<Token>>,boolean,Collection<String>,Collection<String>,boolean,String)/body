{
  if (dataCenters != null && !dataCenters.contains(DatabaseDescriptor.getLocalDataCenter())) {
    throw new IllegalArgumentException("the local data center must be part of the repair");
  }
  return new FutureTask<>(new WrappedRunnable(){
    protected void runMayThrow() throws Exception {
      String message=String.format("Starting repair command #%d, repairing %d ranges for keyspace %s (seq=%b, full=%b)",cmd,ranges.size(),keyspace,isSequential,fullRepair);
      logger.info(message);
      sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.STARTED.ordinal()});
      if (isSequential && !fullRepair) {
        message="It is not possible to mix sequential repair and incremental repairs.";
        logger.error(message);
        sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.FINISHED.ordinal()});
        return;
      }
      Set<InetAddress> allNeighbors=new HashSet<>();
      Map<Range,Set<InetAddress>> rangeToNeighbors=new HashMap<>();
      for (      Range<Token> range : ranges) {
        try {
          Set<InetAddress> neighbors=ActiveRepairService.getNeighbors(keyspace,range,dataCenters,hosts);
          rangeToNeighbors.put(range,neighbors);
          allNeighbors.addAll(neighbors);
        }
 catch (        IllegalArgumentException e) {
          logger.error("Repair failed:",e);
          sendNotification("repair",e.getMessage(),new int[]{cmd,ActiveRepairService.Status.FINISHED.ordinal()});
          return;
        }
      }
      List<ColumnFamilyStore> columnFamilyStores=new ArrayList<>();
      try {
        Iterables.addAll(columnFamilyStores,getValidColumnFamilies(false,false,keyspace,columnFamilies));
      }
 catch (      IllegalArgumentException e) {
        sendNotification("repair",e.getMessage(),new int[]{cmd,ActiveRepairService.Status.FINISHED.ordinal()});
        return;
      }
      UUID parentSession=null;
      if (!fullRepair) {
        try {
          parentSession=ActiveRepairService.instance.prepareForRepair(allNeighbors,ranges,columnFamilyStores);
        }
 catch (        Throwable t) {
          sendNotification("repair",String.format("Repair failed with error %s",t.getMessage()),new int[]{cmd,ActiveRepairService.Status.FINISHED.ordinal()});
          return;
        }
      }
      List<RepairFuture> futures=new ArrayList<>(ranges.size());
      String[] cfnames=new String[columnFamilyStores.size()];
      for (int i=0; i < columnFamilyStores.size(); i++) {
        cfnames[i]=columnFamilyStores.get(i).name;
      }
      for (      Range<Token> range : ranges) {
        RepairFuture future=ActiveRepairService.instance.submitRepairSession(parentSession,range,keyspace,isSequential,rangeToNeighbors.get(range),cfnames);
        if (future == null)         continue;
        futures.add(future);
        try {
          future.session.differencingDone.await();
        }
 catch (        InterruptedException e) {
          message="Interrupted while waiting for the differencing of repair session " + future.session + " to be done. Repair may be imprecise.";
          logger.error(message,e);
          sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.SESSION_FAILED.ordinal()});
        }
      }
      for (      RepairFuture future : futures) {
        try {
          future.get();
          message=String.format("Repair session %s for range %s finished",future.session.getId(),future.session.getRange().toString());
          logger.info(message);
          sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.SESSION_SUCCESS.ordinal()});
        }
 catch (        ExecutionException e) {
          message=String.format("Repair session %s for range %s failed with error %s",future.session.getId(),future.session.getRange().toString(),e.getCause().getMessage());
          logger.error(message,e);
          sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.SESSION_FAILED.ordinal()});
        }
catch (        Exception e) {
          message=String.format("Repair session %s for range %s failed with error %s",future.session.getId(),future.session.getRange().toString(),e.getMessage());
          logger.error(message,e);
          sendNotification("repair",message,new int[]{cmd,ActiveRepairService.Status.SESSION_FAILED.ordinal()});
        }
      }
      if (!fullRepair)       ActiveRepairService.instance.finishParentSession(parentSession,allNeighbors);
      sendNotification("repair",String.format("Repair command #%d finished",cmd),new int[]{cmd,ActiveRepairService.Status.FINISHED.ordinal()});
    }
  }
,null);
}
