{
  InetAddress myAddress=FBUtilities.getBroadcastAddress();
  Token localToken=tokenMetadata_.getToken(myAddress);
  Token token=partitioner.getTokenFactory().fromString(tokenString);
  InetAddress endpoint=tokenMetadata_.getEndpoint(token);
  if (endpoint == null)   throw new UnsupportedOperationException("Token not found.");
  if (endpoint.equals(myAddress))   throw new UnsupportedOperationException("Cannot remove node's own token");
  if (Gossiper.instance.getLiveMembers().contains(endpoint))   throw new UnsupportedOperationException("Node " + endpoint + " is alive and owns this token. Use decommission command to remove it from the ring");
  if (tokenMetadata_.isLeaving(endpoint))   logger_.warn("Node " + endpoint + " is already being removed, continuing removal anyway");
  if (!replicatingNodes.isEmpty())   throw new UnsupportedOperationException("This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed.");
  for (  String table : Schema.instance.getNonSystemTables()) {
    if (Table.open(table).getReplicationStrategy().getReplicationFactor() == 1)     continue;
    Multimap<Range<Token>,InetAddress> changedRanges=getChangedRangesForLeaving(table,endpoint);
    IFailureDetector failureDetector=FailureDetector.instance;
    for (    InetAddress ep : changedRanges.values()) {
      if (failureDetector.isAlive(ep))       replicatingNodes.add(ep);
 else       logger_.warn("Endpoint " + ep + " is down and will not receive data for re-replication of "+ endpoint);
    }
  }
  removingNode=endpoint;
  tokenMetadata_.addLeavingEndpoint(endpoint);
  calculatePendingRanges();
  Gossiper.instance.advertiseRemoving(endpoint,token,localToken);
  restoreReplicaCount(endpoint,myAddress);
  while (!replicatingNodes.isEmpty()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new AssertionError(e);
    }
  }
  excise(token,endpoint);
  Gossiper.instance.advertiseTokenRemoved(endpoint,token);
  replicatingNodes.clear();
  removingNode=null;
}
