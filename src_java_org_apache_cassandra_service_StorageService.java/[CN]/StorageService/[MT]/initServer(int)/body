{
  logger.info("Cassandra version: " + FBUtilities.getReleaseVersionString());
  logger.info("Thrift API version: " + cassandraConstants.VERSION);
  logger.info("CQL supported versions: " + StringUtils.join(ClientState.getCQLSupportedVersion(),",") + " (default: "+ ClientState.DEFAULT_CQL_VERSION+ ")");
  if (initialized) {
    if (isClientMode)     throw new UnsupportedOperationException("StorageService does not support switching modes.");
    return;
  }
  initialized=true;
  isClientMode=false;
  try {
    Class.forName("org.apache.cassandra.service.StorageProxy");
  }
 catch (  ClassNotFoundException e) {
    throw new AssertionError(e);
  }
  if (Boolean.parseBoolean(System.getProperty("cassandra.load_ring_state","true"))) {
    logger.info("Loading persisted ring state");
    Multimap<InetAddress,Token> loadedTokens=SystemKeyspace.loadTokens();
    Map<InetAddress,UUID> loadedHostIds=SystemKeyspace.loadHostIds();
    for (    InetAddress ep : loadedTokens.keySet()) {
      if (ep.equals(FBUtilities.getBroadcastAddress())) {
        SystemKeyspace.removeEndpoint(ep);
      }
 else {
        tokenMetadata.updateNormalTokens(loadedTokens.get(ep),ep);
        if (loadedHostIds.containsKey(ep))         tokenMetadata.updateHostId(loadedHostIds.get(ep),ep);
        Gossiper.instance.addSavedEndpoint(ep);
      }
    }
  }
  if (Boolean.parseBoolean(System.getProperty("cassandra.renew_counter_id","false"))) {
    logger.info("Renewing local node id (as requested)");
    CounterId.renewLocalId();
  }
  Thread drainOnShutdown=new Thread(new WrappedRunnable(){
    @Override public void runMayThrow() throws ExecutionException, InterruptedException, IOException {
      ExecutorService mutationStage=StageManager.getStage(Stage.MUTATION);
      if (mutationStage.isShutdown())       return;
      if (daemon != null)       shutdownClientServers();
      optionalTasks.shutdown();
      Gossiper.instance.stop();
      MessagingService.instance().shutdown();
      mutationStage.shutdown();
      mutationStage.awaitTermination(3600,TimeUnit.SECONDS);
      StorageProxy.instance.verifyNoHintsInProgress();
      List<Future<?>> flushes=new ArrayList<Future<?>>();
      for (      Keyspace keyspace : Keyspace.all()) {
        KSMetaData ksm=Schema.instance.getKSMetaData(keyspace.getName());
        if (!ksm.durableWrites) {
          for (          ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())           flushes.add(cfs.forceFlush());
        }
      }
      try {
        FBUtilities.waitOnFutures(flushes);
      }
 catch (      Throwable e) {
        logger.warn("Caught exception while waiting for memtable flushes during shutdown hook",e);
      }
      CommitLog.instance.shutdownBlocking();
      tasks.shutdown();
      if (!tasks.awaitTermination(1,TimeUnit.MINUTES))       logger.warn("Miscellaneous task executor still busy after one minute; proceeding with shutdown");
    }
  }
,"StorageServiceShutdownHook");
  Runtime.getRuntime().addShutdownHook(drainOnShutdown);
  prepareToJoin();
  if (Boolean.parseBoolean(System.getProperty("cassandra.join_ring","true"))) {
    joinTokenRing(delay);
  }
 else {
    Collection<Token> tokens=SystemKeyspace.getSavedTokens();
    if (!tokens.isEmpty()) {
      tokenMetadata.updateNormalTokens(tokens,FBUtilities.getBroadcastAddress());
      Gossiper.instance.addLocalApplicationState(ApplicationState.TOKENS,valueFactory.tokens(tokens));
      Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS,valueFactory.hibernate(true));
    }
    logger.info("Not joining ring as requested. Use JMX (StorageService->joinRing()) to initiate ring joining");
  }
}
