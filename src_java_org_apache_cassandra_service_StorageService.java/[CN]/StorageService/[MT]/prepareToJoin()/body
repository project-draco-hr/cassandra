{
  if (!joined) {
    Map<ApplicationState,VersionedValue> appStates=new EnumMap<>(ApplicationState.class);
    if (SystemKeyspace.wasDecommissioned()) {
      if (Boolean.getBoolean("cassandra.override_decommission")) {
        logger.warn("This node was decommissioned, but overriding by operator request.");
        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);
      }
 else       throw new ConfigurationException("This node was decommissioned and will not rejoin the ring unless cassandra.override_decommission=true has been set, or all existing data is removed and the node is bootstrapped again");
    }
    if (DatabaseDescriptor.getReplaceTokens().size() > 0 || DatabaseDescriptor.getReplaceNode() != null)     throw new RuntimeException("Replace method removed; use cassandra.replace_address instead");
    if (!MessagingService.instance().isListening())     MessagingService.instance().listen();
    UUID localHostId=SystemKeyspace.getLocalHostId();
    if (replacing) {
      if (SystemKeyspace.bootstrapComplete())       throw new RuntimeException("Cannot replace address with a node that is already bootstrapped");
      if (!(Boolean.parseBoolean(System.getProperty("cassandra.join_ring","true"))))       throw new ConfigurationException("Cannot set both join_ring=false and attempt to replace a node");
      if (!DatabaseDescriptor.isAutoBootstrap() && !Boolean.getBoolean("cassandra.allow_unsafe_replace"))       throw new RuntimeException("Replacing a node without bootstrapping risks invalidating consistency " + "guarantees as the expected data may not be present until repair is run. " + "To perform this operation, please restart with "+ "-Dcassandra.allow_unsafe_replace=true");
      InetAddress replaceAddress=DatabaseDescriptor.getReplaceAddress();
      localHostId=prepareReplacementInfo(replaceAddress);
      appStates.put(ApplicationState.TOKENS,valueFactory.tokens(bootstrapTokens));
      if (DatabaseDescriptor.isAutoBootstrap())       appStates.put(ApplicationState.STATUS,valueFactory.hibernate(true));
 else       SystemKeyspace.updateTokens(bootstrapTokens);
    }
 else {
      checkForEndpointCollision(localHostId);
    }
    getTokenMetadata().updateHostId(localHostId,FBUtilities.getBroadcastAddress());
    appStates.put(ApplicationState.NET_VERSION,valueFactory.networkVersion());
    appStates.put(ApplicationState.HOST_ID,valueFactory.hostId(localHostId));
    appStates.put(ApplicationState.RPC_ADDRESS,valueFactory.rpcaddress(FBUtilities.getBroadcastRpcAddress()));
    appStates.put(ApplicationState.RELEASE_VERSION,valueFactory.releaseVersion());
    loadRingState();
    logger.info("Starting up server gossip");
    Gossiper.instance.register(this);
    Gossiper.instance.start(SystemKeyspace.incrementAndGetGeneration(),appStates);
    gossipActive=true;
    gossipSnitchInfo();
    Schema.instance.updateVersionAndAnnounce();
    LoadBroadcaster.instance.startBroadcasting();
    HintsService.instance.startDispatch();
    BatchlogManager.instance.start();
  }
}
