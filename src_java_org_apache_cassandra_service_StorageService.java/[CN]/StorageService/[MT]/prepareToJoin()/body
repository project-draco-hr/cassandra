{
  if (!joined) {
    Map<ApplicationState,VersionedValue> appStates=new EnumMap<>(ApplicationState.class);
    if (SystemKeyspace.wasDecommissioned()) {
      if (Boolean.getBoolean("cassandra.override_decommission")) {
        logger.warn("This node was decommissioned, but overriding by operator request.");
        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);
      }
 else       throw new ConfigurationException("This node was decommissioned and will not rejoin the ring unless cassandra.override_decommission=true has been set, or all existing data is removed and the node is bootstrapped again");
    }
    if (replacing && !joinRing)     throw new ConfigurationException("Cannot set both join_ring=false and attempt to replace a node");
    if (DatabaseDescriptor.getReplaceTokens().size() > 0 || DatabaseDescriptor.getReplaceNode() != null)     throw new RuntimeException("Replace method removed; use cassandra.replace_address instead");
    if (replacing) {
      if (SystemKeyspace.bootstrapComplete())       throw new RuntimeException("Cannot replace address with a node that is already bootstrapped");
      if (!DatabaseDescriptor.isAutoBootstrap())       throw new RuntimeException("Trying to replace_address with auto_bootstrap disabled will not work, check your configuration");
      bootstrapTokens=prepareReplacementInfo();
      if (isReplacingSameAddress()) {
        logger.warn("Writes will not be forwarded to this node during replacement because it has the same address as " + "the node to be replaced ({}). If the previous node has been down for longer than max_hint_window_in_ms, " + "repair must be run after the replacement process in order to make this node consistent.",DatabaseDescriptor.getReplaceAddress());
        appStates.put(ApplicationState.TOKENS,valueFactory.tokens(bootstrapTokens));
        appStates.put(ApplicationState.STATUS,valueFactory.hibernate(true));
      }
    }
 else     if (shouldBootstrap()) {
      checkForEndpointCollision();
    }
    UUID localHostId=SystemKeyspace.getLocalHostId();
    getTokenMetadata().updateHostId(localHostId,FBUtilities.getBroadcastAddress());
    appStates.put(ApplicationState.NET_VERSION,valueFactory.networkVersion());
    appStates.put(ApplicationState.HOST_ID,valueFactory.hostId(localHostId));
    appStates.put(ApplicationState.RPC_ADDRESS,valueFactory.rpcaddress(FBUtilities.getBroadcastRpcAddress()));
    appStates.put(ApplicationState.RELEASE_VERSION,valueFactory.releaseVersion());
    logger.info("Starting up server gossip");
    Gossiper.instance.register(this);
    Gossiper.instance.start(SystemKeyspace.incrementAndGetGeneration(),appStates);
    gossipSnitchInfo();
    Schema.instance.updateVersionAndAnnounce();
    if (!MessagingService.instance().isListening())     MessagingService.instance().listen();
    LoadBroadcaster.instance.startBroadcasting();
    HintsService.instance.startDispatch();
    BatchlogManager.instance.start();
  }
}
