{
  if (parallelismDegree < 0 || parallelismDegree > RepairParallelism.values().length - 1) {
    throw new IllegalArgumentException("Invalid parallelism degree specified: " + parallelismDegree);
  }
  Collection<Range<Token>> repairingRange=createRepairRangeFrom(beginToken,endToken);
  logger.info("starting user-requested repair of range {} for keyspace {} and column families {}",repairingRange,keyspaceName,columnFamilies);
  RepairParallelism parallelism=RepairParallelism.values()[parallelismDegree];
  if (!FBUtilities.isUnix() && parallelism != RepairParallelism.PARALLEL) {
    logger.warn("Snapshot-based repair is not yet supported on Windows.  Reverting to parallel repair.");
    parallelism=RepairParallelism.PARALLEL;
  }
  return forceRepairAsync(keyspaceName,parallelism,dataCenters,hosts,repairingRange,columnFamilies);
}
