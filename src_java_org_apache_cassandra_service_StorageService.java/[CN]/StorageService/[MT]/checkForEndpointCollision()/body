{
  logger.debug("Starting shadow gossip round to check for endpoint collision");
  if (!MessagingService.instance().isListening())   MessagingService.instance().listen(FBUtilities.getLocalAddress());
  Gossiper.instance.doShadowRound();
  if (!Gossiper.instance.isSafeForBootstrap(FBUtilities.getBroadcastAddress())) {
    throw new RuntimeException(String.format("A node with address %s already exists, cancelling join. " + "Use cassandra.replace_address if you want to replace this node.",FBUtilities.getBroadcastAddress()));
  }
  if (RangeStreamer.useStrictConsistency && !allowSimultaneousMoves()) {
    for (    Map.Entry<InetAddress,EndpointState> entry : Gossiper.instance.getEndpointStates()) {
      if (entry.getKey().equals(FBUtilities.getBroadcastAddress()) || entry.getValue().getApplicationState(ApplicationState.STATUS) == null)       continue;
      String[] pieces=entry.getValue().getApplicationState(ApplicationState.STATUS).value.split(VersionedValue.DELIMITER_STR,-1);
      assert(pieces.length > 0);
      String state=pieces[0];
      if (state.equals(VersionedValue.STATUS_BOOTSTRAPPING) || state.equals(VersionedValue.STATUS_LEAVING) || state.equals(VersionedValue.STATUS_MOVING))       throw new UnsupportedOperationException("Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while cassandra.consistent.rangemovement is true");
    }
  }
  Gossiper.instance.resetEndpointStateMap();
}
