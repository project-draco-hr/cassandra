{
  Collection<Token> tokens=getTokensFor(endpoint);
  Set<Token> tokensToUpdateInMetadata=new HashSet<>();
  Set<Token> tokensToUpdateInSystemKeyspace=new HashSet<>();
  Set<InetAddress> endpointsToRemove=new HashSet<>();
  if (logger.isDebugEnabled())   logger.debug("Node {} state {}, token {}",endpoint,status,tokens);
  if (tokenMetadata.isMember(endpoint))   logger.info("Node {} state jump to {}",endpoint,status);
  if (tokens.isEmpty() && status.equals(VersionedValue.STATUS_NORMAL))   logger.error("Node {} is in state normal but it has no tokens, state: {}",endpoint,Gossiper.instance.getEndpointStateForEndpoint(endpoint));
  updatePeerInfo(endpoint);
  UUID hostId=Gossiper.instance.getHostId(endpoint);
  InetAddress existing=tokenMetadata.getEndpointForHostId(hostId);
  if (replacing && Gossiper.instance.getEndpointStateForEndpoint(DatabaseDescriptor.getReplaceAddress()) != null && (hostId.equals(Gossiper.instance.getHostId(DatabaseDescriptor.getReplaceAddress()))))   logger.warn("Not updating token metadata for {} because I am replacing it",endpoint);
 else {
    if (existing != null && !existing.equals(endpoint)) {
      if (existing.equals(FBUtilities.getBroadcastAddress())) {
        logger.warn("Not updating host ID {} for {} because it's mine",hostId,endpoint);
        tokenMetadata.removeEndpoint(endpoint);
        endpointsToRemove.add(endpoint);
      }
 else       if (Gossiper.instance.compareEndpointStartup(endpoint,existing) > 0) {
        logger.warn("Host ID collision for {} between {} and {}; {} is the new owner",hostId,existing,endpoint,endpoint);
        tokenMetadata.removeEndpoint(existing);
        endpointsToRemove.add(existing);
        tokenMetadata.updateHostId(hostId,endpoint);
      }
 else {
        logger.warn("Host ID collision for {} between {} and {}; ignored {}",hostId,existing,endpoint,endpoint);
        tokenMetadata.removeEndpoint(endpoint);
        endpointsToRemove.add(endpoint);
      }
    }
 else     tokenMetadata.updateHostId(hostId,endpoint);
  }
  for (  final Token token : tokens) {
    InetAddress currentOwner=tokenMetadata.getEndpoint(token);
    if (currentOwner == null) {
      logger.debug("New node {} at token {}",endpoint,token);
      tokensToUpdateInMetadata.add(token);
      tokensToUpdateInSystemKeyspace.add(token);
    }
 else     if (endpoint.equals(currentOwner)) {
      tokensToUpdateInMetadata.add(token);
      tokensToUpdateInSystemKeyspace.add(token);
    }
 else     if (Gossiper.instance.compareEndpointStartup(endpoint,currentOwner) > 0) {
      tokensToUpdateInMetadata.add(token);
      tokensToUpdateInSystemKeyspace.add(token);
      Multimap<InetAddress,Token> epToTokenCopy=getTokenMetadata().getEndpointToTokenMapForReading();
      epToTokenCopy.get(currentOwner).remove(token);
      if (epToTokenCopy.get(currentOwner).size() < 1)       endpointsToRemove.add(currentOwner);
      logger.info(String.format("Nodes %s and %s have the same token %s.  %s is the new owner",endpoint,currentOwner,token,endpoint));
    }
 else {
      logger.info(String.format("Nodes %s and %s have the same token %s.  Ignoring %s",endpoint,currentOwner,token,endpoint));
    }
  }
  boolean isMember=tokenMetadata.isMember(endpoint);
  boolean isMoving=tokenMetadata.isMoving(endpoint);
  tokenMetadata.updateNormalTokens(tokensToUpdateInMetadata,endpoint);
  for (  InetAddress ep : endpointsToRemove) {
    removeEndpoint(ep);
    if (replacing && DatabaseDescriptor.getReplaceAddress().equals(ep))     Gossiper.instance.replacementQuarantine(ep);
  }
  if (!tokensToUpdateInSystemKeyspace.isEmpty())   SystemKeyspace.updateTokens(endpoint,tokensToUpdateInSystemKeyspace);
  ;
  if (isMoving || operationMode == Mode.MOVING) {
    tokenMetadata.removeFromMoving(endpoint);
    notifyMoved(endpoint);
  }
 else   if (!isMember) {
    notifyJoined(endpoint);
  }
  PendingRangeCalculatorService.instance.update();
}
