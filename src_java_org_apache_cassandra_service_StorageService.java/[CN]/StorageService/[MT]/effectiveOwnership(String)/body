{
  if (Schema.instance.getNonSystemKeyspaces().size() <= 0)   throw new IllegalStateException("Couldn't find any Non System Keyspaces to infer replication topology");
  if (keyspace == null && !hasSameReplication(Schema.instance.getNonSystemKeyspaces()))   throw new IllegalStateException("Non System keyspaces doesnt have the same topology");
  TokenMetadata metadata=tokenMetadata.cloneOnlyTokenMap();
  if (keyspace == null)   keyspace=Schema.instance.getNonSystemKeyspaces().get(0);
  Collection<Collection<InetAddress>> endpointsGroupedByDc=new ArrayList<>();
  SortedMap<String,Collection<InetAddress>> sortedDcsToEndpoints=new TreeMap<>();
  sortedDcsToEndpoints.putAll(metadata.getTopology().getDatacenterEndpoints().asMap());
  for (  Collection<InetAddress> endpoints : sortedDcsToEndpoints.values())   endpointsGroupedByDc.add(endpoints);
  Map<Token,Float> tokenOwnership=getPartitioner().describeOwnership(tokenMetadata.sortedTokens());
  LinkedHashMap<InetAddress,Float> finalOwnership=Maps.newLinkedHashMap();
  for (  Collection<InetAddress> endpoints : endpointsGroupedByDc) {
    for (    InetAddress endpoint : endpoints) {
      float ownership=0.0f;
      for (      Range<Token> range : getRangesForEndpoint(keyspace,endpoint)) {
        if (tokenOwnership.containsKey(range.right))         ownership+=tokenOwnership.get(range.right);
      }
      finalOwnership.put(endpoint,ownership);
    }
  }
  return finalOwnership;
}
