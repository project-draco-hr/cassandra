{
  if (keyspace != null) {
    Keyspace keyspaceInstance=Schema.instance.getKeyspaceInstance(keyspace);
    if (keyspaceInstance == null)     throw new IllegalArgumentException("The keyspace " + keyspace + ", does not exist");
    if (keyspaceInstance.getReplicationStrategy() instanceof LocalStrategy)     throw new IllegalStateException("Ownership values for keyspaces with LocalStrategy are meaningless");
  }
 else {
    List<String> nonSystemKeyspaces=Schema.instance.getNonSystemKeyspaces();
    int specialTableCount=0;
    if (nonSystemKeyspaces.contains("system_traces")) {
      specialTableCount+=1;
    }
    if (nonSystemKeyspaces.size() > specialTableCount)     throw new IllegalStateException("Non-system keyspaces don't have the same replication settings, effective ownership information is meaningless");
    keyspace="system_traces";
  }
  TokenMetadata metadata=tokenMetadata.cloneOnlyTokenMap();
  if (keyspace == null)   keyspace=Schema.instance.getNonSystemKeyspaces().get(0);
  Collection<Collection<InetAddress>> endpointsGroupedByDc=new ArrayList<>();
  SortedMap<String,Collection<InetAddress>> sortedDcsToEndpoints=new TreeMap<>();
  sortedDcsToEndpoints.putAll(metadata.getTopology().getDatacenterEndpoints().asMap());
  for (  Collection<InetAddress> endpoints : sortedDcsToEndpoints.values())   endpointsGroupedByDc.add(endpoints);
  Map<Token,Float> tokenOwnership=getPartitioner().describeOwnership(tokenMetadata.sortedTokens());
  LinkedHashMap<InetAddress,Float> finalOwnership=Maps.newLinkedHashMap();
  for (  Collection<InetAddress> endpoints : endpointsGroupedByDc) {
    for (    InetAddress endpoint : endpoints) {
      float ownership=0.0f;
      for (      Range<Token> range : getRangesForEndpoint(keyspace,endpoint)) {
        if (tokenOwnership.containsKey(range.right))         ownership+=tokenOwnership.get(range.right);
      }
      finalOwnership.put(endpoint,ownership);
    }
  }
  return finalOwnership;
}
