{
  if (Schema.instance.getNonSystemTables().size() <= 0)   throw new ConfigurationException("Couldn't find any Non System Keyspaces to infer replication topology");
  if (keyspace == null && !hasSameReplication(Schema.instance.getNonSystemTables()))   throw new ConfigurationException("Non System keyspaces doesnt have the same topology");
  TokenMetadata metadata=tokenMetadata.cloneOnlyTokenMap();
  if (keyspace == null)   keyspace=Schema.instance.getNonSystemTables().get(0);
  Collection<Collection<InetAddress>> endpointsGroupedByDc=new ArrayList<Collection<InetAddress>>();
  SortedMap<String,Collection<InetAddress>> sortedDcsToEndpoints=new TreeMap<String,Collection<InetAddress>>();
  sortedDcsToEndpoints.putAll(metadata.getTopology().getDatacenterEndpoints().asMap());
  for (  Collection<InetAddress> endpoints : sortedDcsToEndpoints.values())   endpointsGroupedByDc.add(endpoints);
  Map<Token,Float> tokenOwnership=getPartitioner().describeOwnership(tokenMetadata.sortedTokens());
  LinkedHashMap<InetAddress,Float> finalOwnership=Maps.newLinkedHashMap();
  for (  Collection<InetAddress> endpoints : endpointsGroupedByDc) {
    List<InetAddress> sortedEndpoints=Lists.newArrayListWithExpectedSize(endpoints.size());
    sortedEndpoints.addAll(endpoints);
    Collections.sort(sortedEndpoints,new Comparator<InetAddress>(){
      public int compare(      InetAddress o1,      InetAddress o2){
        byte[] b1=o1.getAddress();
        byte[] b2=o2.getAddress();
        if (b1.length < b2.length)         return -1;
        if (b1.length > b2.length)         return 1;
        for (int i=0; i < b1.length; i++) {
          int left=(int)b1[i] & 0xFF;
          int right=(int)b2[i] & 0xFF;
          if (left < right)           return -1;
 else           if (left > right)           return 1;
        }
        return 0;
      }
    }
);
    for (    InetAddress endpoint : endpoints) {
      float ownership=0.0f;
      for (      Range<Token> range : getRangesForEndpoint(keyspace,endpoint)) {
        if (tokenOwnership.containsKey(range.left))         ownership+=tokenOwnership.get(range.left);
      }
      finalOwnership.put(endpoint,ownership);
    }
  }
  return finalOwnership;
}
