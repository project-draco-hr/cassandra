{
  if (new HashSet<>(argNames).size() != argNames.size())   throw new InvalidRequestException(String.format("duplicate argument names for given function %s with argument names %s",functionName,argNames));
  List<AbstractType<?>> argTypes=new ArrayList<>(argRawTypes.size());
  for (  CQL3Type.Raw rawType : argRawTypes)   argTypes.add(rawType.prepare(typeKeyspace(rawType)).getType());
  AbstractType<?> returnType=rawReturnType.prepare(typeKeyspace(rawReturnType)).getType();
  Function old=Functions.find(functionName,argTypes);
  if (old != null) {
    if (ifNotExists)     return false;
    if (!orReplace)     throw new InvalidRequestException(String.format("Function %s already exists",old));
    if (!(old instanceof ScalarFunction))     throw new InvalidRequestException(String.format("Function %s can only replace a function",old));
    if (!Functions.typeEquals(old.returnType(),returnType))     throw new InvalidRequestException(String.format("Cannot replace function %s, the new return type %s is not compatible with the return type %s of existing function",functionName,returnType.asCQL3Type(),old.returnType().asCQL3Type()));
  }
  MigrationManager.announceNewFunction(UDFunction.create(functionName,argNames,argTypes,returnType,language,body,deterministic),isLocalOnly);
  return true;
}
