{
  final SlicePredicate predicate=new SlicePredicate().setSlice_range(new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER,ByteBufferUtil.EMPTY_BYTE_BUFFER,false,state.settings.columns.maxColumnsPerKey));
  final List<ByteBuffer> columns=generateColumnValues(getKey());
  final ColumnParent parent=state.columnParents.get(0);
  final ByteBuffer columnName=state.settings.columns.names.get(1);
  final ByteBuffer value=columns.get(1);
  IndexExpression expression=new IndexExpression(columnName,IndexOperator.EQ,value);
  byte[] minKey=new byte[0];
  final List<KeySlice>[] results=new List[1];
  do {
    final boolean first=minKey.length == 0;
    final IndexClause clause=new IndexClause(Arrays.asList(expression),ByteBuffer.wrap(minKey),state.settings.command.keysAtOnce);
    timeWithRetry(new RunOp(){
      @Override public boolean run() throws Exception {
        results[0]=client.get_indexed_slices(parent,clause,predicate,state.settings.command.consistencyLevel);
        return !first || results[0].size() > 0;
      }
      @Override public String key(){
        return new String(value.array());
      }
      @Override public int keyCount(){
        return results[0].size();
      }
    }
);
    minKey=getNextMinKey(minKey,results[0]);
  }
 while (results[0].size() > 0);
}
