{
  ThreadLocalRandom rnd=ThreadLocalRandom.current();
  long operationCount=0, partitionCount=0, rowCount=0, errorCount=0;
  long maxLatency=0, totalLatency=0;
  List<SampleOfLongs> latencies=new ArrayList<>();
  long end=0;
  long pauseStart=0, pauseEnd=Long.MAX_VALUE;
  for (  TimingInterval interval : intervals) {
    if (interval != null) {
      end=Math.max(end,interval.end);
      operationCount+=interval.operationCount;
      maxLatency=Math.max(interval.maxLatency,maxLatency);
      totalLatency+=interval.totalLatency;
      partitionCount+=interval.partitionCount;
      rowCount+=interval.rowCount;
      errorCount+=interval.errorCount;
      latencies.addAll(Arrays.asList(interval.sample));
      if (interval.pauseLength > 0) {
        pauseStart=Math.max(pauseStart,interval.pauseStart);
        pauseEnd=Math.min(pauseEnd,interval.pauseStart + interval.pauseLength);
      }
    }
  }
  if (pauseEnd < pauseStart || pauseStart <= 0) {
    pauseEnd=pauseStart=0;
  }
  return new TimingInterval(start,end,maxLatency,pauseStart,pauseEnd - pauseStart,partitionCount,rowCount,totalLatency,operationCount,errorCount,SampleOfLongs.merge(rnd,latencies,maxSamples));
}
