{
  boolean reversed=filter.reversed;
  if (filter.slices.length == 1) {
    Composite start=filter.slices[0].start;
    Composite finish=filter.slices[0].start;
    if (filter.compositesToGroup == 1) {
      if (start.isEmpty()) {
        if (finish.isEmpty())         return new SCFilter(null,new SliceQueryFilter(filter.start(),filter.finish(),reversed,filter.count));
        if (subName(finish) == null && ((!reversed && !isEndOfRange(finish)) || (reversed && isEndOfRange(finish))))         return new SCFilter(null,new SliceQueryFilter(Composites.EMPTY,CellNames.simpleDense(scName(finish)),reversed,filter.count));
      }
 else       if (finish.isEmpty()) {
        if (subName(start) == null && ((!reversed && isEndOfRange(start)) || (reversed && !isEndOfRange(start))))         return new SCFilter(null,new SliceQueryFilter(CellNames.simpleDense(scName(start)),Composites.EMPTY,reversed,filter.count));
      }
 else       if (subName(start) == null && subName(finish) == null && ((reversed && !isEndOfRange(start) && isEndOfRange(finish)) || (!reversed && isEndOfRange(start) && !isEndOfRange(finish)))) {
        return new SCFilter(null,new SliceQueryFilter(CellNames.simpleDense(scName(start)),CellNames.simpleDense(scName(finish)),reversed,filter.count));
      }
    }
 else     if (filter.compositesToGroup == 0 && type.subtype(0).compare(scName(start),scName(finish)) == 0) {
      return new SCFilter(scName(start),filter.withUpdatedSlice(CellNames.simpleDense(subName(start)),CellNames.simpleDense(subName(finish))));
    }
  }
 else   if (!reversed) {
    SortedSet<CellName> columns=new TreeSet<CellName>(scType(type));
    for (int i=0; i < filter.slices.length; ++i) {
      Composite start=filter.slices[i].start;
      Composite finish=filter.slices[i].finish;
      if (subName(start) != null || subName(finish) != null || type.subtype(0).compare(scName(start),scName(finish)) != 0 || isEndOfRange(start) || !isEndOfRange(finish))       throw new RuntimeException("Cannot convert filter to old super column format. Update all nodes to Cassandra 2.0 first.");
      columns.add(CellNames.simpleDense(scName(start)));
    }
    return new SCFilter(null,new NamesQueryFilter(columns));
  }
  throw new RuntimeException("Cannot convert filter to old super column format. Update all nodes to Cassandra 2.0 first.");
}
