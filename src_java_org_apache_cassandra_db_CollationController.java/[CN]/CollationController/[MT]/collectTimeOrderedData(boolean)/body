{
  final ColumnFamily container=ArrayBackedSortedColumns.factory.create(cfs.metadata,filter.filter.isReversed());
  List<OnDiskAtomIterator> iterators=new ArrayList<>();
  boolean isEmpty=true;
  Tracing.trace("Acquiring sstable references");
  ColumnFamilyStore.ViewFragment view=cfs.select(cfs.viewFilter(filter.key));
  try {
    Tracing.trace("Merging memtable contents");
    long mostRecentRowTombstone=Long.MIN_VALUE;
    for (    Memtable memtable : view.memtables) {
      ColumnFamily cf=memtable.getColumnFamily(filter.key);
      if (cf != null) {
        filter.delete(container.deletionInfo(),cf);
        isEmpty=false;
        Iterator<Cell> iter=filter.getIterator(cf);
        while (iter.hasNext()) {
          Cell cell=iter.next();
          if (copyOnHeap)           cell=cell.localCopy(cfs.metadata,HeapAllocator.instance);
          container.addColumn(cell);
        }
      }
      mostRecentRowTombstone=container.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
    }
    NamesQueryFilter namesFilter=(NamesQueryFilter)filter.filter;
    TreeSet<CellName> filterColumns=new TreeSet<>(namesFilter.columns);
    QueryFilter reducedFilter=new QueryFilter(filter.key,filter.cfName,namesFilter.withUpdatedColumns(filterColumns),filter.timestamp);
    Collections.sort(view.sstables,SSTableReader.maxTimestampComparator);
    for (    SSTableReader sstable : view.sstables) {
      if (sstable.getMaxTimestamp() < mostRecentRowTombstone)       break;
      long currentMaxTs=sstable.getMaxTimestamp();
      reduceNameFilter(reducedFilter,container,currentMaxTs);
      if (((NamesQueryFilter)reducedFilter.filter).columns.isEmpty())       break;
      Tracing.trace("Merging data from sstable {}",sstable.descriptor.generation);
      sstable.incrementReadCount();
      OnDiskAtomIterator iter=reducedFilter.getSSTableColumnIterator(sstable);
      iterators.add(iter);
      isEmpty=false;
      if (iter.getColumnFamily() != null) {
        container.delete(iter.getColumnFamily());
        sstablesIterated++;
        while (iter.hasNext())         container.addAtom(iter.next());
      }
      mostRecentRowTombstone=container.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
    }
    if (isEmpty)     return null;
    ColumnFamily returnCF=container.cloneMeShallow();
    Tracing.trace("Collating all results");
    filter.collateOnDiskAtom(returnCF,container.iterator(),gcBefore);
    if (sstablesIterated > cfs.getMinimumCompactionThreshold() && !cfs.isAutoCompactionDisabled() && cfs.getCompactionStrategy().shouldDefragment()) {
      Tracing.trace("Defragmenting requested data");
      final Mutation mutation=new Mutation(cfs.keyspace.getName(),filter.key.getKey(),returnCF.cloneMe());
      StageManager.getStage(Stage.MUTATION).execute(new Runnable(){
        public void run(){
          Keyspace.open(mutation.getKeyspaceName()).apply(mutation,false,false);
        }
      }
);
    }
    return returnCF;
  }
  finally {
    for (    OnDiskAtomIterator iter : iterators)     FileUtils.closeQuietly(iter);
  }
}
