{
  Tracing.trace("Acquiring sstable references");
  ColumnFamilyStore.ViewFragment view=cfs.markReferenced(filter.key);
  List<OnDiskAtomIterator> iterators=new ArrayList<OnDiskAtomIterator>(Iterables.size(view.memtables) + view.sstables.size());
  ColumnFamily returnCF=ArrayBackedSortedColumns.factory.create(cfs.metadata,filter.filter.isReversed());
  try {
    Tracing.trace("Merging memtable tombstones");
    for (    Memtable memtable : view.memtables) {
      OnDiskAtomIterator iter=filter.getMemtableColumnIterator(memtable);
      if (iter != null) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
    Collections.sort(view.sstables,SSTable.maxTimestampComparator);
    long mostRecentRowTombstone=Long.MIN_VALUE;
    for (    SSTableReader sstable : view.sstables) {
      if (sstable.getMaxTimestamp() < mostRecentRowTombstone)       break;
      OnDiskAtomIterator iter=filter.getSSTableColumnIterator(sstable);
      iterators.add(iter);
      if (iter.getColumnFamily() != null) {
        ColumnFamily cf=iter.getColumnFamily();
        if (cf.isMarkedForDelete())         mostRecentRowTombstone=cf.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
        returnCF.delete(cf);
        sstablesIterated++;
      }
    }
    if (iterators.isEmpty())     return null;
    Tracing.trace("Merging data from memtables and {} sstables",sstablesIterated);
    filter.collateOnDiskAtom(returnCF,iterators,gcBefore);
    return returnCF;
  }
  finally {
    for (    OnDiskAtomIterator iter : iterators)     FileUtils.closeQuietly(iter);
    SSTableReader.releaseReferences(view.sstables);
  }
}
