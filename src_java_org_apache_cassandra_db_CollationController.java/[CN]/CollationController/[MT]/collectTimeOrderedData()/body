{
  logger.trace("collectTimeOrderedData");
  ISortedColumns.Factory factory=mutableColumns ? cfs.metadata.cfType == ColumnFamilyType.Super ? ThreadSafeSortedColumns.factory() : AtomicSortedColumns.factory() : TreeMapBackedSortedColumns.factory();
  ColumnFamily container=ColumnFamily.create(cfs.metadata,factory,filter.filter.isReversed());
  List<OnDiskAtomIterator> iterators=new ArrayList<OnDiskAtomIterator>();
  Tracing.trace("Acquiring sstable references");
  ColumnFamilyStore.ViewFragment view=cfs.markReferenced(filter.key);
  try {
    Tracing.trace("Merging memtable contents");
    for (    Memtable memtable : view.memtables) {
      OnDiskAtomIterator iter=filter.getMemtableColumnIterator(memtable);
      if (iter != null) {
        iterators.add(iter);
        container.delete(iter.getColumnFamily());
        while (iter.hasNext())         container.addAtom(iter.next());
      }
    }
    TreeSet<ByteBuffer> filterColumns=new TreeSet<ByteBuffer>(((NamesQueryFilter)filter.filter).columns);
    QueryFilter reducedFilter=new QueryFilter(filter.key,filter.path,new NamesQueryFilter(filterColumns));
    Collections.sort(view.sstables,SSTable.maxTimestampComparator);
    long mostRecentRowTombstone=Long.MIN_VALUE;
    for (    SSTableReader sstable : view.sstables) {
      if (sstable.getMaxTimestamp() < mostRecentRowTombstone)       break;
      long currentMaxTs=sstable.getMaxTimestamp();
      reduceNameFilter(reducedFilter,container,currentMaxTs);
      if (((NamesQueryFilter)reducedFilter.filter).columns.isEmpty())       break;
      OnDiskAtomIterator iter=reducedFilter.getSSTableColumnIterator(sstable);
      iterators.add(iter);
      if (iter.getColumnFamily() != null) {
        ColumnFamily cf=iter.getColumnFamily();
        if (cf.isMarkedForDelete()) {
          mostRecentRowTombstone=cf.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
        }
        container.delete(cf);
        sstablesIterated++;
        Tracing.trace("Merging data from sstable {}",sstable.descriptor.generation);
        while (iter.hasNext())         container.addAtom(iter.next());
      }
    }
    if (iterators.isEmpty())     return null;
    final ColumnFamily c2=container;
    CloseableIterator<OnDiskAtom> toCollate=new SimpleAbstractColumnIterator(){
      final Iterator<IColumn> iter=c2.iterator();
      protected OnDiskAtom computeNext(){
        return iter.hasNext() ? iter.next() : endOfData();
      }
      public ColumnFamily getColumnFamily(){
        return c2;
      }
      public DecoratedKey getKey(){
        return filter.key;
      }
    }
;
    ColumnFamily returnCF=container.cloneMeShallow();
    Tracing.trace("Collating all results");
    filter.collateOnDiskAtom(returnCF,Collections.singletonList(toCollate),gcBefore);
    if (sstablesIterated > cfs.getMinimumCompactionThreshold() && !cfs.isCompactionDisabled() && cfs.getCompactionStrategy() instanceof SizeTieredCompactionStrategy) {
      Tracing.trace("Defragmenting requested data");
      RowMutation rm=new RowMutation(cfs.table.name,new Row(filter.key,returnCF.cloneMe()));
      Table.open(rm.getTable()).apply(rm,false,false);
    }
    return returnCF;
  }
  finally {
    for (    OnDiskAtomIterator iter : iterators)     FileUtils.closeQuietly(iter);
    SSTableReader.releaseReferences(view.sstables);
  }
}
