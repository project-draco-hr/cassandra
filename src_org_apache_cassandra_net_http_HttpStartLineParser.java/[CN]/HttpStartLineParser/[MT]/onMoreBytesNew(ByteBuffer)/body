{
  int got;
  int limit=buffer.limit();
  int pos=buffer.position();
  if (parseState_ == StartLineParseState.TO_RESET) {
    resetParserState();
  }
  while (pos < limit) {
switch (parseState_) {
case EATING_WHITESPACE:
      while ((char)buffer.get(pos) == ' ' && ++pos < limit)       ;
    if (pos < limit)     parseState_=nextState_;
  break;
case READING_METHOD:
while (pos < limit && (got=buffer.get(pos)) != ' ') {
  httpMethod_.append((char)got);
  pos++;
}
if (pos < limit) {
parseState_=StartLineParseState.EATING_WHITESPACE;
nextState_=StartLineParseState.READING_PATH;
}
break;
case READING_PATH:
while (pos < limit && parseState_ == StartLineParseState.READING_PATH) {
got=buffer.get(pos++);
switch (got) {
case '\r':
parseState_=StartLineParseState.CHECKING_EOL;
break;
case '%':
encodeTo_=httpPath_;
nextState_=parseState_;
parseState_=StartLineParseState.DECODING_FIRST_CHAR;
break;
case ' ':
parseState_=StartLineParseState.EATING_WHITESPACE;
nextState_=StartLineParseState.READING_VERSION;
break;
case '?':
parseState_=StartLineParseState.READING_QUERY;
break;
default :
httpPath_.append((char)got);
break;
}
}
break;
case READING_QUERY:
while (pos < limit && parseState_ == StartLineParseState.READING_QUERY) {
got=buffer.get(pos++);
switch (got) {
case '\r':
parseState_=StartLineParseState.CHECKING_EOL;
break;
case '%':
encodeTo_=httpQuery_;
nextState_=parseState_;
parseState_=StartLineParseState.DECODING_FIRST_CHAR;
break;
case ' ':
parseState_=StartLineParseState.EATING_WHITESPACE;
nextState_=StartLineParseState.READING_VERSION;
break;
case '+':
httpQuery_.append(' ');
break;
default :
httpQuery_.append((char)got);
break;
}
}
break;
case DECODING_FIRST_CHAR:
got=(int)buffer.get(pos++);
encodedValue_=decodeHex(got) * 16;
parseState_=StartLineParseState.DECODING_SECOND_CHAR;
break;
case DECODING_SECOND_CHAR:
got=(int)buffer.get(pos++);
encodeTo_.append((char)(decodeHex(got) + encodedValue_));
parseState_=nextState_;
break;
case READING_VERSION:
while (pos < limit && (got=buffer.get(pos)) != '\r') {
httpVersion_.append((char)got);
pos++;
}
if (pos < limit) {
parseState_=StartLineParseState.CHECKING_EOL;
pos++;
}
break;
case CHECKING_EOL:
switch (buffer.get(pos++)) {
case '\n':
finishLine_();
parseState_=StartLineParseState.TO_RESET;
buffer.position(pos);
return true;
default :
throw new HttpParsingException();
}
default :
throw new HttpParsingException();
}
}
buffer.position(pos);
return false;
}
