{
  lock_.readLock().lock();
  List<ColumnIterator> iterators=new ArrayList<ColumnIterator>();
  try {
    final ColumnFamily returnCF;
    ColumnIterator iter;
    memtableLock_.readLock().lock();
    try {
      iter=memtable_.getColumnIterator(key,cfName,isAscending,startColumn);
      returnCF=iter.getColumnFamily();
    }
  finally {
      memtableLock_.readLock().unlock();
    }
    iterators.add(iter);
    List<Memtable> memtables=getUnflushedMemtables(cfName);
    for (    Memtable memtable : memtables) {
      iter=memtable.getColumnIterator(key,cfName,isAscending,startColumn);
      returnCF.delete(iter.getColumnFamily());
      iterators.add(iter);
    }
    List<SSTable> sstables=new ArrayList<SSTable>(ssTables_.values());
    for (    SSTable sstable : sstables) {
      if (!sstable.isKeyPossible(key))       continue;
      iter=new SSTableColumnIterator(sstable.getFilename(),key,cfName,startColumn,isAscending);
      if (iter.hasNext()) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
    Comparator<IColumn> comparator=new Comparator<IColumn>(){
      public int compare(      IColumn c1,      IColumn c2){
        return c1.name().compareTo(c2.name());
      }
    }
;
    if (!isAscending)     comparator=new ReverseComparator(comparator);
    Iterator collated=IteratorUtils.collatedIterator(comparator,iterators);
    if (!collated.hasNext())     return ColumnFamily.create(table_,cfName);
    ReducingIterator<IColumn> reduced=new ReducingIterator<IColumn>(collated){
      ColumnFamily curCF=returnCF.cloneMeShallow();
      protected Object getKey(      IColumn o){
        return o == null ? null : o.name();
      }
      public void reduce(      IColumn current){
        curCF.addColumn(current);
      }
      protected IColumn getReduced(){
        IColumn c=curCF.getAllColumns().first();
        curCF.clear();
        return c;
      }
    }
;
    int liveColumns=0;
    int limit=offset + count;
    for (    IColumn column : reduced) {
      if (liveColumns >= limit) {
        break;
      }
      if (!column.isMarkedForDelete())       liveColumns++;
      if (liveColumns > offset)       returnCF.addColumn(column);
    }
    return removeDeleted(returnCF);
  }
  finally {
    for (    ColumnIterator ci : iterators) {
      try {
        ci.close();
      }
 catch (      Throwable th) {
        logger_.error(th);
      }
    }
    lock_.readLock().unlock();
  }
}
