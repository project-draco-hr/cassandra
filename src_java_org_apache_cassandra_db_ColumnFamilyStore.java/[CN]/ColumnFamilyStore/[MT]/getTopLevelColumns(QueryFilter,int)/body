{
  List<IColumnIterator> iterators=new ArrayList<IColumnIterator>();
  final ColumnFamily returnCF=ColumnFamily.create(metadata);
  try {
    IColumnIterator iter;
    int sstablesToIterate=0;
    if (reverseReadWriteOrder()) {
      for (      SSTableReader sstable : ssTables) {
        iter=filter.getSSTableColumnIterator(sstable);
        if (iter.getColumnFamily() != null) {
          returnCF.delete(iter.getColumnFamily());
          iterators.add(iter);
          sstablesToIterate++;
        }
      }
      for (      Memtable memtable : memtablesPendingFlush) {
        iter=filter.getMemtableColumnIterator(memtable,getComparator());
        if (iter != null) {
          returnCF.delete(iter.getColumnFamily());
          iterators.add(iter);
        }
      }
      iter=filter.getMemtableColumnIterator(getMemtableThreadSafe(),getComparator());
      if (iter != null) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
 else {
      iter=filter.getMemtableColumnIterator(getMemtableThreadSafe(),getComparator());
      if (iter != null) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
      for (      Memtable memtable : memtablesPendingFlush) {
        iter=filter.getMemtableColumnIterator(memtable,getComparator());
        if (iter != null) {
          returnCF.delete(iter.getColumnFamily());
          iterators.add(iter);
        }
      }
      for (      SSTableReader sstable : ssTables) {
        iter=filter.getSSTableColumnIterator(sstable);
        if (iter.getColumnFamily() != null) {
          returnCF.delete(iter.getColumnFamily());
          iterators.add(iter);
          sstablesToIterate++;
        }
      }
    }
    recentSSTablesPerRead.add(sstablesToIterate);
    sstablesPerRead.add(sstablesToIterate);
    Comparator<IColumn> comparator=filter.filter.getColumnComparator(getComparator());
    Iterator collated=IteratorUtils.collatedIterator(comparator,iterators);
    filter.collectCollatedColumns(returnCF,collated,gcBefore);
    return returnCF;
  }
 catch (  IOException e) {
    throw new IOError(e);
  }
 finally {
    for (    IColumnIterator ci : iterators) {
      try {
        ci.close();
      }
 catch (      Throwable th) {
        logger.error("error closing " + ci,th);
      }
    }
  }
}
