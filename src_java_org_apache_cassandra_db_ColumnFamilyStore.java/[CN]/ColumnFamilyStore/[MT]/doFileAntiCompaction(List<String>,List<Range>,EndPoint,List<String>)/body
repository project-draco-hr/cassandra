{
  boolean result=false;
  long startTime=System.currentTimeMillis();
  long totalBytesRead=0;
  long totalBytesWritten=0;
  long totalkeysRead=0;
  long totalkeysWritten=0;
  String rangeFileLocation;
  String mergedFileName;
  IPartitioner p=StorageService.getPartitioner();
  long expectedRangeFileSize=getExpectedCompactedFileSize(files);
  expectedRangeFileSize=expectedRangeFileSize / 2;
  rangeFileLocation=DatabaseDescriptor.getCompactionFileLocation(expectedRangeFileSize);
  if (rangeFileLocation == null) {
    logger_.warn("Total bytes to be written for range compaction  ..." + expectedRangeFileSize + "   is greater than the safe limit of the disk space available.");
    return result;
  }
  PriorityQueue<FileStruct> pq=initializePriorityQueue(files,ranges,ColumnFamilyStore.BUFSIZE);
  if (pq.isEmpty()) {
    return result;
  }
  mergedFileName=getTempSSTableFileName();
  SSTable ssTableRange=null;
  String lastkey=null;
  List<FileStruct> lfs=new ArrayList<FileStruct>();
  DataOutputBuffer bufOut=new DataOutputBuffer();
  int expectedBloomFilterSize=SSTable.getApproximateKeyCount(files);
  expectedBloomFilterSize=(expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();
  logger_.debug("Expected bloom filter size : " + expectedBloomFilterSize);
  List<ColumnFamily> columnFamilies=new ArrayList<ColumnFamily>();
  while (pq.size() > 0 || lfs.size() > 0) {
    FileStruct fs=null;
    if (pq.size() > 0) {
      fs=pq.poll();
    }
    if (fs != null && (lastkey == null || lastkey.equals(fs.getKey()))) {
      lastkey=fs.getKey();
      lfs.add(fs);
    }
 else {
      Collections.sort(lfs,new FileStructComparator());
      ColumnFamily columnFamily;
      bufOut.reset();
      if (lfs.size() > 1) {
        for (        FileStruct filestruct : lfs) {
          try {
            filestruct.getBufIn().readInt();
            IndexHelper.skipBloomFilterAndIndex(filestruct.getBufIn());
            if (columnFamilies.size() > 1) {
              merge(columnFamilies);
            }
            columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.getBufIn()));
          }
 catch (          Exception ex) {
            logger_.warn(LogUtil.throwableToString(ex));
          }
        }
        columnFamily=resolveAndRemoveDeleted(columnFamilies);
        columnFamilies.clear();
        if (columnFamily != null) {
          ColumnFamily.serializerWithIndexes().serialize(columnFamily,bufOut);
        }
      }
 else {
        FileStruct filestruct=lfs.get(0);
        int size=filestruct.getBufIn().readInt();
        bufOut.write(filestruct.getBufIn(),size);
      }
      if (Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(lastkey),ranges)) {
        if (ssTableRange == null) {
          if (target != null) {
            rangeFileLocation=rangeFileLocation + System.getProperty("file.separator") + "bootstrap";
          }
          FileUtils.createDirectory(rangeFileLocation);
          String fname=new File(rangeFileLocation,mergedFileName).getAbsolutePath();
          ssTableRange=new SSTable(fname,expectedBloomFilterSize,StorageService.getPartitioner());
        }
        try {
          ssTableRange.append(lastkey,bufOut);
        }
 catch (        Exception ex) {
          logger_.warn(LogUtil.throwableToString(ex));
        }
      }
      totalkeysWritten++;
      for (      FileStruct filestruct : lfs) {
        try {
          filestruct.advance();
          if (filestruct.isExhausted()) {
            continue;
          }
          while (!Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(filestruct.getKey()),ranges)) {
            filestruct.advance();
            if (filestruct.isExhausted()) {
              break;
            }
          }
          if (!filestruct.isExhausted()) {
            pq.add(filestruct);
          }
          totalkeysRead++;
        }
 catch (        Exception ex) {
          logger_.warn("corrupt sstable?",ex);
          filestruct.close();
        }
      }
      lfs.clear();
      lastkey=null;
      if (fs != null) {
        pq.add(fs);
      }
    }
  }
  if (ssTableRange != null) {
    ssTableRange.close();
    if (fileList != null) {
      fileList.add(ssTableRange.getFilename());
    }
  }
  logger_.debug("Total time taken for range split   ..." + (System.currentTimeMillis() - startTime));
  logger_.debug("Total bytes Read for range split  ..." + totalBytesRead);
  logger_.debug("Total bytes written for range split  ..." + totalBytesWritten + "   Total keys read ..."+ totalkeysRead);
  return result;
}
