{
  Keyspace.switchLock.writeLock().lock();
  try {
    final Future<ReplayPosition> ctx=writeCommitLog ? CommitLog.instance.getContext() : Futures.immediateFuture(ReplayPosition.NONE);
    final List<ColumnFamilyStore> icc=new ArrayList<ColumnFamilyStore>();
    for (    ColumnFamilyStore cfs : concatWithIndexes()) {
      if (forceSwitch || !cfs.getMemtableThreadSafe().isClean())       icc.add(cfs);
    }
    final CountDownLatch latch=new CountDownLatch(icc.size());
    for (    ColumnFamilyStore cfs : icc) {
      Memtable memtable=cfs.data.switchMemtable();
      if (memtable.isClean()) {
        cfs.replaceFlushed(memtable,null);
        latch.countDown();
      }
 else {
        logger.info("Enqueuing flush of {}",memtable);
        memtable.flushAndSignal(latch,ctx);
      }
    }
    if (metric.memtableSwitchCount.getCount() == Long.MAX_VALUE)     metric.resetMemTableSwitchCount();
    metric.memtableSwitchCount.inc();
    return postFlushExecutor.submit(new WrappedRunnable(){
      public void runMayThrow() throws InterruptedException, ExecutionException {
        latch.await();
        if (!icc.isEmpty()) {
          for (          SecondaryIndex index : indexManager.getIndexesNotBackedByCfs()) {
            logger.info("Flushing SecondaryIndex {}",index);
            index.forceBlockingFlush();
          }
        }
        if (writeCommitLog) {
          CommitLog.instance.discardCompletedSegments(metadata.cfId,ctx.get());
        }
      }
    }
);
  }
  finally {
    Keyspace.switchLock.writeLock().unlock();
  }
}
