{
  logger.trace("Filtering {} for rows matching {}",rowIterator,filter);
  List<Row> rows=new ArrayList<Row>();
  int columnsCount=0;
  int total=0, matched=0;
  try {
    while (rowIterator.hasNext() && rows.size() < filter.maxRows() && columnsCount < filter.maxColumns()) {
      Row rawRow=rowIterator.next();
      total++;
      ColumnFamily data=rawRow.cf;
      if (rowIterator.needsFiltering()) {
        IDiskAtomFilter extraFilter=filter.getExtraFilter(data);
        if (extraFilter != null) {
          QueryPath path=new QueryPath(columnFamily);
          ColumnFamily cf=filter.cfs.getColumnFamily(new QueryFilter(rawRow.key,path,extraFilter));
          if (cf != null)           data.addAll(cf,HeapAllocator.instance);
        }
        if (!filter.isSatisfiedBy(data,null))         continue;
        logger.trace("{} satisfies all filter expressions",data);
        data=filter.prune(data);
      }
      rows.add(new Row(rawRow.key,data));
      matched++;
      if (data != null)       columnsCount+=filter.lastCounted(data);
      filter.updateFilter(columnsCount);
    }
    return rows;
  }
  finally {
    try {
      rowIterator.close();
      Tracing.trace("Scanned {} rows and matched {}",total,matched);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
