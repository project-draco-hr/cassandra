{
  logger.trace("Filtering {} for rows matching {}",rowIterator,filter);
  List<Row> rows=new ArrayList<Row>();
  int columnsCount=0;
  int total=0, matched=0;
  boolean ignoreTombstonedPartitions=filter.ignoreTombstonedPartitions();
  try {
    while (rowIterator.hasNext() && matched < filter.maxRows() && columnsCount < filter.maxColumns()) {
      Row rawRow=rowIterator.next();
      total++;
      ColumnFamily data=rawRow.cf;
      if (rowIterator.needsFiltering()) {
        IDiskAtomFilter extraFilter=filter.getExtraFilter(rawRow.key,data);
        if (extraFilter != null) {
          ColumnFamily cf=filter.cfs.getColumnFamily(new QueryFilter(rawRow.key,name,extraFilter,filter.timestamp));
          if (cf != null)           data.addAll(cf);
        }
        removeDroppedColumns(data);
        if (!filter.isSatisfiedBy(rawRow.key,data,null,null))         continue;
        logger.trace("{} satisfies all filter expressions",data);
        data=filter.prune(rawRow.key,data);
      }
 else {
        removeDroppedColumns(data);
      }
      rows.add(new Row(rawRow.key,data));
      if (!ignoreTombstonedPartitions || !data.hasOnlyTombstones(filter.timestamp))       matched++;
      if (data != null)       columnsCount+=filter.lastCounted(data);
      filter.updateFilter(columnsCount);
    }
    return rows;
  }
  finally {
    try {
      rowIterator.close();
      Tracing.trace("Scanned {} rows and matched {}",total,matched);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
