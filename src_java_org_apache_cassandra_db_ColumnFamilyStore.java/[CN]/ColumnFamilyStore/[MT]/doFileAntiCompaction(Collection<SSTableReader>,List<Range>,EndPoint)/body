{
  logger_.info("AntiCompacting [" + StringUtils.join(sstables,",") + "]");
  long expectedRangeFileSize=getExpectedCompactedFileSize(sstables) / 2;
  String compactionFileLocation=DatabaseDescriptor.getDataFileLocationForTable(table_,expectedRangeFileSize);
  if (compactionFileLocation == null) {
    throw new UnsupportedOperationException("disk full");
  }
  List<SSTableReader> results=new ArrayList<SSTableReader>();
  long startTime=System.currentTimeMillis();
  long totalkeysWritten=0;
  int expectedBloomFilterSize=Math.max(SSTableReader.indexInterval(),SSTableReader.getApproximateKeyCount(sstables) / 2);
  if (logger_.isDebugEnabled())   logger_.debug("Expected bloom filter size : " + expectedBloomFilterSize);
  SSTableWriter writer=null;
  CompactionIterator ci=new CompactionIterator(sstables);
  try {
    if (!ci.hasNext()) {
      logger_.warn("Nothing to compact (all files empty or corrupt). This should not happen.");
      return results;
    }
    while (ci.hasNext()) {
      CompactionIterator.CompactedRow row=ci.next();
      if (Range.isTokenInRanges(row.key.token,ranges)) {
        if (writer == null) {
          if (target != null) {
            compactionFileLocation=compactionFileLocation + File.separator + "bootstrap";
          }
          FileUtils.createDirectory(compactionFileLocation);
          String newFilename=new File(compactionFileLocation,getTempSSTableFileName()).getAbsolutePath();
          writer=new SSTableWriter(newFilename,expectedBloomFilterSize,StorageService.getPartitioner());
        }
        writer.append(row.key,row.buffer);
        totalkeysWritten++;
      }
    }
  }
  finally {
    ci.close();
  }
  if (writer != null) {
    results.add(writer.closeAndOpenReader());
    String format="AntiCompacted to %s.  %d/%d bytes for %d keys.  Time: %dms.";
    long dTime=System.currentTimeMillis() - startTime;
    logger_.info(String.format(format,writer.getFilename(),getTotalBytes(sstables),results.get(0).length(),totalkeysWritten,dTime));
  }
  return results;
}
