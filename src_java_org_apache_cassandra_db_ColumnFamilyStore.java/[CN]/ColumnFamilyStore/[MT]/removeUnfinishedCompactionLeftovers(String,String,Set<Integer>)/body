{
  Directories directories=Directories.create(keyspace,columnfamily);
  Set<Integer> allGenerations=new HashSet<>();
  for (  Descriptor desc : directories.sstableLister().list().keySet())   allGenerations.add(desc.generation);
  if (!allGenerations.containsAll(unfinishedGenerations)) {
    throw new IllegalStateException("Unfinished compactions reference missing sstables." + " This should never happen since compactions are marked finished before we start removing the old sstables.");
  }
  Set<Integer> completedAncestors=new HashSet<>();
  for (  Map.Entry<Descriptor,Set<Component>> sstableFiles : directories.sstableLister().list().entrySet()) {
    Descriptor desc=sstableFiles.getKey();
    Set<Component> components=sstableFiles.getValue();
    Set<Integer> ancestors;
    try {
      CompactionMetadata compactionMetadata=(CompactionMetadata)desc.getMetadataSerializer().deserialize(desc,MetadataType.COMPACTION);
      ancestors=compactionMetadata.ancestors;
    }
 catch (    IOException e) {
      throw new FSReadError(e,desc.filenameFor(Component.STATS));
    }
    if (!ancestors.isEmpty() && unfinishedGenerations.containsAll(ancestors)) {
      SSTable.delete(desc,components);
    }
 else {
      completedAncestors.addAll(ancestors);
    }
  }
  for (  Map.Entry<Descriptor,Set<Component>> sstableFiles : directories.sstableLister().list().entrySet()) {
    Descriptor desc=sstableFiles.getKey();
    Set<Component> components=sstableFiles.getValue();
    if (completedAncestors.contains(desc.generation))     SSTable.delete(desc,components);
  }
}
