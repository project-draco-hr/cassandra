{
  logger.trace("truncating {}",name);
  final long truncatedAt;
  final ReplayPosition replayAfter;
  if (keyspace.getMetadata().durableWrites || takeSnapshot) {
    replayAfter=forceBlockingFlush();
  }
 else {
    Future<ReplayPosition> replayAfterFuture;
synchronized (data) {
      final Flush flush=new Flush(true);
      flushExecutor.execute(flush);
      replayAfterFuture=postFlushExecutor.submit(flush.postFlush);
    }
    replayAfter=FBUtilities.waitOnFuture(replayAfterFuture);
  }
  long now=System.currentTimeMillis();
  for (  ColumnFamilyStore cfs : concatWithIndexes())   for (  SSTableReader sstable : cfs.data.getSSTables())   now=Math.max(now,sstable.maxDataAge);
  truncatedAt=now;
  Runnable truncateRunnable=new Runnable(){
    public void run(){
      logger.debug("Discarding sstable data for truncated CF + indexes");
      data.notifyTruncated(truncatedAt);
      if (takeSnapshot)       snapshot(Keyspace.getTimestampedSnapshotName(name));
      discardSSTables(truncatedAt);
      for (      SecondaryIndex index : indexManager.getIndexes())       index.truncateBlocking(truncatedAt);
      SystemKeyspace.saveTruncationRecord(ColumnFamilyStore.this,truncatedAt,replayAfter);
      logger.trace("cleaning out row cache");
      invalidateCaches();
    }
  }
;
  runWithCompactionsDisabled(Executors.callable(truncateRunnable),true);
  logger.trace("truncate complete");
}
