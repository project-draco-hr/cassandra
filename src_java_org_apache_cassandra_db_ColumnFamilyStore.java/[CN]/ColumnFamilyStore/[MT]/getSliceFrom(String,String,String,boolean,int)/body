{
  lock_.readLock().lock();
  List<ColumnIterator> iterators=new ArrayList<ColumnIterator>();
  try {
    final ColumnFamily returnCF;
    ColumnIterator iter;
    memtableLock_.readLock().lock();
    try {
      iter=memtable_.getColumnIterator(key,cfName,isAscending,startColumn);
      returnCF=iter.getColumnFamily();
    }
  finally {
      memtableLock_.readLock().unlock();
    }
    iterators.add(iter);
    List<Memtable> memtables=getUnflushedMemtables(cfName);
    for (    Memtable memtable : memtables) {
      iter=memtable.getColumnIterator(key,cfName,isAscending,startColumn);
      returnCF.delete(iter.getColumnFamily());
      iterators.add(iter);
    }
    List<String> files=new ArrayList<String>(ssTables_);
    for (    String file : files) {
      if (!SSTable.isKeyInFile(key,file))       continue;
      iter=new SSTableColumnIterator(file,key,cfName,startColumn,isAscending);
      if (iter.hasNext()) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
    Comparator<IColumn> comparator=new Comparator<IColumn>(){
      public int compare(      IColumn c1,      IColumn c2){
        return c1.name().compareTo(c2.name());
      }
    }
;
    if (!isAscending)     comparator=new ReverseComparator(comparator);
    Iterator collated=IteratorUtils.collatedIterator(comparator,iterators);
    if (!collated.hasNext())     return new ColumnFamily(cfName,DatabaseDescriptor.getColumnFamilyType(cfName));
    ReducingIterator<IColumn> reduced=new ReducingIterator<IColumn>(collated){
      ColumnFamily curCF=returnCF.cloneMeShallow();
      protected Object getKey(      IColumn o){
        return o == null ? null : o.name();
      }
      public void reduce(      IColumn current){
        curCF.addColumn(current);
      }
      protected IColumn getReduced(){
        IColumn c=curCF.getAllColumns().first();
        curCF.clear();
        return c;
      }
    }
;
    int liveColumns=0;
    for (    IColumn column : reduced) {
      if (liveColumns >= count) {
        break;
      }
      if (!column.isMarkedForDelete())       liveColumns++;
      returnCF.addColumn(column);
    }
    return removeDeleted(returnCF);
  }
  finally {
    for (    ColumnIterator ci : iterators) {
      try {
        ci.close();
      }
 catch (      Throwable th) {
        logger_.error(th);
      }
    }
    lock_.readLock().unlock();
  }
}
