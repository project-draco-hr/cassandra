{
  if (oldMemtable.isPendingFlush())   return null;
  if (DatabaseDescriptor.getCFMetaData(metadata.cfId) == null)   return null;
  if (!oldMemtable.markPendingFlush())   return null;
  Table.flusherLock.lock();
  try {
    final CommitLogSegment.CommitLogContext ctx=writeCommitLog ? CommitLog.instance.getContext() : null;
    logger.info("switching in a fresh Memtable for " + columnFamily + " at "+ ctx);
    List<ColumnFamilyStore> icc=new ArrayList<ColumnFamilyStore>(indexedColumns.size());
    icc.add(this);
    for (    ColumnFamilyStore indexCfs : indexedColumns.values()) {
      if (!indexCfs.memtable.isClean())       icc.add(indexCfs);
    }
    final CountDownLatch latch=new CountDownLatch(icc.size());
    for (    ColumnFamilyStore cfs : icc) {
      if (!reverseReadWriteOrder()) {
        submitFlush(cfs.memtable,latch);
        cfs.memtable=new Memtable(cfs);
      }
 else {
        Memtable pendingFlush=cfs.memtable;
        cfs.memtable=new Memtable(cfs);
        submitFlush(pendingFlush,latch);
      }
    }
    return postFlushExecutor.submit(new WrappedRunnable(){
      public void runMayThrow() throws InterruptedException, IOException {
        latch.await();
        if (writeCommitLog) {
          CommitLog.instance.discardCompletedSegments(metadata.cfId,ctx);
        }
      }
    }
);
  }
  finally {
    Table.flusherLock.unlock();
    if (memtableSwitchCount == Integer.MAX_VALUE) {
      memtableSwitchCount=0;
    }
    memtableSwitchCount++;
  }
}
