{
  table_=table;
  columnFamily_=columnFamilyName;
  isSuper_=isSuper;
  fileIndexGenerator_.set(indexValue);
  memtable_=new Memtable(table_,columnFamily_);
  binaryMemtable_=new AtomicReference<BinaryMemtable>(new BinaryMemtable(table_,columnFamily_));
  if (logger_.isDebugEnabled())   logger_.debug("Starting CFS " + columnFamily_);
  List<File> sstableFiles=new ArrayList<File>();
  Pattern auxFilePattern=Pattern.compile("(.*)(-Filter\\.db$|-Index\\.db$)");
  for (  File file : files()) {
    String filename=file.getName();
    Matcher matcher=auxFilePattern.matcher(file.getAbsolutePath());
    if (matcher.matches()) {
      String basePath=matcher.group(1);
      if (!new File(basePath + "-Data.db").exists()) {
        logger_.info(String.format("Removing orphan %s",file.getAbsolutePath()));
        FileUtils.deleteWithConfirm(file);
        continue;
      }
    }
    if (((file.length() == 0 && !filename.endsWith("-Compacted")) || (filename.contains("-" + SSTable.TEMPFILE_MARKER)))) {
      FileUtils.deleteWithConfirm(file);
      continue;
    }
    if (filename.contains("-Data.db")) {
      sstableFiles.add(file.getAbsoluteFile());
    }
  }
  Collections.sort(sstableFiles,new FileUtils.FileComparator());
  List<SSTableReader> sstables=new ArrayList<SSTableReader>();
  for (  File file : sstableFiles) {
    String filename=file.getAbsolutePath();
    if (SSTable.deleteIfCompacted(filename))     continue;
    SSTableReader sstable;
    try {
      sstable=SSTableReader.open(filename);
    }
 catch (    IOException ex) {
      logger_.error("Corrupt file " + filename + "; skipped",ex);
      continue;
    }
    sstables.add(sstable);
  }
  ssTables_=new SSTableTracker(sstables);
  double v=DatabaseDescriptor.getRowsCachedFraction(table,columnFamilyName);
  int cacheSize;
  if (0 < v && v < 1)   cacheSize=Math.max(1,(int)(v * ssTables_.estimatedKeys()));
 else   cacheSize=(int)v;
  if (logger_.isDebugEnabled())   logger_.debug("row cache capacity for " + columnFamilyName + " is "+ cacheSize);
  rowCache=new JMXInstrumentedCache<String,ColumnFamily>(table,columnFamilyName + "RowCache",cacheSize);
  new JMXAggregatingCache(new Iterable<IAggregatableCacheProvider>(){
    public Iterator<IAggregatableCacheProvider> iterator(){
      final Iterator<SSTableReader> iter=ssTables_.iterator();
      return new AbstractIterator<IAggregatableCacheProvider>(){
        @Override protected IAggregatableCacheProvider computeNext(){
          if (!iter.hasNext())           return endOfData();
          return new IAggregatableCacheProvider(){
            SSTableReader sstable=iter.next();
            public InstrumentedCache getCache(){
              return sstable.getKeyCache();
            }
            public long getObjectCount(){
              return sstable.getIndexPositions().size() * SSTableReader.indexInterval();
            }
          }
;
        }
      }
;
    }
  }
,table,columnFamilyName + "KeyCache");
}
