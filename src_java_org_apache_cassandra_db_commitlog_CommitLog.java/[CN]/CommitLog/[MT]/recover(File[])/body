{
  Set<Table> tablesRecovered=new HashSet<Table>();
  final AtomicInteger counter=new AtomicInteger(0);
  for (  File file : clogs) {
    CommitLogHeader clHeader=null;
    int bufferSize=(int)Math.min(file.length(),32 * 1024 * 1024);
    BufferedRandomAccessFile reader=new BufferedRandomAccessFile(file.getAbsolutePath(),"r",bufferSize);
    int replayPosition=0;
    try {
      clHeader=CommitLogHeader.readCommitLogHeader(CommitLogHeader.getHeaderPathFromSegmentPath(file.getAbsolutePath()));
      replayPosition=clHeader.getReplayPosition();
    }
 catch (    IOException ioe) {
      logger.info("Attempted to read an incomplete, missing or corrupt CommitLogHeader.  Everything is ok, don't panic.  CommitLog will be replayed from the beginning",ioe);
    }
    reader.seek(replayPosition);
    if (logger.isDebugEnabled())     logger.debug("Replaying " + file + " starting at "+ reader.getFilePointer());
    while (!reader.isEOF()) {
      if (logger.isDebugEnabled())       logger.debug("Reading mutation at " + reader.getFilePointer());
      long claimedCRC32;
      byte[] bytes;
      Checksum checksum=new CRC32();
      try {
        int size=reader.readInt();
        long claimedSizeChecksum=reader.readLong();
        checksum.update(size);
        if (checksum.getValue() != claimedSizeChecksum || size <= 0)         break;
        bytes=new byte[size];
        reader.readFully(bytes);
        claimedCRC32=reader.readLong();
      }
 catch (      EOFException eof) {
        break;
      }
      checksum.update(bytes,0,bytes.length);
      if (claimedCRC32 != checksum.getValue()) {
        continue;
      }
      ByteArrayInputStream bufIn=new ByteArrayInputStream(bytes);
      final RowMutation rm=RowMutation.serializer().deserialize(new DataInputStream(bufIn));
      if (logger.isDebugEnabled())       logger.debug(String.format("replaying mutation for %s.%s: %s",rm.getTable(),rm.key(),"{" + StringUtils.join(rm.getColumnFamilies(),", ") + "}"));
      final Table table=Table.open(rm.getTable());
      tablesRecovered.add(table);
      final Collection<ColumnFamily> columnFamilies=new ArrayList<ColumnFamily>(rm.getColumnFamilies());
      final long entryLocation=reader.getFilePointer();
      final CommitLogHeader finalHeader=clHeader;
      Runnable runnable=new WrappedRunnable(){
        public void runMayThrow() throws IOException {
          RowMutation newRm=new RowMutation(rm.getTable(),rm.key());
          for (          ColumnFamily columnFamily : columnFamilies) {
            if (CFMetaData.getCF(columnFamily.id()) == null)             continue;
            if (finalHeader == null || (finalHeader.isDirty(columnFamily.id()) && entryLocation >= finalHeader.getPosition(columnFamily.id())))             newRm.add(columnFamily);
          }
          if (!newRm.isEmpty()) {
            Table.open(newRm.getTable()).apply(newRm,null,false);
          }
          counter.decrementAndGet();
        }
      }
;
      counter.incrementAndGet();
      StageManager.getStage(StageManager.MUTATION_STAGE).submit(runnable);
    }
    reader.close();
  }
  while (counter.get() > 0) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      throw new AssertionError(e);
    }
  }
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (  Table table : tablesRecovered) {
    futures.addAll(table.flush());
  }
  for (  Future<?> future : futures) {
    try {
      future.get();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}
