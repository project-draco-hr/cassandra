{
  Set<Table> tablesRecovered=new HashSet<Table>();
  final AtomicInteger counter=new AtomicInteger(0);
  for (  File file : clogs) {
    int bufferSize=(int)Math.min(file.length(),32 * 1024 * 1024);
    BufferedRandomAccessFile reader=new BufferedRandomAccessFile(file.getAbsolutePath(),"r",bufferSize);
    final CommitLogHeader clHeader;
    try {
      clHeader=CommitLogHeader.readCommitLogHeader(reader);
    }
 catch (    EOFException eofe) {
      logger.info("Attempted to recover an incomplete CommitLogHeader.  Everything is ok, don't panic.");
      continue;
    }
    int lowPos=CommitLogHeader.getLowestPosition(clHeader);
    if (lowPos == 0)     break;
    reader.seek(lowPos);
    if (logger.isDebugEnabled())     logger.debug("Replaying " + file + " starting at "+ lowPos);
    while (!reader.isEOF()) {
      if (logger.isDebugEnabled())       logger.debug("Reading mutation at " + reader.getFilePointer());
      long claimedCRC32;
      byte[] bytes;
      try {
        bytes=new byte[reader.readInt()];
        reader.readFully(bytes);
        claimedCRC32=reader.readLong();
      }
 catch (      EOFException e) {
        break;
      }
      ByteArrayInputStream bufIn=new ByteArrayInputStream(bytes);
      Checksum checksum=new CRC32();
      checksum.update(bytes,0,bytes.length);
      if (claimedCRC32 != checksum.getValue()) {
        continue;
      }
      final RowMutation rm=RowMutation.serializer().deserialize(new DataInputStream(bufIn));
      if (logger.isDebugEnabled())       logger.debug(String.format("replaying mutation for %s.%s: %s",rm.getTable(),rm.key(),"{" + StringUtils.join(rm.getColumnFamilies(),", ") + "}"));
      final Table table=Table.open(rm.getTable());
      tablesRecovered.add(table);
      final Collection<ColumnFamily> columnFamilies=new ArrayList<ColumnFamily>(rm.getColumnFamilies());
      final long entryLocation=reader.getFilePointer();
      Runnable runnable=new WrappedRunnable(){
        public void runMayThrow() throws IOException {
          RowMutation newRm=new RowMutation(rm.getTable(),rm.key());
          for (          ColumnFamily columnFamily : columnFamilies) {
            if (CFMetaData.getCF(columnFamily.id()) == null)             continue;
            if (clHeader.isDirty(columnFamily.id()) && entryLocation >= clHeader.getPosition(columnFamily.id()))             newRm.add(columnFamily);
          }
          if (!newRm.isEmpty()) {
            Table.open(newRm.getTable()).apply(newRm,null,false);
          }
          counter.decrementAndGet();
        }
      }
;
      counter.incrementAndGet();
      StageManager.getStage(StageManager.MUTATION_STAGE).submit(runnable);
    }
    reader.close();
  }
  while (counter.get() > 0) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      throw new AssertionError(e);
    }
  }
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (  Table table : tablesRecovered) {
    futures.addAll(table.flush());
  }
  for (  Future<?> future : futures) {
    try {
      future.get();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}
