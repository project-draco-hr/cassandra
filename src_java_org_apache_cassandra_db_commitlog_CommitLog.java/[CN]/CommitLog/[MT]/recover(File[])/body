{
  Set<Table> tablesRecovered=new HashSet<Table>();
  List<Future<?>> futures=new ArrayList<Future<?>>();
  byte[] bytes=new byte[4096];
  for (  File file : clogs) {
    CommitLogHeader clHeader=null;
    int bufferSize=(int)Math.min(file.length(),32 * 1024 * 1024);
    BufferedRandomAccessFile reader=new BufferedRandomAccessFile(file.getAbsolutePath(),"r",bufferSize);
    int replayPosition=0;
    String headerPath=CommitLogHeader.getHeaderPathFromSegmentPath(file.getAbsolutePath());
    try {
      clHeader=CommitLogHeader.readCommitLogHeader(headerPath);
      replayPosition=clHeader.getReplayPosition();
    }
 catch (    IOException ioe) {
      logger.info(headerPath + " incomplete, missing or corrupt.  Everything is ok, don't panic.  CommitLog will be replayed from the beginning");
      logger.debug("exception was",ioe);
    }
    if (replayPosition < 0) {
      logger.debug("skipping replay of fully-flushed {}",file);
      continue;
    }
    reader.seek(replayPosition);
    if (logger.isDebugEnabled())     logger.debug("Replaying " + file + " starting at "+ reader.getFilePointer());
    while (!reader.isEOF()) {
      if (logger.isDebugEnabled())       logger.debug("Reading mutation at " + reader.getFilePointer());
      long claimedCRC32;
      Checksum checksum=new CRC32();
      int serializedSize;
      try {
        serializedSize=reader.readInt();
        long claimedSizeChecksum=reader.readLong();
        checksum.update(serializedSize);
        if (checksum.getValue() != claimedSizeChecksum || serializedSize <= 0)         break;
        if (serializedSize > bytes.length)         bytes=new byte[(int)(1.2 * serializedSize)];
        reader.readFully(bytes,0,serializedSize);
        claimedCRC32=reader.readLong();
      }
 catch (      EOFException eof) {
        break;
      }
      checksum.update(bytes,0,serializedSize);
      if (claimedCRC32 != checksum.getValue()) {
        continue;
      }
      ByteArrayInputStream bufIn=new ByteArrayInputStream(bytes,0,serializedSize);
      final RowMutation rm=RowMutation.serializer().deserialize(new DataInputStream(bufIn));
      if (logger.isDebugEnabled())       logger.debug(String.format("replaying mutation for %s.%s: %s",rm.getTable(),rm.key(),"{" + StringUtils.join(rm.getColumnFamilies(),", ") + "}"));
      final Table table=Table.open(rm.getTable());
      tablesRecovered.add(table);
      final Collection<ColumnFamily> columnFamilies=new ArrayList<ColumnFamily>(rm.getColumnFamilies());
      final long entryLocation=reader.getFilePointer();
      final CommitLogHeader finalHeader=clHeader;
      Runnable runnable=new WrappedRunnable(){
        public void runMayThrow() throws IOException {
          RowMutation newRm=new RowMutation(rm.getTable(),rm.key());
          for (          ColumnFamily columnFamily : columnFamilies) {
            if (CFMetaData.getCF(columnFamily.id()) == null)             continue;
            if (finalHeader == null || (finalHeader.isDirty(columnFamily.id()) && entryLocation >= finalHeader.getPosition(columnFamily.id())))             newRm.add(columnFamily);
          }
          if (!newRm.isEmpty()) {
            Table.open(newRm.getTable()).apply(newRm,null,false);
          }
        }
      }
;
      futures.add(StageManager.getStage(StageManager.MUTATION_STAGE).submit(runnable));
      if (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT) {
        FBUtilities.waitOnFutures(futures);
        futures.clear();
      }
    }
    reader.close();
    logger.info("Finished reading " + file + " for recovery");
  }
  FBUtilities.waitOnFutures(futures);
  logger.debug("Finished waiting on mutations from recovery");
  futures.clear();
  for (  Table table : tablesRecovered)   futures.addAll(table.flush());
  FBUtilities.waitOnFutures(futures);
  logger.info("Recovery complete");
}
