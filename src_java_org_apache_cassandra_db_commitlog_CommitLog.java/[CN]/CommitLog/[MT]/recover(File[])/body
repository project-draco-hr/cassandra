{
  Set<Table> tablesRecovered=new HashSet<Table>();
  final AtomicInteger counter=new AtomicInteger(0);
  byte[] bytes=new byte[4096];
  for (  File file : clogs) {
    CommitLogHeader clHeader=null;
    int bufferSize=(int)Math.min(file.length(),32 * 1024 * 1024);
    BufferedRandomAccessFile reader=new BufferedRandomAccessFile(file.getAbsolutePath(),"r",bufferSize);
    int replayPosition=0;
    String headerPath=CommitLogHeader.getHeaderPathFromSegmentPath(file.getAbsolutePath());
    try {
      clHeader=CommitLogHeader.readCommitLogHeader(headerPath);
      replayPosition=clHeader.getReplayPosition();
    }
 catch (    IOException ioe) {
      logger.info(headerPath + " incomplete, missing or corrupt.  Everything is ok, don't panic.  CommitLog will be replayed from the beginning");
      logger.debug("exception was",ioe);
    }
    reader.seek(replayPosition);
    if (logger.isDebugEnabled())     logger.debug("Replaying " + file + " starting at "+ reader.getFilePointer());
    while (!reader.isEOF()) {
      if (logger.isDebugEnabled())       logger.debug("Reading mutation at " + reader.getFilePointer());
      long claimedCRC32;
      Checksum checksum=new CRC32();
      int serializedSize;
      try {
        serializedSize=reader.readInt();
        long claimedSizeChecksum=reader.readLong();
        checksum.update(serializedSize);
        if (checksum.getValue() != claimedSizeChecksum || serializedSize <= 0)         break;
        if (serializedSize > bytes.length)         bytes=new byte[(int)(1.2 * serializedSize)];
        reader.readFully(bytes,0,serializedSize);
        claimedCRC32=reader.readLong();
      }
 catch (      EOFException eof) {
        break;
      }
      checksum.update(bytes,0,serializedSize);
      if (claimedCRC32 != checksum.getValue()) {
        continue;
      }
      ByteArrayInputStream bufIn=new ByteArrayInputStream(bytes,0,serializedSize);
      final RowMutation rm=RowMutation.serializer().deserialize(new DataInputStream(bufIn));
      if (logger.isDebugEnabled())       logger.debug(String.format("replaying mutation for %s.%s: %s",rm.getTable(),rm.key(),"{" + StringUtils.join(rm.getColumnFamilies(),", ") + "}"));
      final Table table=Table.open(rm.getTable());
      tablesRecovered.add(table);
      final Collection<ColumnFamily> columnFamilies=new ArrayList<ColumnFamily>(rm.getColumnFamilies());
      final long entryLocation=reader.getFilePointer();
      final CommitLogHeader finalHeader=clHeader;
      Runnable runnable=new WrappedRunnable(){
        public void runMayThrow() throws IOException {
          RowMutation newRm=new RowMutation(rm.getTable(),rm.key());
          for (          ColumnFamily columnFamily : columnFamilies) {
            if (CFMetaData.getCF(columnFamily.id()) == null)             continue;
            if (finalHeader == null || (finalHeader.isDirty(columnFamily.id()) && entryLocation >= finalHeader.getPosition(columnFamily.id())))             newRm.add(columnFamily);
          }
          if (!newRm.isEmpty()) {
            Table.open(newRm.getTable()).apply(newRm,null,false);
          }
          counter.decrementAndGet();
        }
      }
;
      counter.incrementAndGet();
      StageManager.getStage(StageManager.MUTATION_STAGE).submit(runnable);
    }
    reader.close();
    logger.info("Finished reading " + file);
  }
  while (counter.get() > 0) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      throw new AssertionError(e);
    }
  }
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (  Table table : tablesRecovered) {
    futures.addAll(table.flush());
  }
  for (  Future<?> future : futures) {
    try {
      future.get();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}
