def run(self):
    begin = self.range[0]
    end = self.range[(-1)]
    current = begin
    last = (current + options.rangecount)
    fmt = (('%0' + str(len(str(total_keys)))) + 'd')
    p = {'slice_range': {'start': '', 'finish': '', 'reversed': False, 'count': columns_per_key, }, }
    if ('super' == options.cftype):
        while (current < end):
            keyrange = {'start_key': (fmt % current), 'end_key': (fmt % last), 'count': options.rangecount, }
            res = []
            for j in xrange(supers_per_key):
                parent = {'column_family': 'Super1', 'super_column': ('S' + str(j)), }
                begin = time.time()
                try:
                    res = self.cclient.request('get_range_slices', {'column_parent': parent, 'predicate': p, 'range': keyrange, 'consistency_level': consistency, })
                    if (not res):
                        raise RuntimeError(('Key %s not found' % key))
                except KeyboardInterrupt:
                    raise
                except Exception as e:
                    if options.ignore:
                        print e
                    else:
                        raise
                self.latencies[self.idx] += (time.time() - begin)
                self.opcounts[self.idx] += 1
            current += (len(r) + 1)
            last = ((current + len(r)) + 1)
            self.keycounts[self.idx] += len(r)
    else:
        parent = {'column_family': 'Standard1', }
        while (current < end):
            start = (fmt % current)
            finish = (fmt % last)
            keyrange = {'start_key': start, 'end_key': finish, 'count': options.rangecount, }
            begin = time.time()
            try:
                r = self.cclient.request('get_range_slices', {'column_parent': parent, 'predicate': p, 'range': keyrange, 'consistency_level': consistency, })
                if (not r):
                    raise RuntimeError('Range not found:', start, finish)
            except KeyboardInterrupt:
                raise
            except Exception as e:
                if options.ignore:
                    print e
                else:
                    print start, finish
                    raise
            current += (len(r) + 1)
            last = ((current + len(r)) + 1)
            self.latencies[self.idx] += (time.time() - begin)
            self.opcounts[self.idx] += 1
            self.keycounts[self.idx] += len(r)
