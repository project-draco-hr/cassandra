{
  logger.debug("In maybeRecover with Descriptor {}",desc);
  File ifile=new File(desc.filenameFor(SSTable.COMPONENT_INDEX));
  File ffile=new File(desc.filenameFor(SSTable.COMPONENT_FILTER));
  if (ifile.exists() && ffile.exists())   return;
  ColumnFamilyStore cfs=Table.open(desc.ksname).getColumnFamilyStore(desc.cfname);
  Set<byte[]> indexedColumns=cfs.getIndexedColumns();
  ifile.delete();
  ffile.delete();
  BufferedRandomAccessFile dfile=new BufferedRandomAccessFile(desc.filenameFor(SSTable.COMPONENT_DATA),"r",8 * 1024 * 1024);
  IndexWriter iwriter;
  long estimatedRows;
  try {
    estimatedRows=estimateRows(desc,dfile);
    iwriter=new IndexWriter(desc,StorageService.getPartitioner(),estimatedRows);
  }
 catch (  IOException e) {
    dfile.close();
    throw e;
  }
  long rows=0;
  try {
    DecoratedKey key;
    long dataPosition=0;
    while (dataPosition < dfile.length()) {
      key=SSTableReader.decodeKey(StorageService.getPartitioner(),desc,FBUtilities.readShortByteArray(dfile));
      long dataSize=SSTableReader.readRowSize(dfile,desc);
      if (!indexedColumns.isEmpty()) {
        dfile.readFully(new byte[dfile.readInt()]);
        dfile.readFully(new byte[dfile.readInt()]);
        ColumnFamily cf=ColumnFamily.create(desc.ksname,desc.cfname);
        ColumnFamily.serializer().deserializeFromSSTableNoColumns(cf,dfile);
        int columns=dfile.readInt();
        for (int i=0; i < columns; i++) {
          IColumn iColumn=cf.getColumnSerializer().deserialize(dfile);
          if (indexedColumns.contains(iColumn.name())) {
            DecoratedKey valueKey=cfs.getIndexKeyFor(iColumn.name(),iColumn.value());
            ColumnFamily indexedCf=cfs.newIndexedColumnFamily(iColumn.name());
            indexedCf.addColumn(new Column(key.key,ArrayUtils.EMPTY_BYTE_ARRAY,iColumn.clock()));
            logger.debug("adding indexed column row mutation for key {}",valueKey);
            Table.open(desc.ksname).applyIndexedCF(cfs.getIndexedColumnFamilyStore(iColumn.name()),key,valueKey,indexedCf);
          }
        }
      }
      iwriter.afterAppend(key,dataPosition);
      dataPosition=dfile.getFilePointer() + dataSize;
      dfile.seek(dataPosition);
      rows++;
    }
    for (    byte[] column : cfs.getIndexedColumns()) {
      try {
        cfs.getIndexedColumnFamilyStore(column).forceBlockingFlush();
      }
 catch (      ExecutionException e) {
        throw new RuntimeException(e);
      }
catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
  finally {
    try {
      dfile.close();
      iwriter.close();
    }
 catch (    IOException e) {
      logger.error("Failed to close data or index file during recovery of " + desc,e);
    }
  }
  logger.debug("estimated row count was %s of real count",((double)estimatedRows) / rows);
}
