{
  final List<IndexHelper.IndexInfo> indexes=indexEntry.columnsIndex();
  if (currentIndexIdx >= indexes.size())   return Collections.emptyIterator();
  final int startIdx=IndexHelper.indexFor(slice.start(),indexes,sstable.metadata.comparator,false,currentIndexIdx);
  if (startIdx >= indexes.size())   return Collections.emptyIterator();
  if (startIdx != currentIndexIdx)   updateBlock(startIdx);
  final int endIdx=IndexHelper.indexFor(slice.end(),indexes,sstable.metadata.comparator,false,startIdx);
  final IndexHelper.IndexInfo startIndex=currentIndex();
  if (startIdx == endIdx && metadata().comparator.compare(slice.end(),startIndex.firstName) < 0 && openMarker == null && sstable.descriptor.version.storeRows())   return Collections.emptyIterator();
  return new AbstractIterator<Unfiltered>(){
    private boolean beforeStart=true;
    private int currentIndexIdx=startIdx;
    protected Unfiltered computeNext(){
      try {
        if (beforeStart) {
          while (deserializer.hasNext() && deserializer.compareNextTo(slice.start()) <= 0) {
            if (deserializer.nextIsRow())             deserializer.skipNext();
 else             updateOpenMarker((RangeTombstoneMarker)deserializer.readNext());
          }
          beforeStart=false;
          if (openMarker != null)           return new RangeTombstoneBoundMarker(slice.start(),openMarker);
        }
        if (currentIndexIdx < indexes.size() && file.bytesPastMark(mark) >= currentIndex().width)         updateBlock(++currentIndexIdx);
        if (currentIndexIdx < indexes.size() && currentIndexIdx <= endIdx && deserializer.hasNext() && (currentIndexIdx != endIdx || deserializer.compareNextTo(slice.end()) <= 0)) {
          Unfiltered next=deserializer.readNext();
          if (next.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)           updateOpenMarker((RangeTombstoneMarker)next);
          return next;
        }
        if (openMarker != null)         return new RangeTombstoneBoundMarker(slice.end(),getAndClearOpenMarker());
        return endOfData();
      }
 catch (      IOException e) {
        try {
          close();
        }
 catch (        IOException suppressed) {
          e.addSuppressed(suppressed);
        }
        sstable.markSuspect();
        throw new CorruptSSTableException(e,file.getPath());
      }
    }
  }
;
}
