{
  String ksname=KEYSPACE1;
  String cfname=CF_STANDARDLOWiINTERVAL;
  Keyspace keyspace=Keyspace.open(ksname);
  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(cfname);
  cfs.truncateBlocking();
  cfs.disableAutoCompaction();
  ByteBuffer value=ByteBuffer.wrap(new byte[100]);
  int numRows=256;
  for (int row=0; row < numRows; row++) {
    DecoratedKey key=Util.dk(String.valueOf(row));
    Mutation rm=new Mutation(ksname,key.getKey());
    rm.add(cfname,Util.cellname("column"),value,0);
    rm.applyUnsafe();
  }
  cfs.forceBlockingFlush();
  List<SSTableReader> sstables=new ArrayList<>(cfs.getSSTables());
  assertEquals(1,sstables.size());
  SSTableReader original=sstables.get(0);
  SSTableReader sstable=original;
  for (int samplingLevel=1; samplingLevel < BASE_SAMPLING_LEVEL; samplingLevel++) {
    sstable=sstable.cloneWithNewSummarySamplingLevel(cfs,samplingLevel);
    assertEquals(samplingLevel,sstable.getIndexSummarySamplingLevel());
    int expectedSize=(numRows * samplingLevel) / (sstable.metadata.getMinIndexInterval() * BASE_SAMPLING_LEVEL);
    assertEquals(expectedSize,sstable.getIndexSummarySize(),1);
  }
  cfs.getDataTracker().replaceReaders(Collections.singleton(original),Collections.singleton(sstable),true);
}
