{
  String format="%0" + session.getTotalKeysLength() + "d";
  int current=range.begins();
  int limit=range.limit();
  int count=session.getColumnsPerKey();
  int last=current + session.getKeysPerCall();
  SlicePredicate predicate=new SlicePredicate().setSlice_range(new SliceRange(ByteBuffer.wrap(new byte[]{}),ByteBuffer.wrap(new byte[]{}),false,count));
  if (session.getColumnFamilyType() == ColumnFamilyType.Super) {
    while (current < limit) {
      byte[] start=String.format(format,current).getBytes();
      byte[] end=String.format(format,last).getBytes();
      List<KeySlice> slices=new ArrayList<KeySlice>();
      KeyRange range=new KeyRange(count).setStart_key(start).setEnd_key(end);
      for (int i=0; i < session.getSuperColumns(); i++) {
        String superColumnName="S" + Integer.toString(i);
        ColumnParent parent=new ColumnParent("Super1").setSuper_column(ByteBuffer.wrap(superColumnName.getBytes()));
        long startTime=System.currentTimeMillis();
        boolean success=false;
        String exceptionMessage=null;
        for (int t=0; t < session.getRetryTimes(); t++) {
          try {
            slices=client.get_range_slices(parent,predicate,range,session.getConsistencyLevel());
            success=(slices.size() != 0);
          }
 catch (          Exception e) {
            exceptionMessage=getExceptionMessage(e);
            success=false;
          }
        }
        if (!success) {
          System.err.printf("Thread [%d] retried %d times - error on calling get_range_slices for range %s->%s %s%n",index,session.getRetryTimes(),new String(start),new String(end),(exceptionMessage == null) ? "" : "(" + exceptionMessage + ")");
          if (!session.ignoreErrors())           return;
        }
        session.operationCount.getAndIncrement(index);
        session.latencies.getAndAdd(index,System.currentTimeMillis() - startTime);
      }
      current+=slices.size() + 1;
      last=current + slices.size() + 1;
      session.keyCount.getAndAdd(index,slices.size());
    }
  }
 else {
    ColumnParent parent=new ColumnParent("Standard1");
    while (current < limit) {
      byte[] start=String.format(format,current).getBytes();
      byte[] end=String.format(format,last).getBytes();
      List<KeySlice> slices=new ArrayList<KeySlice>();
      KeyRange range=new KeyRange(count).setStart_key(start).setEnd_key(end);
      long startTime=System.currentTimeMillis();
      boolean success=false;
      String exceptionMessage=null;
      for (int t=0; t < session.getRetryTimes(); t++) {
        if (success)         break;
        try {
          slices=client.get_range_slices(parent,predicate,range,session.getConsistencyLevel());
          success=(slices.size() != 0);
        }
 catch (        Exception e) {
          exceptionMessage=getExceptionMessage(e);
          success=false;
        }
      }
      if (!success) {
        System.err.printf("Thread [%d] retried %d times - error on calling get_indexed_slices for range %s->%s %s%n",index,session.getRetryTimes(),new String(start),new String(end),(exceptionMessage == null) ? "" : "(" + exceptionMessage + ")");
        if (!session.ignoreErrors())         return;
      }
      current+=slices.size() + 1;
      last=current + slices.size() + 1;
      session.operationCount.getAndIncrement(index);
      session.keyCount.getAndAdd(index,slices.size());
      session.latencies.getAndAdd(index,System.currentTimeMillis() - startTime);
    }
  }
}
