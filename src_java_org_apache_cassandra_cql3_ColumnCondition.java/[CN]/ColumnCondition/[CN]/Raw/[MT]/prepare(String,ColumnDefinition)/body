{
  if (receiver.type instanceof CounterColumnType)   throw new InvalidRequestException("Conditions on counters are not supported");
  if (collectionElement == null) {
    if (operator.equals(Relation.Type.IN)) {
      if (inValues == null)       return ColumnCondition.inCondition(receiver,inMarker.prepare(keyspace,receiver));
      List<Term> terms=new ArrayList<>(inValues.size());
      for (      Term.Raw value : inValues)       terms.add(value.prepare(keyspace,receiver));
      return ColumnCondition.inCondition(receiver,terms);
    }
 else {
      return ColumnCondition.condition(receiver,value.prepare(keyspace,receiver),operator);
    }
  }
  if (!(receiver.type.isCollection()))   throw new InvalidRequestException(String.format("Invalid element access syntax for non-collection column %s",receiver.name));
  ColumnSpecification elementSpec, valueSpec;
switch ((((CollectionType)receiver.type).kind)) {
case LIST:
    elementSpec=Lists.indexSpecOf(receiver);
  valueSpec=Lists.valueSpecOf(receiver);
break;
case MAP:
elementSpec=Maps.keySpecOf(receiver);
valueSpec=Maps.valueSpecOf(receiver);
break;
case SET:
throw new InvalidRequestException(String.format("Invalid element access syntax for set column %s",receiver.name));
default :
throw new AssertionError();
}
if (operator.equals(Relation.Type.IN)) {
if (inValues == null) return ColumnCondition.inCondition(receiver,collectionElement.prepare(keyspace,elementSpec),inMarker.prepare(keyspace,valueSpec));
List<Term> terms=new ArrayList<>(inValues.size());
for (Term.Raw value : inValues) terms.add(value.prepare(keyspace,valueSpec));
return ColumnCondition.inCondition(receiver,collectionElement.prepare(keyspace,elementSpec),terms);
}
 else {
return ColumnCondition.condition(receiver,collectionElement.prepare(keyspace,elementSpec),value.prepare(keyspace,valueSpec),operator);
}
}
