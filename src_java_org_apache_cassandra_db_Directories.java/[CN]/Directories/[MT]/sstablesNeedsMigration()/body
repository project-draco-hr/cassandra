{
  if (StorageService.instance.isClientMode())   return false;
  boolean hasSystemKeyspace=false;
  for (  File location : dataFileLocations) {
    File systemDir=new File(location,Table.SYSTEM_TABLE);
    hasSystemKeyspace|=(systemDir.exists() && systemDir.isDirectory());
    File statusCFDir=new File(systemDir,SystemTable.SCHEMA_KEYSPACES_CF);
    if (statusCFDir.exists())     return false;
  }
  if (!hasSystemKeyspace)   return false;
  int longestLocation=-1;
  try {
    for (    File loc : dataFileLocations)     longestLocation=Math.max(longestLocation,loc.getCanonicalPath().length());
  }
 catch (  IOException e) {
    throw new IOError(e);
  }
  for (  KSMetaData ksm : Schema.instance.getTableDefinitions()) {
    String ksname=ksm.name;
    for (    Map.Entry<String,CFMetaData> entry : ksm.cfMetaData().entrySet()) {
      String cfname=entry.getKey();
      if (System.getProperty("os.name").startsWith("Windows") && longestLocation + (ksname.length() + cfname.length()) * 2 + 63 > 255) {
        throw new RuntimeException(String.format("Starting with 1.1, keyspace names and column family " + "names must be less than %s characters long. %s/%s doesn't" + " respect that restriction. Please rename your "+ "keyspace/column families to respect that restriction "+ "before updating.",Schema.NAME_LENGTH,ksname,cfname));
      }
      if (ksm.name.length() + cfname.length() + 28 > 255) {
        throw new RuntimeException("Starting with 1.1, the keyspace name is included in data filenames.  For " + ksm.name + "/"+ cfname+ ", this puts you over the largest possible filename of 255 characters");
      }
    }
  }
  return true;
}
