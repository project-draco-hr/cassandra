{
  return new AlteringUnfilteredRowIterator(iter){
    @Override public DeletionTime partitionLevelDeletion(){
      DeletionTime dt=iter.partitionLevelDeletion();
      return purger.shouldPurge(dt) ? DeletionTime.LIVE : dt;
    }
    @Override public Row computeNextStatic(    Row row){
      return row.purge(purger,gcBefore);
    }
    @Override public Row computeNext(    Row row){
      return row.purge(purger,gcBefore);
    }
    @Override public RangeTombstoneMarker computeNext(    RangeTombstoneMarker marker){
      boolean reversed=isReverseOrder();
      if (marker.isBoundary()) {
        RangeTombstoneBoundaryMarker boundary=(RangeTombstoneBoundaryMarker)marker;
        boolean shouldPurgeClose=purger.shouldPurge(boundary.closeDeletionTime(reversed));
        boolean shouldPurgeOpen=purger.shouldPurge(boundary.openDeletionTime(reversed));
        if (shouldPurgeClose) {
          if (shouldPurgeOpen)           return null;
          return boundary.createCorrespondingOpenMarker(reversed);
        }
        return shouldPurgeOpen ? boundary.createCorrespondingCloseMarker(reversed) : marker;
      }
 else {
        return purger.shouldPurge(((RangeTombstoneBoundMarker)marker).deletionTime()) ? null : marker;
      }
    }
  }
;
}
