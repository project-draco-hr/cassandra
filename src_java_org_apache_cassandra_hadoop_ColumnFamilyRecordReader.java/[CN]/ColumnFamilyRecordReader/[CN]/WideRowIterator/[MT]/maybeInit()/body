{
  if (wideColumns != null && wideColumns.hasNext())   return;
  KeyRange keyRange;
  ByteBuffer startColumn;
  if (totalRead == 0) {
    String startToken=split.getStartToken();
    keyRange=new KeyRange(batchSize).setStart_token(startToken).setEnd_token(split.getEndToken()).setRow_filter(filter);
    startColumn=ByteBufferUtil.EMPTY_BYTE_BUFFER;
  }
 else {
    KeySlice lastRow=Iterables.getLast(rows);
    logger.debug("Starting with last-seen row {}",lastRow.key);
    keyRange=new KeyRange(batchSize).setStart_key(lastRow.key).setEnd_token(split.getEndToken()).setRow_filter(filter);
    startColumn=Iterables.getLast(lastRow.columns).column.name;
  }
  try {
    rows=client.get_paged_slice(cfName,keyRange,startColumn,consistencyLevel);
    int n=0;
    for (    KeySlice row : rows)     n+=row.columns.size();
    logger.debug("read {} columns in {} rows for {} starting with {}",new Object[]{n,rows.size(),keyRange,startColumn});
    wideColumns=Iterators.peekingIterator(new WideColumnIterator(rows));
    if (wideColumns.hasNext() && wideColumns.peek().right.keySet().iterator().next().equals(startColumn))     wideColumns.next();
    if (!wideColumns.hasNext())     rows=null;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
