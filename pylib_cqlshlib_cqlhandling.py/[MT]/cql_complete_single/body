def cql_complete_single(text, partial, init_bindings={}, ignore_case=True, startsymbol='Start'):
    tokens = (cql_split_statements(text)[0] or [[]])[(-1)]
    bindings = init_bindings.copy()
    prefix = None
    if (tokens and (tokens[(-1)][0] == 'unclosedString')):
        prefix = token_dequote(tokens[(-1)])
        tokens = tokens[:(-1)]
        partial = (prefix + partial)
    if (tokens and (tokens[(-1)][0] == 'unclosedComment')):
        return []
    bindings['partial'] = partial
    completions = CqlRuleSet.complete(startsymbol, tokens, bindings)
    (hints, strcompletes) = list_bifilter(pylexotron.is_hint, completions)
    if ('\n' in strcompletes):
        strcompletes.remove('\n')
        if (partial == ''):
            hints.append(Hint('<enter>'))
    if ignore_case:
        partial = partial.lower()
        f = (lambda s: (s and cql_dequote(s).lower().startswith(partial)))
    else:
        f = (lambda s: (s and cql_dequote(s).startswith(partial)))
    candidates = filter(f, strcompletes)
    if (prefix is not None):
        candidates = [cql_escape(cql_dequote(c))[(len(prefix) + 1):(-1)] for c in candidates]
        candidates = filter(None, candidates)
    if tokens:
        newcandidates = []
        for c in candidates:
            if (want_space_between(tokens[(-1)], c) and (prefix is None) and (not text[(-1)].isspace()) and (not c[0].isspace())):
                c = (' ' + c)
            newcandidates.append(c)
        candidates = newcandidates
    return (candidates, hints)
