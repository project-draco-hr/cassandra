import re
import traceback
from . import pylexotron, util
Hint = pylexotron.Hint
CqlRuleSet = CqlParsingRuleSet()
shorthands = ('completer_for', 'explain_completion', 'dequote_value', 'dequote_name', 'escape_value', 'escape_name', 'maybe_escape_name')
for shorthand in shorthands:
    globals()[shorthand] = getattr(CqlRuleSet, shorthand)
syntax_rules = '\n<Start> ::= <CQL_Statement>*\n          ;\n\n<CQL_Statement> ::= [statements]=<statementBody> ";"\n                  ;\n\n# the order of these terminal productions is significant:\n<endline> ::= /\\n/ ;\n\nJUNK ::= /([ \\t\\r\\f\\v]+|(--|[/][/])[^\\n\\r]*([\\n\\r]|$)|[/][*].*?[*][/])/ ;\n\n<stringLiteral> ::= /\'([^\']|\'\')*\'/ ;\n<float> ::=         /-?[0-9]+\\.[0-9]+/ ;\n<integer> ::=       /-?[0-9]+/ ;\n<uuid> ::=          /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/ ;\n<identifier> ::=    /[a-z][a-z0-9_]*/ ;\n<colon> ::=         ":" ;\n<star> ::=          "*" ;\n<range> ::=         ".." ;\n<endtoken> ::=      ";" ;\n<op> ::=            /[-+=,().]/ ;\n<cmp> ::=           /[<>]=?/ ;\n\n<unclosedString>  ::= /\'([^\']|\'\')*/ ;\n<unclosedComment> ::= /[/][*][^\\n]*$/ ;\n\n<symbol> ::= <star>\n           | <range>\n           | <op>\n           | <cmp>\n           ;\n<name> ::= <identifier>\n         | <stringLiteral>\n         | <integer>\n         ;\n<term> ::= <stringLiteral>\n         | <integer>\n         | <float>\n         | <uuid>\n         ;\n<colname> ::= <term>\n            | <identifier>\n            ;\n\n<statementBody> ::= <useStatement>\n                  | <selectStatement>\n                  | <dataChangeStatement>\n                  | <schemaChangeStatement>\n                  ;\n\n<dataChangeStatement> ::= <insertStatement>\n                        | <updateStatement>\n                        | <deleteStatement>\n                        | <truncateStatement>\n                        | <batchStatement>\n                        ;\n\n<schemaChangeStatement> ::= <createKeyspaceStatement>\n                          | <createColumnFamilyStatement>\n                          | <createIndexStatement>\n                          | <dropKeyspaceStatement>\n                          | <dropColumnFamilyStatement>\n                          | <dropIndexStatement>\n                          | <alterTableStatement>\n                          ;\n\n<consistencylevel> ::= cl=<identifier> ;\n\n<storageType> ::= typename=( <identifier> | <stringLiteral> ) ;\n\n<keyspaceName> ::= ksname=<name> ;\n\n<columnFamilyName> ::= ( ksname=<name> "." )? cfname=<name> ;\n'
syntax_rules += '\n<useStatement> ::= "USE" ksname=<keyspaceName>\n                 ;\n<selectStatement> ::= "SELECT" <whatToSelect>\n                        "FROM" cf=<columnFamilyName>\n                          ("USING" "CONSISTENCY" <consistencylevel>)?\n                          ("WHERE" <selectWhereClause>)?\n                          ("LIMIT" <integer>)?\n                    ;\n<selectWhereClause> ::= <relation> ("AND" <relation>)*\n                      | keyname=<colname> "IN" "(" <term> ("," <term>)* ")"\n                      ;\n<relation> ::= [rel_lhs]=<colname> ("=" | "<" | ">" | "<=" | ">=") <colname>\n             ;\n<whatToSelect> ::= colname=<colname> ("," colname=<colname>)*\n                 | ("FIRST" <integer>)? "REVERSED"? (rangestart=<colname> ".." rangeend=<colname>\n                                                     | "*")\n                 | "COUNT" countparens="(" "*" ")"\n                 ;\n'
explain_completion('whatToSelect', 'colname')
explain_completion('whatToSelect', 'rangestart', '<range_start>')
explain_completion('whatToSelect', 'rangeend', '<range_end>')
syntax_rules += '\n<insertStatement> ::= "INSERT" "INTO" cf=<columnFamilyName>\n                               "(" keyname=<colname> ","\n                                   [colname]=<colname> ( "," [colname]=<colname> )* ")"\n                      "VALUES" "(" <term> "," <term> ( "," <term> )* ")"\n                      ( "USING" [insertopt]=<usingOption>\n                                ( "AND" [insertopt]=<usingOption> )* )?\n                    ;\n<usingOption> ::= "CONSISTENCY" <consistencylevel>\n                | "TIMESTAMP" <integer>\n                | "TTL" <integer>\n                ;\n'
explain_completion('insertStatement', 'colname')
syntax_rules += '\n<updateStatement> ::= "UPDATE" cf=<columnFamilyName>\n                        ( "USING" [updateopt]=<usingOption>\n                                  ( "AND" [updateopt]=<usingOption> )* )?\n                        "SET" <assignment> ( "," <assignment> )*\n                        "WHERE" <updateWhereClause>\n                    ;\n<assignment> ::= updatecol=<colname> "=" update_rhs=<colname>\n                                         ( counterop=( "+" | "-"? ) <integer> )?\n               ;\n<updateWhereClause> ::= updatefiltercol=<colname> "=" <term>\n                      | updatefilterkey=<colname> filter_in="IN" "(" <term> ( "," <term> )* ")"\n                      ;\n'
syntax_rules += '\n<deleteStatement> ::= "DELETE" ( [delcol]=<colname> ( "," [delcol]=<colname> )* )?\n                        "FROM" cf=<columnFamilyName>\n                        ( "USING" [delopt]=<deleteOption> ( "AND" [delopt]=<deleteOption> )* )?\n                        "WHERE" <updateWhereClause>\n                    ;\n<deleteOption> ::= "CONSISTENCY" <consistencylevel>\n                 | "TIMESTAMP" <integer>\n                 ;\n'
explain_completion('deleteStatement', 'delcol', '<column_to_delete>')
syntax_rules += '\n<batchStatement> ::= "BEGIN" "BATCH"\n                        ( "USING" [batchopt]=<usingOption>\n                                  ( "AND" [batchopt]=<usingOption> )* )?\n                        [batchstmt]=<batchStatementMember> ";"\n                            ( [batchstmt]=<batchStatementMember> ";" )*\n                     "APPLY" "BATCH"\n                   ;\n<batchStatementMember> ::= <insertStatement>\n                         | <updateStatement>\n                         | <deleteStatement>\n                         ;\n'
syntax_rules += '\n<truncateStatement> ::= "TRUNCATE" cf=<columnFamilyName>\n                      ;\n'
syntax_rules += '\n<createKeyspaceStatement> ::= "CREATE" "KEYSPACE" ksname=<name>\n                                 "WITH" [optname]=<optionName> "=" [optval]=<optionVal>\n                                 ( "AND" [optname]=<optionName> "=" [optval]=<optionVal> )*\n                            ;\n<optionName> ::= <identifier> ( ":" ( <identifier> | <integer> ) )?\n               ;\n<optionVal> ::= <stringLiteral>\n              | <identifier>\n              | <integer>\n              ;\n'
explain_completion('createKeyspaceStatement', 'ksname', '<new_keyspace_name>')
syntax_rules += '\n<createColumnFamilyStatement> ::= "CREATE" ( "COLUMNFAMILY" | "TABLE" ) cf=<name>\n                                    "(" keyalias=<colname> <storageType> "PRIMARY" "KEY"\n                                        ( "," colname=<colname> <storageType> )* ")"\n                                   ( "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                                     ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )* )?\n                                ;\n\n<cfOptionName> ::= cfoptname=<identifier> ( cfoptsep=":" cfsubopt=( <identifier> | <integer> ) )?\n                 ;\n\n<cfOptionVal> ::= <identifier>\n                | <stringLiteral>\n                | <integer>\n                | <float>\n                ;\n'
explain_completion('createColumnFamilyStatement', 'keyalias', '<new_key_name>')
explain_completion('createColumnFamilyStatement', 'cf', '<new_table_name>')
explain_completion('createColumnFamilyStatement', 'colname', '<new_column_name>')
completer_for('createColumnFamilyStatement', 'optval')(create_cf_option_val_completer)
syntax_rules += '\n<createIndexStatement> ::= "CREATE" "INDEX" indexname=<identifier>? "ON"\n                               cf=<name> "(" col=<colname> ")"\n                         ;\n'
explain_completion('createIndexStatement', 'indexname', '<new_index_name>')
syntax_rules += '\n<dropKeyspaceStatement> ::= "DROP" "KEYSPACE" ksname=<keyspaceName>\n                          ;\n'
syntax_rules += '\n<dropColumnFamilyStatement> ::= "DROP" ( "COLUMNFAMILY" | "TABLE" ) cf=<name>\n                              ;\n'
syntax_rules += '\n<dropIndexStatement> ::= "DROP" "INDEX" indexname=<name>\n                       ;\n'
syntax_rules += '\n<alterTableStatement> ::= "ALTER" ( "COLUMNFAMILY" | "TABLE" ) cf=<name> <alterInstructions>\n                        ;\n<alterInstructions> ::= "ALTER" existcol=<name> "TYPE" <storageType>\n                      | "ADD" newcol=<name> <storageType>\n                      | "DROP" existcol=<name>\n                      | "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                        ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )*\n                      ;\n'
explain_completion('alterInstructions', 'newcol', '<new_column_name>')
completer_for('alterInstructions', 'optval')(create_cf_option_val_completer)
CqlRuleSet.append_rules(syntax_rules)
