import re
from . import pylexotron
from itertools import izip
Hint = pylexotron.Hint
keywords = set(('select', 'from', 'where', 'and', 'key', 'insert', 'update', 'with', 'limit', 'using', 'consistency', 'one', 'quorum', 'all', 'any', 'local_quorum', 'each_quorum', 'two', 'three', 'use', 'count', 'set', 'begin', 'apply', 'batch', 'truncate', 'delete', 'in', 'create', 'keyspace', 'schema', 'columnfamily', 'table', 'index', 'on', 'drop', 'primary', 'into', 'values', 'timestamp', 'ttl', 'alter', 'add', 'type', 'first', 'reversed'))
columnfamily_options = (('comment', None), ('comparator', 'comparator_type'), ('read_repair_chance', None), ('gc_grace_seconds', None), ('default_validation', 'default_validation_class'), ('min_compaction_threshold', None), ('max_compaction_threshold', None), ('replicate_on_write', None), ('compaction_strategy_class', 'compaction_strategy'))
obsolete_cf_options = (('key_cache_size', None), ('row_cache_size', None), ('row_cache_save_period_in_seconds', None), ('key_cache_save_period_in_seconds', None), ('memtable_throughput_in_mb', None), ('memtable_operations_in_millions', None), ('memtable_flush_after_mins', None), ('row_cache_provider', None))
all_columnfamily_options = (columnfamily_options + obsolete_cf_options)
columnfamily_map_options = (('compaction_strategy_options', None, ()), ('compression_parameters', 'compression_options', ('sstable_compression', 'chunk_length_kb', 'crc_check_chance')))
available_compression_classes = ('DeflateCompressor', 'SnappyCompressor')
available_compaction_classes = ('LeveledCompactionStrategy', 'SizeTieredCompactionStrategy')
cql_type_to_apache_class = {'ascii': 'AsciiType', 'bigint': 'LongType', 'blob': 'BytesType', 'boolean': 'BooleanType', 'counter': 'CounterColumnType', 'decimal': 'DecimalType', 'double': 'DoubleType', 'float': 'FloatType', 'int': 'Int32Type', 'text': 'UTF8Type', 'timestamp': 'DateType', 'uuid': 'UUIDType', 'varchar': 'UTF8Type', 'varint': 'IntegerType', }
apache_class_to_cql_type = dict(((v, k) for (k, v) in cql_type_to_apache_class.items()))
cql_types = sorted(cql_type_to_apache_class.keys())
replication_strategies = ('SimpleStrategy', 'OldNetworkTopologyStrategy', 'NetworkTopologyStrategy')
consistency_levels = ('ANY', 'ONE', 'QUORUM', 'ALL', 'LOCAL_QUORUM', 'EACH_QUORUM')
valid_cql_word_re = re.compile('^(?:[a-z][a-z0-9_]*|-?[0-9][0-9.]*)$', re.I)
commands_end_with_newline = set()
special_completers = []
syntax_rules = '\n<Start> ::= <CQL_Statement>*\n          ;\n\n<CQL_Statement> ::= [statements]=<statementBody> ";"\n                  ;\n\n# the order of these terminal productions is significant:\n<endline> ::= /\\n/ ;\n\nJUNK ::= /([ \\t\\r\\f\\v]+|(--|[/][/])[^\\n\\r]*([\\n\\r]|$)|[/][*].*?[*][/])/ ;\n\n<stringLiteral> ::= /\'([^\']|\'\')*\'/ ;\n<dquoteLiteral> ::= /"([^"]|"")*"/ ;\n<float> ::=         /-?[0-9]+\\.[0-9]+/ ;\n<integer> ::=       /-?[0-9]+/ ;\n<uuid> ::=          /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/ ;\n<identifier> ::=    /[a-z][a-z0-9_]*/ ;\n<colon> ::=         ":" ;\n<star> ::=          "*" ;\n<range> ::=         ".." ;\n<endtoken> ::=      ";" ;\n<op> ::=            /[-+=,().]/ ;\n<cmp> ::=           /[<>]=?/ ;\n\n<unclosedString>  ::= /\'([^\']|\'\')*/ ;\n<unclosedComment> ::= /[/][*][^\\n]*$/ ;\n\n<symbol> ::= <star>\n           | <range>\n           | <op>\n           | <cmp>\n           ;\n<name> ::= <identifier>\n         | <stringLiteral>\n         | <dquoteLiteral>\n         | <integer>\n         ;\n<term> ::= <stringLiteral>\n         | <integer>\n         | <float>\n         | <uuid>\n         ;\n<colname> ::= <term>\n            | <identifier>\n            ;\n\n<statementBody> ::= <useStatement>\n                  | <selectStatement>\n                  | <dataChangeStatement>\n                  | <schemaChangeStatement>\n                  ;\n\n<dataChangeStatement> ::= <insertStatement>\n                        | <updateStatement>\n                        | <deleteStatement>\n                        | <truncateStatement>\n                        | <batchStatement>\n                        ;\n\n<schemaChangeStatement> ::= <createKeyspaceStatement>\n                          | <createColumnFamilyStatement>\n                          | <createIndexStatement>\n                          | <dropKeyspaceStatement>\n                          | <dropColumnFamilyStatement>\n                          | <dropIndexStatement>\n                          | <alterTableStatement>\n                          ;\n\n<consistencylevel> ::= cl=<identifier> ;\n\n<storageType> ::= typename=( <identifier> | <stringLiteral> );\n'
syntax_rules += '\n<useStatement> ::= "USE" ksname=<name>\n                 ;\n'
syntax_rules += '\n<selectStatement> ::= "SELECT" <whatToSelect>\n                        "FROM" ( selectks=<name> "." )? selectsource=<name>\n                          ("USING" "CONSISTENCY" <consistencylevel>)?\n                          ("WHERE" <selectWhereClause>)?\n                          ("LIMIT" <integer>)?\n                    ;\n<selectWhereClause> ::= <relation> ("AND" <relation>)*\n                      | keyname=<colname> "IN" "(" <term> ("," <term>)* ")"\n                      ;\n<relation> ::= [rel_lhs]=<colname> ("=" | "<" | ">" | "<=" | ">=") <colname>\n             ;\n<whatToSelect> ::= colname=<colname> ("," colname=<colname>)*\n                 | ("FIRST" <integer>)? "REVERSED"? (rangestart=<colname> ".." rangeend=<colname>\n                                                     | "*")\n                 | "COUNT" countparens="(" "*" ")"\n                 ;\n'
explain_completion('whatToSelect', 'colname')
explain_completion('whatToSelect', 'rangestart', '<range_start>')
explain_completion('whatToSelect', 'rangeend', '<range_end>')
syntax_rules += '\n<insertStatement> ::= "INSERT" "INTO" ( insertks=<name> "." )? insertcf=<name>\n                               "(" keyname=<colname> ","\n                                   [colname]=<colname> ( "," [colname]=<colname> )* ")"\n                      "VALUES" "(" <term> "," <term> ( "," <term> )* ")"\n                      ( "USING" [insertopt]=<usingOption>\n                                ( "AND" [insertopt]=<usingOption> )* )?\n                    ;\n<usingOption> ::= "CONSISTENCY" <consistencylevel>\n                | "TIMESTAMP" <integer>\n                | "TTL" <integer>\n                ;\n'
explain_completion('insertStatement', 'colname')
syntax_rules += '\n<updateStatement> ::= "UPDATE" ( updateks=<name> "." )? updatecf=<name>\n                        ( "USING" [updateopt]=<usingOption>\n                                  ( "AND" [updateopt]=<usingOption> )* )?\n                        "SET" <assignment> ( "," <assignment> )*\n                        "WHERE" <updateWhereClause>\n                    ;\n<assignment> ::= updatecol=<colname> "=" update_rhs=<colname>\n                                         ( counterop=( "+" | "-"? ) <integer> )?\n               ;\n<updateWhereClause> ::= updatefiltercol=<colname> "=" <term>\n                      | updatefilterkey=<colname> filter_in="IN" "(" <term> ( "," <term> )* ")"\n                      ;\n'
syntax_rules += '\n<deleteStatement> ::= "DELETE" ( [delcol]=<colname> ( "," [delcol]=<colname> )* )?\n                        "FROM" ( deleteks=<name> "." )? deletecf=<name>\n                        ( "USING" [delopt]=<deleteOption> ( "AND" [delopt]=<deleteOption> )* )?\n                        "WHERE" <updateWhereClause>\n                    ;\n<deleteOption> ::= "CONSISTENCY" <consistencylevel>\n                 | "TIMESTAMP" <integer>\n                 ;\n'
explain_completion('deleteStatement', 'delcol', '<column_to_delete>')
syntax_rules += '\n<batchStatement> ::= "BEGIN" "BATCH"\n                        ( "USING" [batchopt]=<usingOption>\n                                  ( "AND" [batchopt]=<usingOption> )* )?\n                        [batchstmt]=<batchStatementMember> ";"\n                            ( [batchstmt]=<batchStatementMember> ";" )*\n                     "APPLY" "BATCH"\n                   ;\n<batchStatementMember> ::= <insertStatement>\n                         | <updateStatement>\n                         | <deleteStatement>\n                         ;\n'
syntax_rules += '\n<truncateStatement> ::= "TRUNCATE" ( truncateks=<name> "." )? truncatecf=<name>\n                      ;\n'
syntax_rules += '\n<createKeyspaceStatement> ::= "CREATE" "KEYSPACE" ksname=<name>\n                                 "WITH" [optname]=<optionName> "=" [optval]=<optionVal>\n                                 ( "AND" [optname]=<optionName> "=" [optval]=<optionVal> )*\n                            ;\n<optionName> ::= <identifier> ( ":" ( <identifier> | <integer> ) )?\n               ;\n<optionVal> ::= <stringLiteral>\n              | <identifier>\n              | <integer>\n              ;\n'
explain_completion('createKeyspaceStatement', 'ksname', '<new_keyspace_name>')
syntax_rules += '\n<createColumnFamilyStatement> ::= "CREATE" "COLUMNFAMILY" cf=<name>\n                                    "(" keyalias=<colname> <storageType> "PRIMARY" "KEY"\n                                        ( "," colname=<colname> <storageType> )* ")"\n                                   ( "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                                     ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )* )?\n                                ;\n\n<cfOptionName> ::= cfoptname=<identifier> ( cfoptsep=":" cfsubopt=( <identifier> | <integer> ) )?\n                 ;\n\n<cfOptionVal> ::= <identifier>\n                | <stringLiteral>\n                | <integer>\n                | <float>\n                ;\n'
explain_completion('createColumnFamilyStatement', 'keyalias', '<new_key_alias>')
explain_completion('createColumnFamilyStatement', 'cf', '<new_columnfamily_name>')
explain_completion('createColumnFamilyStatement', 'colname', '<new_column_name>')
completer_for('createColumnFamilyStatement', 'optval')(create_cf_option_val_completer)
syntax_rules += '\n<createIndexStatement> ::= "CREATE" "INDEX" indexname=<identifier>? "ON"\n                               cf=<name> "(" col=<colname> ")"\n                         ;\n'
explain_completion('createIndexStatement', 'indexname', '<new_index_name>')
syntax_rules += '\n<dropKeyspaceStatement> ::= "DROP" "KEYSPACE" ksname=<name>\n                          ;\n'
syntax_rules += '\n<dropColumnFamilyStatement> ::= "DROP" "COLUMNFAMILY" cf=<name>\n                              ;\n'
syntax_rules += '\n<dropIndexStatement> ::= "DROP" "INDEX" indexname=<name>\n                       ;\n'
syntax_rules += '\n<alterTableStatement> ::= "ALTER" "COLUMNFAMILY" cf=<name> <alterInstructions>\n                        ;\n<alterInstructions> ::= "ALTER" existcol=<name> "TYPE" <storageType>\n                      | "ADD" newcol=<name> <storageType>\n                      | "DROP" existcol=<name>\n                      | "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                        ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )*\n                      ;\n'
explain_completion('alterInstructions', 'newcol', '<new_column_name>')
completer_for('alterInstructions', 'optval')(create_cf_option_val_completer)
CqlRuleSet = pylexotron.ParsingRuleSet.from_rule_defs(syntax_rules)
for (rulename, symname, compf) in special_completers:
    CqlRuleSet.register_completer(compf, rulename, symname)
