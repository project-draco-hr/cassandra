{
  if (r > n)   throw new IllegalArgumentException("r must be less than n");
  if (r < 0)   throw new IllegalArgumentException("r must be positive");
  if (w > n)   throw new IllegalArgumentException("w must be less than n");
  if (w < 0)   throw new IllegalArgumentException("w must be positive");
  if (percentileLatency < 0 || percentileLatency > 1)   throw new IllegalArgumentException("percentileLatency must be between 0 and 1 inclusive");
  if (numberVersionsStale < 0)   throw new IllegalArgumentException("numberVersionsStale must be positive");
  if (!logLatencies)   throw new IllegalStateException("Latency logging is not enabled");
  Map<Integer,List<Long>> wLatencies=getOrderedWLatencies();
  Map<Integer,List<Long>> aLatencies=getOrderedALatencies();
  Map<Integer,List<Long>> rLatencies=getOrderedRLatencies();
  Map<Integer,List<Long>> sLatencies=getOrderedSLatencies();
  if (wLatencies.isEmpty() || aLatencies.isEmpty())   throw new IllegalStateException("No write latencies have been recorded so far. Run some (non-local) inserts.");
  if (rLatencies.isEmpty() || sLatencies.isEmpty())   throw new IllegalStateException("No read latencies have been recorded so far. Run some (non-local) reads.");
  ArrayList<Long> readLatencies=new ArrayList<Long>();
  ArrayList<Long> writeLatencies=new ArrayList<Long>();
  long consistentReads=0;
  ArrayList<Long> trialWLatencies=new ArrayList<Long>();
  ArrayList<Long> trialRLatencies=new ArrayList<Long>();
  ArrayList<Long> replicaWriteLatencies=new ArrayList<Long>();
  ArrayList<Long> replicaReadLatencies=new ArrayList<Long>();
  for (int i=0; i < numberTrialsPrediction; ++i) {
    for (int replicaNo=0; replicaNo < n; ++replicaNo) {
      long trialWLatency=getRandomLatencySample(wLatencies,replicaNo);
      long trialALatency=getRandomLatencySample(aLatencies,replicaNo);
      trialWLatencies.add(trialWLatency);
      replicaWriteLatencies.add(trialWLatency + trialALatency);
    }
    for (int replicaNo=0; replicaNo < r; ++replicaNo) {
      long trialRLatency=getRandomLatencySample(rLatencies,replicaNo);
      long trialSLatency=getRandomLatencySample(sLatencies,replicaNo);
      trialRLatencies.add(trialRLatency);
      replicaReadLatencies.add(trialRLatency + trialSLatency);
    }
    Collections.sort(replicaWriteLatencies);
    long writeLatency=replicaWriteLatencies.get(w - 1);
    writeLatencies.add(writeLatency);
    ArrayList<Long> sortedReplicaReadLatencies=new ArrayList<Long>(replicaReadLatencies);
    Collections.sort(sortedReplicaReadLatencies);
    readLatencies.add(sortedReplicaReadLatencies.get(r - 1));
    for (int responseNumber=0; responseNumber < r; ++responseNumber) {
      int replicaNumber=replicaReadLatencies.indexOf(sortedReplicaReadLatencies.get(responseNumber));
      if (writeLatency + timeSinceWrite + trialRLatencies.get(replicaNumber) >= trialWLatencies.get(replicaNumber)) {
        consistentReads++;
        break;
      }
      replicaReadLatencies.set(replicaNumber,-1L);
    }
    trialWLatencies.clear();
    trialRLatencies.clear();
    replicaReadLatencies.clear();
    replicaWriteLatencies.clear();
  }
  float oneVersionConsistencyProbability=(float)consistentReads / numberTrialsPrediction;
  float consistencyProbability=(float)(1 - Math.pow((double)(1 - oneVersionConsistencyProbability),numberVersionsStale));
  float averageWriteLatency=listAverage(writeLatencies);
  float averageReadLatency=listAverage(readLatencies);
  long percentileWriteLatency=getPercentile(writeLatencies,percentileLatency);
  long percentileReadLatency=getPercentile(readLatencies,percentileLatency);
  return new PBSPredictionResult(n,r,w,timeSinceWrite,numberVersionsStale,consistencyProbability,averageReadLatency,averageWriteLatency,percentileReadLatency,percentileLatency,percentileWriteLatency,percentileLatency);
}
