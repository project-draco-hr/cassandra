{
  checkArgument(args.size() == 2,"cfhistograms requires ks and cf args");
  String keyspace=args.get(0);
  String cfname=args.get(1);
  long[] estimatedRowSize=(long[])probe.getColumnFamilyMetric(keyspace,cfname,"EstimatedRowSizeHistogram");
  long[] estimatedColumnCount=(long[])probe.getColumnFamilyMetric(keyspace,cfname,"EstimatedColumnCountHistogram");
  double[] estimatedRowSizePercentiles=new double[7];
  double[] estimatedColumnCountPercentiles=new double[7];
  double[] offsetPercentiles=new double[]{0.5,0.75,0.95,0.98,0.99};
  if (ArrayUtils.isEmpty(estimatedRowSize) || ArrayUtils.isEmpty(estimatedColumnCount)) {
    System.err.println("No SSTables exists, unable to calculate 'Partition Size' and 'Cell Count' percentiles");
    for (int i=0; i < 7; i++) {
      estimatedRowSizePercentiles[i]=Double.NaN;
      estimatedColumnCountPercentiles[i]=Double.NaN;
    }
  }
 else {
    long[] rowSizeBucketOffsets=new EstimatedHistogram(estimatedRowSize.length).getBucketOffsets();
    long[] columnCountBucketOffsets=new EstimatedHistogram(estimatedColumnCount.length).getBucketOffsets();
    EstimatedHistogram rowSizeHist=new EstimatedHistogram(rowSizeBucketOffsets,estimatedRowSize);
    EstimatedHistogram columnCountHist=new EstimatedHistogram(columnCountBucketOffsets,estimatedColumnCount);
    if (rowSizeHist.isOverflowed()) {
      System.err.println(String.format("Row sizes are larger than %s, unable to calculate percentiles",rowSizeBucketOffsets[rowSizeBucketOffsets.length - 1]));
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedRowSizePercentiles[i]=Double.NaN;
    }
 else {
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedRowSizePercentiles[i]=rowSizeHist.percentile(offsetPercentiles[i]);
    }
    if (columnCountHist.isOverflowed()) {
      System.err.println(String.format("Column counts are larger than %s, unable to calculate percentiles",columnCountBucketOffsets[columnCountBucketOffsets.length - 1]));
      for (int i=0; i < estimatedColumnCountPercentiles.length; i++)       estimatedColumnCountPercentiles[i]=Double.NaN;
    }
 else {
      for (int i=0; i < offsetPercentiles.length; i++)       estimatedColumnCountPercentiles[i]=columnCountHist.percentile(offsetPercentiles[i]);
    }
    estimatedRowSizePercentiles[5]=rowSizeHist.min();
    estimatedColumnCountPercentiles[5]=columnCountHist.min();
    estimatedRowSizePercentiles[6]=rowSizeHist.max();
    estimatedColumnCountPercentiles[6]=columnCountHist.max();
  }
  String[] percentiles=new String[]{"50%","75%","95%","98%","99%","Min","Max"};
  double[] readLatency=probe.metricPercentilesAsArray((JmxReporter.HistogramMBean)probe.getColumnFamilyMetric(keyspace,cfname,"ReadLatency"));
  double[] writeLatency=probe.metricPercentilesAsArray((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspace,cfname,"WriteLatency"));
  double[] sstablesPerRead=probe.metricPercentilesAsArray((JmxReporter.HistogramMBean)probe.getColumnFamilyMetric(keyspace,cfname,"SSTablesPerReadHistogram"));
  System.out.println(format("%s/%s histograms",keyspace,cfname));
  System.out.println(format("%-10s%10s%18s%18s%18s%18s","Percentile","SSTables","Write Latency","Read Latency","Partition Size","Cell Count"));
  System.out.println(format("%-10s%10s%18s%18s%18s%18s","","","(micros)","(micros)","(bytes)",""));
  for (int i=0; i < percentiles.length; i++) {
    System.out.println(format("%-10s%10.2f%18.2f%18.2f%18.0f%18.0f",percentiles[i],sstablesPerRead[i],writeLatency[i],readLatency[i],estimatedRowSizePercentiles[i],estimatedColumnCountPercentiles[i]));
  }
  System.out.println();
}
