{
  joiningNodes=probe.getJoiningNodes();
  leavingNodes=probe.getLeavingNodes();
  movingNodes=probe.getMovingNodes();
  loadMap=probe.getLoadMap();
  tokensToEndpoints=probe.getTokenToEndpointMap();
  liveNodes=probe.getLiveNodes();
  unreachableNodes=probe.getUnreachableNodes();
  hostIDMap=probe.getHostIdMap();
  epSnitchInfo=probe.getEndpointSnitchInfoProxy();
  Map<InetAddress,Float> ownerships;
  try {
    ownerships=probe.effectiveOwnership(keyspace);
    hasEffectiveOwns=true;
  }
 catch (  IllegalStateException e) {
    ownerships=probe.getOwnership();
    System.out.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
  }
  Map<String,SetHostStat> dcs=getOwnershipByDc(probe,resolveIp,tokensToEndpoints,ownerships);
  if (dcs.values().size() < tokensToEndpoints.keySet().size())   isTokenPerNode=false;
  findMaxAddressLength(dcs);
  for (  Map.Entry<String,SetHostStat> dc : dcs.entrySet()) {
    String dcHeader=String.format("Datacenter: %s%n",dc.getKey());
    System.out.printf(dcHeader);
    for (int i=0; i < (dcHeader.length() - 1); i++)     System.out.print('=');
    System.out.println();
    System.out.println("Status=Up/Down");
    System.out.println("|/ State=Normal/Leaving/Joining/Moving");
    printNodesHeader(hasEffectiveOwns,isTokenPerNode);
    ArrayListMultimap<InetAddress,HostStat> hostToTokens=ArrayListMultimap.create();
    for (    HostStat stat : dc.getValue())     hostToTokens.put(stat.endpoint,stat);
    for (    InetAddress endpoint : hostToTokens.keySet()) {
      Float owns=ownerships.get(endpoint);
      List<HostStat> tokens=hostToTokens.get(endpoint);
      printNode(endpoint.getHostAddress(),owns,tokens,hasEffectiveOwns,isTokenPerNode);
    }
  }
}
