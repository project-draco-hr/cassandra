{
  Map<String,String> tokensToEndpoints=probe.getTokenToEndpointMap();
  LinkedHashMultimap<String,String> endpointsToTokens=LinkedHashMultimap.create();
  for (  Map.Entry<String,String> entry : tokensToEndpoints.entrySet())   endpointsToTokens.put(entry.getValue(),entry.getKey());
  int maxAddressLength=Collections.max(endpointsToTokens.keys(),new Comparator<String>(){
    @Override public int compare(    String first,    String second){
      return ((Integer)first.length()).compareTo(second.length());
    }
  }
).length();
  String formatPlaceholder="%%-%ds  %%-12s%%-7s%%-8s%%-16s%%-20s%%-44s%%n";
  String format=format(formatPlaceholder,maxAddressLength);
  Map<InetAddress,Float> ownerships;
  try {
    ownerships=probe.effectiveOwnership(keyspace);
  }
 catch (  IllegalStateException ex) {
    ownerships=probe.getOwnership();
    System.out.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
  }
  try {
    System.out.println();
    Map<String,Map<InetAddress,Float>> perDcOwnerships=Maps.newLinkedHashMap();
    for (    Map.Entry<InetAddress,Float> ownership : ownerships.entrySet()) {
      String dc=probe.getEndpointSnitchInfoProxy().getDatacenter(ownership.getKey().getHostAddress());
      if (!perDcOwnerships.containsKey(dc))       perDcOwnerships.put(dc,new LinkedHashMap<InetAddress,Float>());
      perDcOwnerships.get(dc).put(ownership.getKey(),ownership.getValue());
    }
    for (    Map.Entry<String,Map<InetAddress,Float>> entry : perDcOwnerships.entrySet())     printDc(probe,format,entry.getKey(),endpointsToTokens,entry.getValue());
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
  if (DatabaseDescriptor.getNumTokens() > 1) {
    System.out.println("  Warning: \"nodetool ring\" is used to output all the tokens of a node.");
    System.out.println("  To view status related info of a node use \"nodetool status\" instead.\n");
  }
}
