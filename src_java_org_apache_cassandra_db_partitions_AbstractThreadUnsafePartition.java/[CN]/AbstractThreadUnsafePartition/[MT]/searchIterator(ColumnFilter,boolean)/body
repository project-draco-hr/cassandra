{
  final RowSearcher searcher=reversed ? new ReverseRowSearcher() : new ForwardRowSearcher();
  return new SearchIterator<Clustering,Row>(){
    public boolean hasNext(){
      return !searcher.isDone();
    }
    public Row next(    Clustering clustering){
      if (clustering == Clustering.STATIC_CLUSTERING) {
        Row staticRow=staticRow();
        return staticRow.isEmpty() || columns.fetchedColumns().statics.isEmpty() ? Rows.EMPTY_STATIC_ROW : staticRow.filter(columns,partitionLevelDeletion(),true,metadata);
      }
      Row row=searcher.search(clustering);
      RangeTombstone rt=deletionInfo().rangeCovering(clustering);
      DeletionTime activeDeletion=partitionLevelDeletion();
      if (rt != null && rt.deletionTime().supersedes(activeDeletion))       activeDeletion=rt.deletionTime();
      if (row == null)       return activeDeletion.isLive() ? null : BTreeBackedRow.emptyDeletedRow(clustering,activeDeletion);
      return row.filter(columns,activeDeletion,true,metadata);
    }
  }
;
}
