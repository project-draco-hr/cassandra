{
  while (true) {
    CommitLogSegment next;
synchronized (this) {
      if (allocatingFrom != old)       return;
      next=availableSegments.poll();
      if (next != null) {
        allocatingFrom=next;
        activeSegments.add(next);
      }
    }
    if (next != null) {
      if (old != null) {
        CommitLog.instance.archiver.maybeArchive(old);
        old.discardUnusedTail();
      }
      CommitLog.instance.requestExtraSync();
      return;
    }
    WaitQueue.Signal signal=hasAvailableSegments.register(CommitLog.instance.metrics.waitingOnSegmentAllocation.time());
    wakeManager();
    if (!availableSegments.isEmpty() || allocatingFrom != old) {
      signal.cancel();
      if (allocatingFrom != old)       return;
      continue;
    }
    signal.awaitUninterruptibly();
  }
}
