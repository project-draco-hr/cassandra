{
  Runnable runnable=new WrappedRunnable(){
    public void runMayThrow() throws Exception {
      while (run) {
        try {
          Callable<CommitLogSegment> task=segmentManagementTasks.poll();
          if (task == null) {
            if (availableSegments.isEmpty() && (activeSegments.isEmpty() || createReserveSegments)) {
              logger.debug("No segments in reserve; creating a fresh one");
              size.addAndGet(DatabaseDescriptor.getCommitLogSegmentSize());
              availableSegments.add(CommitLogSegment.freshSegment());
              hasAvailableSegments.signalAll();
            }
            long unused=unusedCapacity();
            if (unused < 0) {
              List<CommitLogSegment> segmentsToRecycle=new ArrayList<>();
              long spaceToReclaim=0;
              for (              CommitLogSegment segment : activeSegments) {
                if (segment == allocatingFrom)                 break;
                segmentsToRecycle.add(segment);
                spaceToReclaim+=DatabaseDescriptor.getCommitLogSegmentSize();
                if (spaceToReclaim + unused >= 0)                 break;
              }
              flushDataFrom(segmentsToRecycle,false);
            }
            try {
              task=segmentManagementTasks.take();
            }
 catch (            InterruptedException e) {
              continue;
            }
          }
          CommitLogSegment recycled=task.call();
          if (recycled != null) {
            availableSegments.add(recycled);
            hasAvailableSegments.signalAll();
          }
        }
 catch (        Throwable t) {
          if (!CommitLog.handleCommitError("Failed managing commit log segments",t))           return;
          Uninterruptibles.sleepUninterruptibly(1,TimeUnit.SECONDS);
        }
      }
    }
  }
;
  managerThread=new Thread(runnable,"COMMIT-LOG-ALLOCATOR");
  managerThread.start();
}
