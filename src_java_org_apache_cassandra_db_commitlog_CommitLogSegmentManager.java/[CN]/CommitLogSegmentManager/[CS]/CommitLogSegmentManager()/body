{
  Runnable runnable=new WrappedRunnable(){
    public void runMayThrow() throws Exception {
      while (run) {
        Callable<CommitLogSegment> task=segmentManagementTasks.poll();
        if (task == null) {
          if (availableSegments.isEmpty() && (activeSegments.isEmpty() || createReserveSegments)) {
            logger.debug("No segments in reserve; creating a fresh one");
            size.addAndGet(DatabaseDescriptor.getCommitLogSegmentSize());
            availableSegments.add(CommitLogSegment.freshSegment());
            hasAvailableSegments.signalAll();
          }
          long unused=unusedCapacity();
          if (unused < 0) {
            List<CommitLogSegment> segmentsToRecycle=new ArrayList<>();
            long spaceToReclaim=0;
            for (            CommitLogSegment segment : activeSegments) {
              if (segment == allocatingFrom)               break;
              segmentsToRecycle.add(segment);
              spaceToReclaim+=DatabaseDescriptor.getCommitLogSegmentSize();
              if (spaceToReclaim + unused >= 0)               break;
            }
            flushDataFrom(segmentsToRecycle);
          }
          try {
            task=segmentManagementTasks.take();
          }
 catch (          InterruptedException e) {
            continue;
          }
        }
        CommitLogSegment recycled=task.call();
        if (recycled != null) {
          availableSegments.add(recycled);
          hasAvailableSegments.signalAll();
        }
      }
    }
  }
;
  managerThread=new Thread(runnable,"COMMIT-LOG-ALLOCATOR");
  managerThread.start();
}
