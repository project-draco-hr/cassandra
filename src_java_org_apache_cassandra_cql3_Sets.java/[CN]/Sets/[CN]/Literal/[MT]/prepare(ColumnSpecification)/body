{
  validateAssignableTo(receiver);
  if (receiver.type instanceof MapType && elements.isEmpty())   return new Maps.Value(Collections.<ByteBuffer,ByteBuffer>emptyMap());
  ColumnSpecification valueSpec=Sets.valueSpecOf(receiver);
  Set<ByteBuffer> values=new TreeSet<ByteBuffer>(((SetType)receiver.type).elements);
  for (  Term.Raw rt : elements) {
    Term t=rt.prepare(valueSpec);
    if (!(t instanceof Constants.Value)) {
      if (t instanceof Term.NonTerminal)       throw new InvalidRequestException(String.format("Invalid set literal for %s: bind variables are not supported inside collection literals",receiver));
 else       throw new InvalidRequestException(String.format("Invalid set literal for %s: nested collections are not supported",receiver));
    }
    ByteBuffer bytes=((Constants.Value)t).bytes;
    if (bytes == null)     throw new InvalidRequestException("null is not supported inside collections");
    if (bytes.remaining() > FBUtilities.MAX_UNSIGNED_SHORT)     throw new InvalidRequestException(String.format("Set value is too long. Set values are limited to %d bytes but %d bytes value provided",FBUtilities.MAX_UNSIGNED_SHORT,bytes.remaining()));
    if (!values.add(bytes))     throw new InvalidRequestException(String.format("Invalid set literal: duplicate value %s",rt));
  }
  return new Value(values);
}
