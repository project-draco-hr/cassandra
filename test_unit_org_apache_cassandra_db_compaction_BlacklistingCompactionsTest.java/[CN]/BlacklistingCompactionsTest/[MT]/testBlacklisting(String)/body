{
  Keyspace keyspace=Keyspace.open(KEYSPACE1);
  final ColumnFamilyStore cfs=keyspace.getColumnFamilyStore("Standard1");
  final int ROWS_PER_SSTABLE=10;
  final int SSTABLES=cfs.metadata.getMinIndexInterval() * 2 / ROWS_PER_SSTABLE;
  cfs.setCompactionStrategyClass(compactionStrategy);
  cfs.disableAutoCompaction();
  long maxTimestampExpected=Long.MIN_VALUE;
  Set<DecoratedKey> inserted=new HashSet<>();
  for (int j=0; j < SSTABLES; j++) {
    for (int i=0; i < ROWS_PER_SSTABLE; i++) {
      DecoratedKey key=Util.dk(String.valueOf(i));
      long timestamp=j * ROWS_PER_SSTABLE + i;
      new RowUpdateBuilder(cfs.metadata,timestamp,key.getKey()).clustering("cols" + "i").add("val","val" + i).build().applyUnsafe();
      maxTimestampExpected=Math.max(timestamp,maxTimestampExpected);
      inserted.add(key);
    }
    cfs.forceBlockingFlush();
    CompactionsTest.assertMaxTimestamp(cfs,maxTimestampExpected);
    assertEquals(inserted.toString(),inserted.size(),Util.getAll(Util.cmd(cfs).build()).size());
  }
  Collection<SSTableReader> sstables=cfs.getLiveSSTables();
  int currentSSTable=0;
  int sstablesToCorrupt=8;
  for (  SSTableReader sstable : sstables) {
    if (currentSSTable + 1 > sstablesToCorrupt)     break;
    RandomAccessFile raf=null;
    try {
      int corruptionSize=50;
      raf=new RandomAccessFile(sstable.getFilename(),"rw");
      assertNotNull(raf);
      assertTrue(raf.length() > corruptionSize);
      raf.seek(new Random().nextInt((int)(raf.length() - corruptionSize)));
      byte[] corruption=new byte[corruptionSize];
      Arrays.fill(corruption,(byte)0xFF);
      raf.write(corruption);
    }
  finally {
      FileUtils.closeQuietly(raf);
    }
    currentSSTable++;
  }
  int failures=0;
  for (int i=0; i < sstables.size(); i++) {
    try {
      cfs.forceMajorCompaction();
    }
 catch (    Exception e) {
      failures++;
      continue;
    }
    break;
  }
  cfs.truncateBlocking();
  assertEquals(sstablesToCorrupt,failures);
}
