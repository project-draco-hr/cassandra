{
  Keyspace keyspace=Keyspace.open(KEYSPACE);
  final ColumnFamilyStore cfs=keyspace.getColumnFamilyStore("Standard1");
  final int ROWS_PER_SSTABLE=10;
  final int SSTABLES=cfs.metadata.getMinIndexInterval() * 2 / ROWS_PER_SSTABLE;
  cfs.setCompactionStrategyClass(compactionStrategy);
  cfs.disableAutoCompaction();
  long maxTimestampExpected=Long.MIN_VALUE;
  Set<DecoratedKey> inserted=new HashSet<DecoratedKey>();
  for (int j=0; j < SSTABLES; j++) {
    for (int i=0; i < ROWS_PER_SSTABLE; i++) {
      DecoratedKey key=Util.dk(String.valueOf(i % 2));
      Mutation rm=new Mutation(KEYSPACE,key.getKey());
      long timestamp=j * ROWS_PER_SSTABLE + i;
      rm.add("Standard1",cellname(i / 2),ByteBufferUtil.EMPTY_BYTE_BUFFER,timestamp);
      maxTimestampExpected=Math.max(timestamp,maxTimestampExpected);
      rm.apply();
      inserted.add(key);
    }
    cfs.forceBlockingFlush();
    CompactionsTest.assertMaxTimestamp(cfs,maxTimestampExpected);
    assertEquals(inserted.toString(),inserted.size(),Util.getRangeSlice(cfs).size());
  }
  Collection<SSTableReader> sstables=cfs.getSSTables();
  int currentSSTable=0;
  int sstablesToCorrupt=8;
  for (  SSTableReader sstable : sstables) {
    if (currentSSTable + 1 > sstablesToCorrupt)     break;
    RandomAccessFile raf=null;
    try {
      raf=new RandomAccessFile(sstable.getFilename(),"rw");
      assertNotNull(raf);
      assertTrue(raf.length() > 20);
      raf.seek(new Random().nextInt((int)(raf.length() - 20)));
      byte[] corruption=new byte[20];
      Arrays.fill(corruption,(byte)0xFF);
      raf.write(corruption);
    }
  finally {
      FileUtils.closeQuietly(raf);
    }
    currentSSTable++;
  }
  int failures=0;
  for (int i=0; i < sstables.size(); i++) {
    try {
      cfs.forceMajorCompaction();
    }
 catch (    Exception e) {
      failures++;
      continue;
    }
    assertEquals(sstablesToCorrupt + 1,cfs.getSSTables().size());
    break;
  }
  cfs.truncateBlocking();
  assertEquals(sstablesToCorrupt,failures);
}
