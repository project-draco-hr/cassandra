{
  int timerCount=0;
  for (  List<Timer> timersForOperation : timers.values()) {
    timerCount+=timersForOperation.size();
  }
  final CountDownLatch ready=new CountDownLatch(timerCount);
  for (  List<Timer> timersForOperation : timers.values()) {
    for (    Timer timer : timersForOperation) {
      timer.requestReport(ready);
    }
  }
  E extra;
  try {
    extra=call.call();
  }
 catch (  Exception e) {
    if (e instanceof InterruptedException)     throw (InterruptedException)e;
    throw new RuntimeException(e);
  }
  if (!ready.await(5L,TimeUnit.MINUTES)) {
    throw new RuntimeException("Timed out waiting for a timer thread - seems one got stuck. Check GC/Heap size");
  }
  boolean done=true;
  Map<String,TimingInterval> intervals=new TreeMap<>();
  for (  Map.Entry<String,List<Timer>> entry : timers.entrySet()) {
    List<TimingInterval> operationIntervals=new ArrayList<>();
    for (    Timer timer : entry.getValue()) {
      operationIntervals.add(timer.report);
      done&=!timer.running();
    }
    intervals.put(entry.getKey(),TimingInterval.merge(operationIntervals,reportSampleCount,history.get(entry.getKey()).endNanos()));
  }
  TimingIntervals result=new TimingIntervals(intervals);
  this.done=done;
  history=history.merge(result,historySampleCount,history.startNanos());
  return new TimingResult<>(extra,result);
}
