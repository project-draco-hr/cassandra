{
  String keyspace=in.readUTF();
  String columnFamily=in.readUTF();
  long timestamp=in.readLong();
  CFMetaData metadata=Schema.instance.getCFMetaData(keyspace,columnFamily);
  if (metadata == null) {
    String message=String.format("Got range slice command for nonexistent table %s.%s.  If the table was just " + "created, this is likely due to the schema not being fully propagated.  Please wait for schema " + "agreement on table creation.",keyspace,columnFamily);
    throw new UnknownColumnFamilyException(message,null);
  }
  IDiskAtomFilter predicate=metadata.comparator.diskAtomFilterSerializer().deserialize(in,version);
  List<IndexExpression> rowFilter;
  int filterCount=in.readInt();
  rowFilter=new ArrayList<>(filterCount);
  for (int i=0; i < filterCount; i++) {
    rowFilter.add(IndexExpression.readFrom(in));
  }
  AbstractBounds<RowPosition> range=AbstractBounds.rowPositionSerializer.deserialize(in,MessagingService.globalPartitioner(),version);
  int maxResults=in.readInt();
  boolean countCQL3Rows=in.readBoolean();
  boolean isPaging=in.readBoolean();
  return new RangeSliceCommand(keyspace,columnFamily,timestamp,predicate,range,rowFilter,maxResults,countCQL3Rows,isPaging);
}
