{
  if (discardingTooLongFrame) {
    bytesToDiscard=discard(buffer,bytesToDiscard);
    if (bytesToDiscard <= 0)     fail();
    return;
  }
  if (buffer.readableBytes() < Header.LEGACY_LENGTH)   return;
  int idx=buffer.readerIndex();
  int firstByte=buffer.getByte(idx++);
  Message.Direction direction=Message.Direction.extractFromVersion(firstByte);
  int version=firstByte & PROTOCOL_VERSION_MASK;
  if (version > Server.CURRENT_VERSION)   throw new ProtocolException(String.format("Invalid or unsupported protocol version (%d); highest supported is %d ",version,Server.CURRENT_VERSION));
  if (version < Server.VERSION_3 && !hasLoggedDeprecationWarning) {
    hasLoggedDeprecationWarning=true;
    logger.warn("Detected connection using native protocol version {}. Both version 1 and 2" + " of the native protocol are now deprecated and support will be removed in Cassandra 3.0." + " You are encouraged to upgrade to a client driver using version 3 of the native protocol",version);
  }
  if (version >= Server.VERSION_3 && buffer.readableBytes() < Header.MODERN_LENGTH)   return;
  int flags=buffer.getByte(idx++);
  int streamId, headerLength;
  if (version >= Server.VERSION_3) {
    streamId=buffer.getShort(idx);
    idx+=2;
    headerLength=Header.MODERN_LENGTH;
  }
 else {
    streamId=buffer.getByte(idx);
    idx++;
    headerLength=Header.LEGACY_LENGTH;
  }
  Message.Type type;
  try {
    type=Message.Type.fromOpcode(buffer.getByte(idx++),direction);
  }
 catch (  ProtocolException e) {
    throw ErrorMessage.wrap(e,streamId);
  }
  long bodyLength=buffer.getUnsignedInt(idx);
  idx+=Header.BODY_LENGTH_SIZE;
  long frameLength=bodyLength + headerLength;
  if (frameLength > MAX_FRAME_LENGTH) {
    discardingTooLongFrame=true;
    tooLongStreamId=streamId;
    tooLongFrameLength=frameLength;
    bytesToDiscard=discard(buffer,frameLength);
    if (bytesToDiscard <= 0)     fail();
    return;
  }
  if (buffer.readableBytes() < frameLength)   return;
  ByteBuf body=buffer.slice(idx,(int)bodyLength);
  body.retain();
  idx+=bodyLength;
  buffer.readerIndex(idx);
  Connection connection=ctx.channel().attr(Connection.attributeKey).get();
  if (connection == null) {
    connection=factory.newConnection(ctx.channel(),version);
    ctx.channel().attr(Connection.attributeKey).set(connection);
  }
 else   if (connection.getVersion() != version) {
    throw ErrorMessage.wrap(new ProtocolException(String.format("Invalid message version. Got %d but previous messages on this connection had version %d",version,connection.getVersion())),streamId);
  }
  results.add(new Frame(new Header(version,flags,streamId,type),body));
}
