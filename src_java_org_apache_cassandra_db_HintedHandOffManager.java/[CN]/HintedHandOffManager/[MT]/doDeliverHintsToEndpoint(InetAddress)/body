{
  UUID hostId=Gossiper.instance.getHostId(endpoint);
  logger.info("Started hinted handoff for host: {} with IP: {}",hostId,endpoint);
  final ByteBuffer hostIdBytes=ByteBuffer.wrap(UUIDGen.decompose(hostId));
  DecoratedKey epkey=StorageService.getPartitioner().decorateKey(hostIdBytes);
  final AtomicInteger rowsReplayed=new AtomicInteger(0);
  ByteBuffer startColumn=ByteBufferUtil.EMPTY_BYTE_BUFFER;
  int pageSize=calculatePageSize();
  logger.debug("Using pageSize of {}",pageSize);
  int throttleInKB=DatabaseDescriptor.getHintedHandoffThrottleInKB() / (StorageService.instance.getTokenMetadata().getAllEndpoints().size() - 1);
  RateLimiter rateLimiter=RateLimiter.create(throttleInKB == 0 ? Double.MAX_VALUE : throttleInKB * 1024);
  boolean finished=false;
  delivery:   while (true) {
    QueryFilter filter=QueryFilter.getSliceFilter(epkey,new QueryPath(SystemTable.HINTS_CF),startColumn,ByteBufferUtil.EMPTY_BYTE_BUFFER,false,pageSize);
    ColumnFamily hintsPage=ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter),(int)(System.currentTimeMillis() / 1000));
    if (pagingFinished(hintsPage,startColumn)) {
      logger.info("Finished hinted handoff of {} rows to endpoint {}",rowsReplayed,endpoint);
      finished=true;
      break;
    }
    if (!FailureDetector.instance.isAlive(endpoint)) {
      logger.info("Endpoint {} died during hint delivery; aborting ({} delivered)",endpoint,rowsReplayed);
      break;
    }
    List<WriteResponseHandler> responseHandlers=Lists.newArrayList();
    for (    final IColumn hint : hintsPage.getSortedColumns()) {
      if (hintedHandOffPaused) {
        logger.debug("Hints delivery process is paused, aborting");
        break delivery;
      }
      if (!hint.isLive())       continue;
      startColumn=hint.name();
      ByteBuffer[] components=comparator.split(hint.name());
      int version=Int32Type.instance.compose(components[1]);
      DataInputStream in=new DataInputStream(ByteBufferUtil.inputStream(hint.value()));
      RowMutation rm;
      try {
        rm=RowMutation.serializer.deserialize(in,version);
      }
 catch (      UnknownColumnFamilyException e) {
        logger.debug("Skipping delivery of hint for deleted columnfamily",e);
        deleteHint(hostIdBytes,hint.name(),hint.maxTimestamp());
        continue;
      }
catch (      IOException e) {
        throw new AssertionError(e);
      }
      Map<UUID,Long> truncationTimesCache=new HashMap<UUID,Long>();
      for (      UUID cfId : ImmutableSet.copyOf((rm.getColumnFamilyIds()))) {
        Long truncatedAt=truncationTimesCache.get(cfId);
        if (truncatedAt == null) {
          ColumnFamilyStore cfs=Table.open(rm.getTable()).getColumnFamilyStore(cfId);
          truncatedAt=cfs.getTruncationTime();
          truncationTimesCache.put(cfId,truncatedAt);
        }
        if (hint.maxTimestamp() < truncatedAt) {
          logger.debug("Skipping delivery of hint for truncated columnfamily {}" + cfId);
          rm=rm.without(cfId);
        }
      }
      if (rm.isEmpty()) {
        deleteHint(hostIdBytes,hint.name(),hint.maxTimestamp());
        continue;
      }
      MessageOut<RowMutation> message=rm.createMessage();
      rateLimiter.acquire(message.serializedSize(MessagingService.current_version));
      Runnable callback=new Runnable(){
        public void run(){
          rowsReplayed.incrementAndGet();
          deleteHint(hostIdBytes,hint.name(),hint.maxTimestamp());
        }
      }
;
      WriteResponseHandler responseHandler=new WriteResponseHandler(endpoint,WriteType.UNLOGGED_BATCH,callback);
      MessagingService.instance().sendRR(message,endpoint,responseHandler);
      responseHandlers.add(responseHandler);
    }
    for (    WriteResponseHandler handler : responseHandlers) {
      try {
        handler.get();
      }
 catch (      WriteTimeoutException e) {
        logger.info("Timed out replaying hints to {}; aborting ({} delivered)",endpoint,rowsReplayed);
        break delivery;
      }
    }
  }
  if (finished || rowsReplayed.get() >= DatabaseDescriptor.getTombstoneDebugThreshold()) {
    try {
      compact().get();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}
