{
  UUID hostId=Gossiper.instance.getHostId(endpoint);
  logger.info("Started hinted handoff for host: {} with IP: {}",hostId,endpoint);
  final ByteBuffer hostIdBytes=ByteBuffer.wrap(UUIDGen.decompose(hostId));
  DecoratedKey epkey=StorageService.getPartitioner().decorateKey(hostIdBytes);
  final AtomicInteger rowsReplayed=new AtomicInteger(0);
  int throttleInKB=DatabaseDescriptor.getHintedHandoffThrottleInKB() / (StorageService.instance.getTokenMetadata().getAllEndpoints().size() - 1);
  RateLimiter rateLimiter=RateLimiter.create(throttleInKB == 0 ? Double.MAX_VALUE : throttleInKB * 1024);
  int nowInSec=FBUtilities.nowInSeconds();
  try (OpOrder.Group op=hintStore.readOrdering.start();RowIterator iter=UnfilteredRowIterators.filter(SinglePartitionReadCommand.fullPartitionRead(SystemKeyspace.Hints,nowInSec,epkey).queryMemtableAndDisk(hintStore,op),nowInSec)){
    List<WriteResponseHandler<Mutation>> responseHandlers=Lists.newArrayList();
    while (iter.hasNext()) {
      if (!FailureDetector.instance.isAlive(endpoint)) {
        logger.info("Endpoint {} died during hint delivery; aborting ({} delivered)",endpoint,rowsReplayed);
        return;
      }
      if (hintedHandOffPaused) {
        logger.debug("Hints delivery process is paused, aborting");
        return;
      }
      if (responseHandlers.size() > MAX_SIMULTANEOUSLY_REPLAYED_HINTS && !checkDelivered(endpoint,responseHandlers,rowsReplayed))       return;
      final Row hint=iter.next();
      int version=Int32Type.instance.compose(hint.clustering().get(1));
      Cell cell=hint.getCell(hintColumn);
      final long timestamp=cell.livenessInfo().timestamp();
      DataInputStream in=new DataInputStream(ByteBufferUtil.inputStream(cell.value()));
      Mutation mutation;
      try {
        mutation=Mutation.serializer.deserialize(in,version);
      }
 catch (      UnknownColumnFamilyException e) {
        logger.debug("Skipping delivery of hint for deleted table",e);
        deleteHint(hostIdBytes,hint.clustering(),timestamp);
        continue;
      }
catch (      IOException e) {
        throw new AssertionError(e);
      }
      for (      UUID cfId : mutation.getColumnFamilyIds()) {
        if (timestamp <= SystemKeyspace.getTruncatedAt(cfId)) {
          logger.debug("Skipping delivery of hint for truncated table {}",cfId);
          mutation=mutation.without(cfId);
        }
      }
      if (mutation.isEmpty()) {
        deleteHint(hostIdBytes,hint.clustering(),timestamp);
        continue;
      }
      MessageOut<Mutation> message=mutation.createMessage();
      rateLimiter.acquire(message.serializedSize(MessagingService.current_version));
      Runnable callback=new Runnable(){
        public void run(){
          rowsReplayed.incrementAndGet();
          deleteHint(hostIdBytes,hint.clustering(),timestamp);
        }
      }
;
      WriteResponseHandler<Mutation> responseHandler=new WriteResponseHandler<>(endpoint,WriteType.SIMPLE,callback);
      MessagingService.instance().sendRR(message,endpoint,responseHandler,false);
      responseHandlers.add(responseHandler);
    }
    if (checkDelivered(endpoint,responseHandlers,rowsReplayed))     logger.info("Finished hinted handoff of {} rows to endpoint {}",rowsReplayed,endpoint);
  }
 }
