{
  if (keysWritten % minIndexInterval == 0) {
    boolean shouldSkip=false;
    for (    int start : startPoints) {
      if ((indexIntervalMatches - start) % BASE_SAMPLING_LEVEL == 0) {
        shouldSkip=true;
        break;
      }
    }
    if (!shouldSkip) {
      keys.add(decoratedKey);
      offheapSize+=decoratedKey.key.remaining();
      positions.add(indexPosition);
      offheapSize+=TypeSizes.NATIVE.sizeof(indexPosition);
    }
    indexIntervalMatches++;
  }
  keysWritten++;
  return this;
}
