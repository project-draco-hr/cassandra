{
  ThriftValidation.validateConsistencyLevel(keyspace,select.getConsistencyLevel(),RequestType.READ);
  if (!select.isKeyRange() && (select.getKeyFinish() != null))   throw new InvalidRequestException("Key range clauses must include a start key (i.e. KEY > term)");
  if (select.isKeyRange() && select.getKeys().size() > 0)   throw new InvalidRequestException("You cannot combine key range and by-key clauses in a SELECT");
  if (select.isKeyRange() && (select.getKeyFinish() != null) && (select.getColumnRelations().size() > 0))   throw new InvalidRequestException("You cannot combine key range and by-column clauses in a SELECT");
  if (!select.isMultiKey() && select.getKeys().size() > 1)   throw new InvalidRequestException("You cannot use more than one KEY = in a SELECT");
  AbstractType<?> comparator=select.getComparator(keyspace);
  if (select.getColumnRelations().size() > 0) {
    Set<ByteBuffer> indexed=Table.open(keyspace).getColumnFamilyStore(select.getColumnFamily()).indexManager.getIndexedColumns();
    for (    Relation relation : select.getColumnRelations()) {
      if ((relation.operator() == RelationType.EQ) && indexed.contains(relation.getEntity().getByteBuffer(comparator)))       return;
    }
    throw new InvalidRequestException("No indexed columns present in by-columns clause with \"equals\" operator");
  }
}
