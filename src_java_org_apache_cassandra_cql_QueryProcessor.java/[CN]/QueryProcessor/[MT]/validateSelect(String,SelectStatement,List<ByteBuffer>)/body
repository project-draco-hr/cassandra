{
  select.getConsistencyLevel().validateForRead(keyspace);
  if (!select.isKeyRange() && (select.getKeyFinish() != null))   throw new InvalidRequestException("Key range clauses must include a start key (i.e. KEY > term)");
  if (select.isKeyRange() && select.getKeys().size() > 0)   throw new InvalidRequestException("You cannot combine key range and by-key clauses in a SELECT");
  if (select.isKeyRange() && (select.getKeyFinish() != null) && (select.getColumnRelations().size() > 0))   throw new InvalidRequestException("You cannot combine key range and by-column clauses in a SELECT");
  if (!select.isMultiKey() && select.getKeys().size() > 1)   throw new InvalidRequestException("You cannot use more than one KEY = in a SELECT");
  if (select.getColumnRelations().size() > 0) {
    ColumnFamilyStore cfstore=Keyspace.open(keyspace).getColumnFamilyStore(select.getColumnFamily());
    CellNameType comparator=cfstore.metadata.comparator;
    AbstractType<?> at=comparator.asAbstractType();
    SecondaryIndexManager idxManager=cfstore.indexManager;
    for (    Relation relation : select.getColumnRelations()) {
      ByteBuffer name=relation.getEntity().getByteBuffer(at,variables);
      if ((relation.operator() == RelationType.EQ) && idxManager.indexes(comparator.cellFromByteBuffer(name)))       return;
    }
    throw new InvalidRequestException("No indexed columns present in by-columns clause with \"equals\" operator");
  }
}
