{
  logger.trace("CQL QUERY: {}",queryString);
  CqlParser parser=getParser(queryString);
  CQLStatement statement=parser.query();
  parser.throwLastRecognitionError();
  String keyspace=clientState.getKeyspace();
  CqlResult avroResult=new CqlResult();
switch (statement.type) {
case SELECT:
    SelectStatement select=(SelectStatement)statement.statement;
  validateColumnFamily(keyspace,select.getColumnFamily());
validateSelect(keyspace,select);
List<org.apache.cassandra.db.Row> rows=null;
if (!select.isKeyRange() && (select.getKeys().size() > 0)) {
rows=getSlice(keyspace,select);
if (select.isCountOperation()) {
avroResult.type=CqlResultType.INT;
if (rows.size() > 0) avroResult.num=rows.get(0).cf != null ? rows.get(0).cf.getSortedColumns().size() : 0;
 else avroResult.num=0;
return avroResult;
}
}
 else {
if ((select.getKeyFinish() != null) || (select.getColumnRelations().size() == 0)) {
rows=multiRangeSlice(keyspace,select);
}
 else {
rows=getIndexedSlices(keyspace,select);
}
}
List<CqlRow> avroRows=new ArrayList<CqlRow>();
avroResult.type=CqlResultType.ROWS;
for (org.apache.cassandra.db.Row row : rows) {
if (row.cf == null) continue;
List<Column> avroColumns=new ArrayList<Column>();
for (IColumn column : row.cf.getSortedColumns()) {
if (column.isMarkedForDelete()) continue;
Column avroColumn=new Column();
avroColumn.name=column.name();
avroColumn.value=column.value();
avroColumn.timestamp=column.timestamp();
avroColumns.add(avroColumn);
}
CqlRow avroRow=new CqlRow();
avroRow.key=row.key.key;
avroRow.columns=avroColumns;
if (select.isColumnsReversed()) Collections.reverse(avroRow.columns);
avroRows.add(avroRow);
}
avroResult.rows=avroRows;
return avroResult;
case UPDATE:
UpdateStatement update=(UpdateStatement)statement.statement;
batchUpdate(keyspace,Collections.singletonList(update),update.getConsistencyLevel());
avroResult.type=CqlResultType.VOID;
return avroResult;
case BATCH_UPDATE:
BatchUpdateStatement batch=(BatchUpdateStatement)statement.statement;
for (UpdateStatement up : batch.getUpdates()) if (up.isSetConsistencyLevel()) throw newInvalidRequestException("Consistency level must be set on the BATCH, not individual UPDATE statements");
batchUpdate(keyspace,batch.getUpdates(),batch.getConsistencyLevel());
avroResult.type=CqlResultType.VOID;
return avroResult;
case USE:
clientState.setKeyspace((String)statement.statement);
avroResult.type=CqlResultType.VOID;
return avroResult;
case TRUNCATE:
String columnFamily=(String)statement.statement;
try {
StorageProxy.truncateBlocking(keyspace,columnFamily);
}
 catch (org.apache.cassandra.thrift.UnavailableException e) {
throw newUnavailableException(e);
}
catch (TimeoutException e) {
throw newUnavailableException(e);
}
catch (IOException e) {
throw newUnavailableException(e);
}
avroResult.type=CqlResultType.VOID;
return avroResult;
case DELETE:
DeleteStatement delete=(DeleteStatement)statement.statement;
List<RowMutation> rowMutations=new ArrayList<RowMutation>();
for (Term key : delete.getKeys()) {
RowMutation rm=new RowMutation(keyspace,key.getByteBuffer());
if (delete.getColumns().size() < 1) rm.delete(new QueryPath(delete.getColumnFamily()),System.currentTimeMillis());
 else {
for (Term column : delete.getColumns()) rm.delete(new QueryPath(delete.getColumnFamily(),null,column.getByteBuffer()),System.currentTimeMillis());
}
rowMutations.add(rm);
}
try {
StorageProxy.mutate(rowMutations,delete.getConsistencyLevel());
}
 catch (org.apache.cassandra.thrift.UnavailableException e) {
throw newUnavailableException(e);
}
catch (TimeoutException e) {
throw new TimedOutException();
}
avroResult.type=CqlResultType.VOID;
return avroResult;
}
return null;
}
