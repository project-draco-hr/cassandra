{
  logger.trace("CQL QUERY: {}",queryString);
  CQLStatement statement=getStatement(queryString);
  String keyspace=null;
  if (StatementType.requiresKeyspace.contains(statement.type))   keyspace=clientState.getKeyspace();
  CqlResult result=new CqlResult();
  logger.debug("CQL statement type: {}",statement.type.toString());
switch (statement.type) {
case SELECT:
    SelectStatement select=(SelectStatement)statement.statement;
  clientState.hasColumnFamilyAccess(select.getColumnFamily(),Permission.READ);
validateColumnFamily(keyspace,select.getColumnFamily(),false);
validateSelect(keyspace,select);
List<org.apache.cassandra.db.Row> rows=null;
if (!select.isKeyRange() && (select.getKeys().size() > 0)) {
rows=getSlice(keyspace,select);
if (select.isCountOperation()) {
result.type=CqlResultType.INT;
if (rows.size() > 0) result.setNum(rows.get(0).cf != null ? rows.get(0).cf.getSortedColumns().size() : 0);
 else result.setNum(0);
return result;
}
}
 else {
if ((select.getKeyFinish() != null) || (select.getColumnRelations().size() == 0)) {
rows=multiRangeSlice(keyspace,select);
}
 else {
rows=getIndexedSlices(keyspace,select);
}
}
List<CqlRow> cqlRows=new ArrayList<CqlRow>();
result.type=CqlResultType.ROWS;
for (org.apache.cassandra.db.Row row : rows) {
if (row.cf == null) continue;
List<Column> thriftColumns=new ArrayList<Column>();
for (IColumn column : row.cf.getSortedColumns()) {
if (column.isMarkedForDelete()) continue;
Column c=new Column();
c.name=column.name();
c.value=column.value();
c.timestamp=column.timestamp();
thriftColumns.add(c);
}
CqlRow cqlRow=new CqlRow();
cqlRow.key=row.key.key;
cqlRow.columns=thriftColumns;
if (select.isColumnsReversed()) Collections.reverse(cqlRow.columns);
cqlRows.add(cqlRow);
}
result.rows=cqlRows;
return result;
case INSERT:
case UPDATE:
UpdateStatement update=(UpdateStatement)statement.statement;
batchUpdate(clientState,Collections.singletonList(update),update.getConsistencyLevel());
result.type=CqlResultType.VOID;
return result;
case BATCH_UPDATE:
BatchUpdateStatement batch=(BatchUpdateStatement)statement.statement;
for (UpdateStatement up : batch.getUpdates()) if (up.isSetConsistencyLevel()) throw new InvalidRequestException("Consistency level must be set on the BATCH, not individual UPDATE statements");
batchUpdate(clientState,batch.getUpdates(),batch.getConsistencyLevel());
result.type=CqlResultType.VOID;
return result;
case USE:
clientState.setKeyspace((String)statement.statement);
result.type=CqlResultType.VOID;
return result;
case TRUNCATE:
String columnFamily=(String)statement.statement;
clientState.hasColumnFamilyAccess(columnFamily,Permission.WRITE);
try {
StorageProxy.truncateBlocking(keyspace,columnFamily);
}
 catch (TimeoutException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
catch (IOException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
result.type=CqlResultType.VOID;
return result;
case DELETE:
DeleteStatement delete=(DeleteStatement)statement.statement;
clientState.hasColumnFamilyAccess(delete.getColumnFamily(),Permission.WRITE);
CFMetaData metadata=validateColumnFamily(keyspace,delete.getColumnFamily(),false);
AbstractType<?> comparator=metadata.getComparatorFor(null);
AbstractType<?> keyType=DatabaseDescriptor.getCFMetaData(keyspace,delete.getColumnFamily()).getKeyValidator();
List<RowMutation> rowMutations=new ArrayList<RowMutation>();
for (Term key : delete.getKeys()) {
RowMutation rm=new RowMutation(keyspace,key.getByteBuffer(keyType));
if (delete.getColumns().size() < 1) rm.delete(new QueryPath(delete.getColumnFamily()),System.currentTimeMillis());
 else {
for (Term column : delete.getColumns()) {
ByteBuffer columnName=column.getByteBuffer(comparator);
validateColumnName(columnName);
rm.delete(new QueryPath(delete.getColumnFamily(),null,columnName),System.currentTimeMillis());
}
}
rowMutations.add(rm);
}
try {
StorageProxy.mutate(rowMutations,delete.getConsistencyLevel());
}
 catch (TimeoutException e) {
throw new TimedOutException();
}
result.type=CqlResultType.VOID;
return result;
case CREATE_KEYSPACE:
CreateKeyspaceStatement create=(CreateKeyspaceStatement)statement.statement;
create.validate();
clientState.hasKeyspaceListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
KSMetaData ksm=new KSMetaData(create.getName(),AbstractReplicationStrategy.getClass(create.getStrategyClass()),create.getStrategyOptions());
applyMigrationOnStage(new AddKeyspace(ksm));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_COLUMNFAMILY:
CreateColumnFamilyStatement createCf=(CreateColumnFamilyStatement)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new AddColumnFamily(createCf.getCFMetaData(keyspace)));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_INDEX:
CreateIndexStatement createIdx=(CreateIndexStatement)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
CFMetaData oldCfm=DatabaseDescriptor.getCFMetaData(CFMetaData.getId(keyspace,createIdx.getColumnFamily()));
if (oldCfm == null) throw new InvalidRequestException("No such column family: " + createIdx.getColumnFamily());
ByteBuffer columnName=createIdx.getColumnName().getByteBuffer();
ColumnDefinition columnDef=oldCfm.getColumn_metadata().get(columnName);
if (columnDef != null) {
if (columnDef.getIndexType() != null) throw new InvalidRequestException("Index exists");
columnDef.setIndexName(createIdx.getIndexName());
columnDef.setIndexType(org.apache.cassandra.thrift.IndexType.KEYS);
}
 else {
columnDef=new ColumnDefinition(columnName,DatabaseDescriptor.getValueValidator(keyspace,createIdx.getColumnFamily(),columnName),org.apache.cassandra.thrift.IndexType.KEYS,createIdx.getIndexName());
}
CfDef cfamilyDef=CFMetaData.convertToAvro(oldCfm);
cfamilyDef.column_metadata.add(columnDef.deflate());
try {
applyMigrationOnStage(new UpdateColumnFamily(cfamilyDef));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_KEYSPACE:
String deleteKeyspace=(String)statement.statement;
clientState.hasKeyspaceListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropKeyspace(deleteKeyspace));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_COLUMNFAMILY:
String deleteColumnFamily=(String)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropColumnFamily(keyspace,deleteColumnFamily));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
}
return null;
}
