{
  logger.trace("CQL QUERY: {}",queryString);
  CQLStatement statement=getStatement(queryString);
  String keyspace=null;
  if (StatementType.requiresKeyspace.contains(statement.type))   keyspace=clientState.getKeyspace();
  CqlResult result=new CqlResult();
  logger.debug("CQL statement type: {}",statement.type.toString());
  CFMetaData metadata;
  AbstractType<?> comparator;
switch (statement.type) {
case SELECT:
    SelectStatement select=(SelectStatement)statement.statement;
  clientState.hasColumnFamilyAccess(select.getColumnFamily(),Permission.READ);
metadata=validateColumnFamily(keyspace,select.getColumnFamily(),false);
comparator=metadata.getComparatorFor(null);
validateSelect(keyspace,select);
List<org.apache.cassandra.db.Row> rows;
if (!select.isKeyRange() && (select.getKeys().size() > 0)) {
rows=getSlice(keyspace,select);
if (select.isCountOperation()) {
result.type=CqlResultType.INT;
if (rows.size() > 0) result.setNum(rows.get(0).cf != null ? rows.get(0).cf.getSortedColumns().size() : 0);
 else result.setNum(0);
return result;
}
}
 else {
if ((select.getKeyFinish() != null) || (select.getColumnRelations().size() == 0)) {
rows=multiRangeSlice(keyspace,select);
}
 else {
rows=getIndexedSlices(keyspace,select);
}
}
List<CqlRow> cqlRows=new ArrayList<CqlRow>();
result.type=CqlResultType.ROWS;
for (org.apache.cassandra.db.Row row : rows) {
if (row.cf == null) continue;
List<Column> thriftColumns=extractThriftColumns(select,comparator,row);
CqlRow cqlRow=new CqlRow();
cqlRow.key=row.key.key;
cqlRow.columns=thriftColumns;
if (select.isColumnsReversed()) Collections.reverse(cqlRow.columns);
cqlRows.add(cqlRow);
}
result.rows=cqlRows;
return result;
case INSERT:
case UPDATE:
UpdateStatement update=(UpdateStatement)statement.statement;
batchUpdate(clientState,Collections.singletonList(update),update.getConsistencyLevel());
result.type=CqlResultType.VOID;
return result;
case BATCH:
BatchStatement batch=(BatchStatement)statement.statement;
for (AbstractModification up : batch.getStatements()) if (up.isSetConsistencyLevel()) throw new InvalidRequestException("Consistency level must be set on the BATCH, not individual statements");
try {
StorageProxy.mutate(batch.getMutations(keyspace,clientState),batch.getConsistencyLevel());
}
 catch (org.apache.cassandra.thrift.UnavailableException e) {
throw new UnavailableException();
}
catch (TimeoutException e) {
throw new TimedOutException();
}
result.type=CqlResultType.VOID;
return result;
case USE:
clientState.setKeyspace((String)statement.statement);
result.type=CqlResultType.VOID;
return result;
case TRUNCATE:
String columnFamily=(String)statement.statement;
validateColumnFamily(keyspace,columnFamily);
clientState.hasColumnFamilyAccess(columnFamily,Permission.WRITE);
try {
StorageProxy.truncateBlocking(keyspace,columnFamily);
}
 catch (TimeoutException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
catch (IOException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
result.type=CqlResultType.VOID;
return result;
case DELETE:
DeleteStatement delete=(DeleteStatement)statement.statement;
try {
StorageProxy.mutate(delete.prepareRowMutations(keyspace,clientState),delete.getConsistencyLevel());
}
 catch (TimeoutException e) {
throw new TimedOutException();
}
result.type=CqlResultType.VOID;
return result;
case CREATE_KEYSPACE:
CreateKeyspaceStatement create=(CreateKeyspaceStatement)statement.statement;
create.validate();
clientState.hasKeyspaceListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
KSMetaData ksm=new KSMetaData(create.getName(),AbstractReplicationStrategy.getClass(create.getStrategyClass()),create.getStrategyOptions());
applyMigrationOnStage(new AddKeyspace(ksm));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_COLUMNFAMILY:
CreateColumnFamilyStatement createCf=(CreateColumnFamilyStatement)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new AddColumnFamily(createCf.getCFMetaData(keyspace)));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_INDEX:
CreateIndexStatement createIdx=(CreateIndexStatement)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
CFMetaData oldCfm=DatabaseDescriptor.getCFMetaData(CFMetaData.getId(keyspace,createIdx.getColumnFamily()));
if (oldCfm == null) throw new InvalidRequestException("No such column family: " + createIdx.getColumnFamily());
ByteBuffer columnName=createIdx.getColumnName().getByteBuffer();
ColumnDefinition columnDef=oldCfm.getColumn_metadata().get(columnName);
if (columnDef != null) {
if (columnDef.getIndexType() != null) throw new InvalidRequestException("Index exists");
columnDef.setIndexName(createIdx.getIndexName());
columnDef.setIndexType(org.apache.cassandra.thrift.IndexType.KEYS);
}
 else {
columnDef=new ColumnDefinition(columnName,DatabaseDescriptor.getValueValidator(keyspace,createIdx.getColumnFamily(),columnName),org.apache.cassandra.thrift.IndexType.KEYS,createIdx.getIndexName());
}
CfDef cfamilyDef=CFMetaData.convertToAvro(oldCfm);
cfamilyDef.column_metadata.add(columnDef.deflate());
try {
applyMigrationOnStage(new UpdateColumnFamily(cfamilyDef));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_KEYSPACE:
String deleteKeyspace=(String)statement.statement;
clientState.hasKeyspaceListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropKeyspace(deleteKeyspace));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_COLUMNFAMILY:
String deleteColumnFamily=(String)statement.statement;
clientState.hasColumnFamilyListAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropColumnFamily(keyspace,deleteColumnFamily));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
}
return null;
}
