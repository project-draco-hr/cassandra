{
  logger.trace("CQL QUERY: {}",queryString);
  CQLStatement statement=getStatement(queryString);
  String keyspace=null;
  if (StatementType.requiresKeyspace.contains(statement.type))   keyspace=clientState.getKeyspace();
  CqlResult result=new CqlResult();
  logger.debug("CQL statement type: {}",statement.type.toString());
  CFMetaData metadata;
switch (statement.type) {
case SELECT:
    SelectStatement select=(SelectStatement)statement.statement;
  clientState.hasColumnFamilyAccess(select.getColumnFamily(),Permission.READ);
metadata=validateColumnFamily(keyspace,select.getColumnFamily());
select.extractKeyAliasFromColumns(metadata);
if (select.getKeys().size() > 0) validateKeyAlias(metadata,select.getKeyAlias());
validateSelect(keyspace,select);
List<org.apache.cassandra.db.Row> rows;
if (!select.isKeyRange() && (select.getKeys().size() > 0)) {
rows=getSlice(keyspace,select);
if (select.isCountOperation()) {
result.type=CqlResultType.INT;
if (rows.size() > 0) result.setNum(rows.get(0).cf != null ? rows.get(0).cf.getSortedColumns().size() : 0);
 else result.setNum(0);
return result;
}
}
 else {
if ((select.getKeyFinish() != null) || (select.getColumnRelations().size() == 0)) {
rows=multiRangeSlice(keyspace,select);
}
 else {
rows=getIndexedSlices(keyspace,select);
}
}
List<CqlRow> cqlRows=new ArrayList<CqlRow>();
result.type=CqlResultType.ROWS;
for (org.apache.cassandra.db.Row row : rows) {
if (row.cf == null) continue;
List<Column> thriftColumns=extractThriftColumns(select,metadata,row);
CqlRow cqlRow=new CqlRow();
cqlRow.key=row.key.key;
cqlRow.columns=thriftColumns;
if (select.isColumnsReversed()) Collections.reverse(cqlRow.columns);
cqlRows.add(cqlRow);
}
result.rows=cqlRows;
return result;
case INSERT:
case UPDATE:
UpdateStatement update=(UpdateStatement)statement.statement;
batchUpdate(clientState,Collections.singletonList(update),update.getConsistencyLevel());
result.type=CqlResultType.VOID;
return result;
case BATCH:
BatchStatement batch=(BatchStatement)statement.statement;
if (batch.getTimeToLive() != 0) throw new InvalidRequestException("Global TTL on the BATCH statement is not supported.");
for (AbstractModification up : batch.getStatements()) {
if (up.isSetConsistencyLevel()) throw new InvalidRequestException("Consistency level must be set on the BATCH, not individual statements");
if (batch.isSetTimestamp() && up.isSetTimestamp()) throw new InvalidRequestException("Timestamp must be set either on BATCH or individual statements");
}
try {
StorageProxy.mutate(batch.getMutations(keyspace,clientState),batch.getConsistencyLevel());
}
 catch (org.apache.cassandra.thrift.UnavailableException e) {
throw new UnavailableException();
}
catch (TimeoutException e) {
throw new TimedOutException();
}
result.type=CqlResultType.VOID;
return result;
case USE:
clientState.setKeyspace((String)statement.statement);
result.type=CqlResultType.VOID;
return result;
case TRUNCATE:
String columnFamily=(String)statement.statement;
validateColumnFamily(keyspace,columnFamily);
clientState.hasColumnFamilyAccess(columnFamily,Permission.WRITE);
try {
StorageProxy.truncateBlocking(keyspace,columnFamily);
}
 catch (TimeoutException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
catch (IOException e) {
throw (UnavailableException)new UnavailableException().initCause(e);
}
result.type=CqlResultType.VOID;
return result;
case DELETE:
DeleteStatement delete=(DeleteStatement)statement.statement;
try {
StorageProxy.mutate(delete.prepareRowMutations(keyspace,clientState),delete.getConsistencyLevel());
}
 catch (TimeoutException e) {
throw new TimedOutException();
}
result.type=CqlResultType.VOID;
return result;
case CREATE_KEYSPACE:
CreateKeyspaceStatement create=(CreateKeyspaceStatement)statement.statement;
create.validate();
clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
validateSchemaAgreement();
try {
KsDef ksd=new KsDef(create.getName(),create.getStrategyClass(),Collections.<CfDef>emptyList()).setStrategy_options(create.getStrategyOptions());
ThriftValidation.validateKsDef(ksd);
ThriftValidation.validateKeyspaceNotYetExisting(create.getName());
applyMigrationOnStage(new AddKeyspace(KSMetaData.fromThrift(ksd)));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_COLUMNFAMILY:
CreateColumnFamilyStatement createCf=(CreateColumnFamilyStatement)statement.statement;
clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new AddColumnFamily(createCf.getCFMetaData(keyspace)));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_INDEX:
CreateIndexStatement createIdx=(CreateIndexStatement)statement.statement;
clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
validateSchemaAgreement();
CFMetaData oldCfm=Schema.instance.getCFMetaData(keyspace,createIdx.getColumnFamily());
if (oldCfm == null) throw new InvalidRequestException("No such column family: " + createIdx.getColumnFamily());
boolean columnExists=false;
ByteBuffer columnName=createIdx.getColumnName().getByteBuffer();
CfDef cf_def=oldCfm.toThrift();
for (ColumnDef cd : cf_def.column_metadata) {
if (cd.name.equals(columnName)) {
if (cd.index_type != null) throw new InvalidRequestException("Index already exists");
logger.debug("Updating column {} definition for index {}",oldCfm.comparator.getString(columnName),createIdx.getIndexName());
cd.setIndex_type(IndexType.KEYS);
cd.setIndex_name(createIdx.getIndexName());
columnExists=true;
break;
}
}
if (!columnExists) throw new InvalidRequestException("No column definition found for column " + oldCfm.comparator.getString(columnName));
CFMetaData.addDefaultIndexNames(cf_def);
ThriftValidation.validateCfDef(cf_def,oldCfm);
try {
org.apache.cassandra.db.migration.avro.CfDef result1;
try {
result1=CFMetaData.fromThrift(cf_def).toAvro();
}
 catch (Exception e) {
throw new RuntimeException(e);
}
applyMigrationOnStage(new UpdateColumnFamily(result1));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_INDEX:
DropIndexStatement dropIdx=(DropIndexStatement)statement.statement;
clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(dropIdx.generateMutation(clientState.getKeyspace()));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_KEYSPACE:
String deleteKeyspace=(String)statement.statement;
clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropKeyspace(deleteKeyspace));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_COLUMNFAMILY:
String deleteColumnFamily=(String)statement.statement;
clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new DropColumnFamily(keyspace,deleteColumnFamily));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case ALTER_TABLE:
AlterTableStatement alterTable=(AlterTableStatement)statement.statement;
validateColumnFamily(keyspace,alterTable.columnFamily);
clientState.hasColumnFamilyAccess(alterTable.columnFamily,Permission.WRITE);
validateSchemaAgreement();
try {
applyMigrationOnStage(new UpdateColumnFamily(alterTable.getCfDef(keyspace)));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
catch (IOException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
}
return null;
}
