{
  IPartitioner<?> p=StorageService.getPartitioner();
  AbstractType<?> keyType=Schema.instance.getCFMetaData(metadata.ksName,select.getColumnFamily()).getKeyValidator();
  ByteBuffer startKeyBytes=(select.getKeyStart() != null) ? select.getKeyStart().getByteBuffer(keyType,variables) : null;
  ByteBuffer finishKeyBytes=(select.getKeyFinish() != null) ? select.getKeyFinish().getByteBuffer(keyType,variables) : null;
  RowPosition startKey=RowPosition.forKey(startKeyBytes,p), finishKey=RowPosition.forKey(finishKeyBytes,p);
  if (startKey.compareTo(finishKey) > 0 && !finishKey.isMinimum(p)) {
    if (p instanceof RandomPartitioner)     throw new InvalidRequestException("Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner");
 else     throw new InvalidRequestException("Start key must sort before (or equal to) finish key in your partitioner!");
  }
  AbstractBounds<RowPosition> bounds=new Bounds<RowPosition>(startKey,finishKey);
  IDiskAtomFilter columnFilter=filterFromSelect(select,metadata,variables);
  validateFilter(metadata,columnFilter);
  List<Relation> columnRelations=select.getColumnRelations();
  List<IndexExpression> expressions=new ArrayList<IndexExpression>(columnRelations.size());
  for (  Relation columnRelation : columnRelations) {
    ByteBuffer entity=columnRelation.getEntity().getByteBuffer(metadata.comparator.asAbstractType(),variables);
    ByteBuffer value=columnRelation.getValue().getByteBuffer(metadata.getValueValidator(metadata.comparator.cellFromByteBuffer(entity)),variables);
    expressions.add(new IndexExpression(entity,IndexExpression.Operator.valueOf(columnRelation.operator().toString()),value));
  }
  int limit=select.isKeyRange() && select.getKeyStart() != null ? select.getNumRecords() + 1 : select.getNumRecords();
  List<org.apache.cassandra.db.Row> rows=StorageProxy.getRangeSlice(new RangeSliceCommand(metadata.ksName,select.getColumnFamily(),now,columnFilter,bounds,expressions,limit),select.getConsistencyLevel());
  if (select.getKeyStart() != null && !select.includeStartKey() && !rows.isEmpty()) {
    if (rows.get(0).key.key.equals(startKeyBytes))     rows.remove(0);
  }
  if (select.getKeyFinish() != null && !select.includeFinishKey() && !rows.isEmpty()) {
    int lastIndex=rows.size() - 1;
    if (rows.get(lastIndex).key.key.equals(finishKeyBytes))     rows.remove(lastIndex);
  }
  return rows.subList(0,select.getNumRecords() < rows.size() ? select.getNumRecords() : rows.size());
}
