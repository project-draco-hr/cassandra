{
  List<org.apache.cassandra.db.Row> rows=null;
  QueryPath queryPath=new QueryPath(select.getColumnFamily());
  List<ReadCommand> commands=new ArrayList<ReadCommand>();
  for (  Term keyName : select.getKeyPredicates().getTerms()) {
    ByteBuffer key=keyName.getByteBuffer();
    validateKey(key);
    if ((!select.getColumnPredicates().isRange()) && select.getColumnPredicates().isInitialized()) {
      Collection<ByteBuffer> columnNames=new ArrayList<ByteBuffer>();
      for (      Term column : select.getColumnPredicates().getTerms())       columnNames.add(column.getByteBuffer());
      commands.add(new SliceByNamesReadCommand(keyspace,key,queryPath,columnNames));
    }
 else {
      commands.add(new SliceFromReadCommand(keyspace,key,queryPath,select.getColumnPredicates().getStart().getByteBuffer(),select.getColumnPredicates().getFinish().getByteBuffer(),select.reversed(),select.getNumColumns()));
    }
  }
  try {
    rows=StorageProxy.readProtocol(commands,select.getConsistencyLevel());
  }
 catch (  TimeoutException e) {
    throw new TimedOutException();
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  org.apache.cassandra.thrift.UnavailableException e) {
    UnavailableException error=new UnavailableException();
    error.initCause(e);
    throw error;
  }
catch (  org.apache.cassandra.thrift.InvalidRequestException e) {
    InvalidRequestException error=new InvalidRequestException();
    error.initCause(e);
    throw error;
  }
  return rows;
}
