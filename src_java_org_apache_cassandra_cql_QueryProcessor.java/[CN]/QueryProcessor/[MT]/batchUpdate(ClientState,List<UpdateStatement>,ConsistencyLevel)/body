{
  String keyspace=clientState.getKeyspace();
  List<RowMutation> rowMutations=new ArrayList<RowMutation>();
  List<String> cfamsSeen=new ArrayList<String>();
  for (  UpdateStatement update : updateStatements) {
    String cfname=update.getColumnFamily();
    if (!(cfamsSeen.contains(update.getColumnFamily()))) {
      clientState.hasColumnFamilyAccess(update.getColumnFamily(),Permission.WRITE);
      cfamsSeen.add(update.getColumnFamily());
    }
    ByteBuffer key=update.getKey().getByteBuffer(AsciiType.instance);
    validateKey(key);
    validateColumnFamily(keyspace,cfname);
    validateKeyType(key,keyspace,cfname);
    AbstractType<?> comparator=update.getComparator(keyspace);
    RowMutation rm=new RowMutation(keyspace,key);
    for (    Map.Entry<Term,Term> column : update.getColumns().entrySet()) {
      ByteBuffer colName=column.getKey().getByteBuffer(comparator);
      ByteBuffer colValue=column.getValue().getByteBuffer(update.getValueValidator(keyspace,colName));
      validateColumn(keyspace,update.getColumnFamily(),colName,colValue);
      rm.add(new QueryPath(update.getColumnFamily(),null,colName),colValue,System.currentTimeMillis());
    }
    rowMutations.add(rm);
  }
  try {
    StorageProxy.mutate(rowMutations,consistency);
  }
 catch (  org.apache.cassandra.thrift.UnavailableException e) {
    throw new UnavailableException();
  }
catch (  TimeoutException e) {
    throw new TimedOutException();
  }
}
