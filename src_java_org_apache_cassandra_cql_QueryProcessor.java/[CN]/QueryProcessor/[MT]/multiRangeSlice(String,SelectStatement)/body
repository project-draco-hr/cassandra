{
  List<org.apache.cassandra.db.Row> rows;
  IPartitioner<?> p=StorageService.getPartitioner();
  AbstractType<?> keyType=DatabaseDescriptor.getCFMetaData(keyspace,select.getColumnFamily()).getKeyValidator();
  ByteBuffer startKey=(select.getKeyStart() != null) ? select.getKeyStart().getByteBuffer(keyType) : (new Term()).getByteBuffer();
  ByteBuffer finishKey=(select.getKeyFinish() != null) ? select.getKeyFinish().getByteBuffer(keyType) : (new Term()).getByteBuffer();
  Token startToken=p.getToken(startKey), finishToken=p.getToken(finishKey);
  if (startToken.compareTo(finishToken) > 0 && !finishToken.equals(p.getMinimumToken())) {
    if (p instanceof RandomPartitioner)     throw new InvalidRequestException("Start key's md5 sorts after end key's md5. This is not allowed; you probably should not specify end key at all, under RandomPartitioner");
 else     throw new InvalidRequestException("Start key must sort before (or equal to) finish key in your partitioner!");
  }
  AbstractBounds bounds=new Bounds(startToken,finishToken);
  CFMetaData metadata=validateColumnFamily(keyspace,select.getColumnFamily(),false);
  AbstractType<?> comparator=metadata.getComparatorFor(null);
  SlicePredicate thriftSlicePredicate=slicePredicateFromSelect(select,comparator);
  validateSlicePredicate(metadata,thriftSlicePredicate);
  int limit=select.isKeyRange() && select.getKeyStart() != null ? select.getNumRecords() + 1 : select.getNumRecords();
  try {
    rows=StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace,select.getColumnFamily(),null,thriftSlicePredicate,bounds,limit),select.getConsistencyLevel());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  org.apache.cassandra.thrift.UnavailableException e) {
    throw new UnavailableException();
  }
catch (  TimeoutException e) {
    throw new TimedOutException();
  }
  if (select.getKeyStart() != null && !select.includeStartKey()) {
    if (rows.get(0).key.key.equals(startKey))     rows.remove(0);
  }
  if (select.getKeyFinish() != null && !select.includeFinishKey()) {
    int lastIndex=rows.size() - 1;
    if (rows.get(lastIndex).key.key.equals(finishKey))     rows.remove(lastIndex);
  }
  return rows.subList(0,select.getNumRecords() < rows.size() ? select.getNumRecords() : rows.size());
}
