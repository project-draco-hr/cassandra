{
  List<org.apache.cassandra.db.Row> rows=null;
  IPartitioner<?> p=StorageService.getPartitioner();
  AbstractBounds bounds=new Bounds(p.getToken(select.getKeyStart().getByteBuffer()),p.getToken(select.getKeyFinish().getByteBuffer()));
  SlicePredicate thriftSlicePredicate=new SlicePredicate();
  if (select.isColumnRange() || select.getColumnNames().size() == 0) {
    SliceRange sliceRange=new SliceRange();
    sliceRange.start=select.getColumnStart().getByteBuffer();
    sliceRange.finish=select.getColumnFinish().getByteBuffer();
    sliceRange.reversed=false;
    sliceRange.count=select.getColumnsLimit();
    thriftSlicePredicate.slice_range=sliceRange;
  }
 else {
    List<ByteBuffer> columnNames=new ArrayList<ByteBuffer>();
    for (    Term column : select.getColumnNames())     columnNames.add(column.getByteBuffer());
    thriftSlicePredicate.column_names=columnNames;
  }
  try {
    rows=StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace,select.getColumnFamily(),null,thriftSlicePredicate,bounds,select.getNumRecords()),select.getConsistencyLevel());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  org.apache.cassandra.thrift.UnavailableException e) {
    throw new UnavailableException();
  }
catch (  TimeoutException e) {
    throw new TimedOutException();
  }
  return rows;
}
