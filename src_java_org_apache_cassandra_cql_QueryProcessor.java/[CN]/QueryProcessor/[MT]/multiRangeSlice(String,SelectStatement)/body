{
  List<org.apache.cassandra.db.Row> rows=null;
  IPartitioner<?> p=StorageService.getPartitioner();
  AbstractBounds bounds=new Bounds(p.getToken(select.getKeyPredicates().getStart().getByteBuffer()),p.getToken(select.getKeyPredicates().getFinish().getByteBuffer()));
  SlicePredicate thriftSlicePredicate=new SlicePredicate();
  if (select.getColumnPredicates().isRange() || select.getColumnPredicates().getTerms().size() == 0) {
    SliceRange sliceRange=new SliceRange();
    sliceRange.start=select.getColumnPredicates().getStart().getByteBuffer();
    sliceRange.finish=select.getColumnPredicates().getFinish().getByteBuffer();
    sliceRange.reversed=false;
    sliceRange.count=select.getNumColumns();
    thriftSlicePredicate.slice_range=sliceRange;
  }
 else {
    List<ByteBuffer> columnNames=new ArrayList<ByteBuffer>();
    for (    Term column : select.getColumnPredicates().getTerms())     columnNames.add(column.getByteBuffer());
    thriftSlicePredicate.column_names=columnNames;
  }
  try {
    rows=StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace,select.getColumnFamily(),null,thriftSlicePredicate,bounds,select.getNumRecords()),select.getConsistencyLevel());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  org.apache.cassandra.thrift.UnavailableException e) {
    throw new UnavailableException();
  }
catch (  TimeoutException e) {
    throw new TimedOutException();
  }
  return rows;
}
