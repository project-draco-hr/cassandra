{
  String keyspace=null;
  if (statement.type != StatementType.SELECT && StatementType.REQUIRES_KEYSPACE.contains(statement.type))   keyspace=clientState.getKeyspace();
  CqlResult result=new CqlResult();
  if (logger.isDebugEnabled())   logger.debug("CQL statement type: {}",statement.type.toString());
  CFMetaData metadata;
switch (statement.type) {
case SELECT:
    SelectStatement select=(SelectStatement)statement.statement;
  final String oldKeyspace=clientState.getRawKeyspace();
if (select.isSetKeyspace()) {
  keyspace=CliUtils.unescapeSQLString(select.getKeyspace());
  ThriftValidation.validateTable(keyspace);
}
 else if (oldKeyspace == null) throw new InvalidRequestException("no keyspace has been specified");
 else keyspace=oldKeyspace;
clientState.hasColumnFamilyAccess(keyspace,select.getColumnFamily(),Permission.SELECT);
metadata=validateColumnFamily(keyspace,select.getColumnFamily());
select.extractKeyAliasFromColumns(metadata);
if (select.getKeys().size() > 0) validateKeyAlias(metadata,select.getKeyAlias());
validateSelect(keyspace,select,variables);
List<org.apache.cassandra.db.Row> rows;
long now=System.currentTimeMillis();
if (!select.isKeyRange() && (select.getKeys().size() > 0)) {
rows=getSlice(metadata,select,variables,now);
}
 else {
rows=multiRangeSlice(metadata,select,variables,now);
}
result.type=CqlResultType.ROWS;
if (select.isCountOperation()) {
validateCountOperation(select);
ByteBuffer countBytes=ByteBufferUtil.bytes("count");
result.schema=new CqlMetadata(Collections.<ByteBuffer,String>emptyMap(),Collections.<ByteBuffer,String>emptyMap(),"AsciiType","LongType");
List<Column> columns=Collections.singletonList(new Column(countBytes).setValue(ByteBufferUtil.bytes((long)rows.size())));
result.rows=Collections.singletonList(new CqlRow(countBytes,columns));
return result;
}
result.schema=new CqlMetadata(new HashMap<ByteBuffer,String>(),new HashMap<ByteBuffer,String>(),TypeParser.getShortName(metadata.comparator),TypeParser.getShortName(metadata.getDefaultValidator()));
List<CqlRow> cqlRows=new ArrayList<CqlRow>(rows.size());
for (org.apache.cassandra.db.Row row : rows) {
List<Column> thriftColumns=new ArrayList<Column>();
if (select.isColumnRange()) {
if (select.isFullWildcard()) {
ByteBuffer keyName=ByteBufferUtil.bytes(metadata.getCQL2KeyName());
thriftColumns.add(new Column(keyName).setValue(row.key.key).setTimestamp(-1));
result.schema.name_types.put(keyName,TypeParser.getShortName(AsciiType.instance));
result.schema.value_types.put(keyName,TypeParser.getShortName(metadata.getKeyValidator()));
}
if (row.cf != null) {
for (org.apache.cassandra.db.Column c : row.cf.getSortedColumns()) {
if (c.isMarkedForDelete(now)) continue;
ColumnDefinition cd=metadata.getColumnDefinitionFromColumnName(c.name());
if (cd != null) result.schema.value_types.put(c.name(),TypeParser.getShortName(cd.getValidator()));
thriftColumns.add(thriftify(c));
}
}
}
 else {
String keyString=metadata.getCQL2KeyName();
for (Term term : select.getColumnNames()) {
if (term.getText().equalsIgnoreCase(keyString)) {
ByteBuffer requestedKey=ByteBufferUtil.bytes(term.getText());
thriftColumns.add(new Column(requestedKey).setValue(row.key.key).setTimestamp(-1));
result.schema.name_types.put(requestedKey,TypeParser.getShortName(AsciiType.instance));
result.schema.value_types.put(requestedKey,TypeParser.getShortName(metadata.getKeyValidator()));
continue;
}
if (row.cf == null) continue;
ByteBuffer name;
try {
name=term.getByteBuffer(metadata.comparator,variables);
}
 catch (InvalidRequestException e) {
throw new AssertionError(e);
}
ColumnDefinition cd=metadata.getColumnDefinitionFromColumnName(name);
if (cd != null) result.schema.value_types.put(name,TypeParser.getShortName(cd.getValidator()));
org.apache.cassandra.db.Column c=row.cf.getColumn(name);
if (c == null || c.isMarkedForDelete(now)) thriftColumns.add(new Column().setName(name));
 else thriftColumns.add(thriftify(c));
}
}
CqlRow cqlRow=new CqlRow();
cqlRow.key=row.key.key;
cqlRow.columns=thriftColumns;
if (select.isColumnsReversed()) Collections.reverse(cqlRow.columns);
cqlRows.add(cqlRow);
}
result.rows=cqlRows;
return result;
case INSERT:
case UPDATE:
UpdateStatement update=(UpdateStatement)statement.statement;
update.getConsistencyLevel().validateForWrite(keyspace);
keyspace=update.keyspace == null ? clientState.getKeyspace() : update.keyspace;
List<IMutation> rowMutations=update.prepareRowMutations(keyspace,clientState,variables);
for (IMutation mutation : rowMutations) {
validateKey(mutation.key());
}
StorageProxy.mutateWithTriggers(rowMutations,update.getConsistencyLevel(),false);
result.type=CqlResultType.VOID;
return result;
case BATCH:
BatchStatement batch=(BatchStatement)statement.statement;
batch.getConsistencyLevel().validateForWrite(keyspace);
if (batch.getTimeToLive() != 0) throw new InvalidRequestException("Global TTL on the BATCH statement is not supported.");
for (AbstractModification up : batch.getStatements()) {
if (up.isSetConsistencyLevel()) throw new InvalidRequestException("Consistency level must be set on the BATCH, not individual statements");
if (batch.isSetTimestamp() && up.isSetTimestamp()) throw new InvalidRequestException("Timestamp must be set either on BATCH or individual statements");
}
List<IMutation> mutations=batch.getMutations(keyspace,clientState,variables);
for (IMutation mutation : mutations) {
validateKey(mutation.key());
}
StorageProxy.mutateWithTriggers(mutations,batch.getConsistencyLevel(),false);
result.type=CqlResultType.VOID;
return result;
case USE:
clientState.validateLogin();
clientState.setKeyspace(CliUtils.unescapeSQLString((String)statement.statement));
result.type=CqlResultType.VOID;
return result;
case TRUNCATE:
Pair<String,String> columnFamily=(Pair<String,String>)statement.statement;
keyspace=columnFamily.left == null ? clientState.getKeyspace() : columnFamily.left;
validateColumnFamily(keyspace,columnFamily.right);
clientState.hasColumnFamilyAccess(keyspace,columnFamily.right,Permission.MODIFY);
try {
StorageProxy.truncateBlocking(keyspace,columnFamily.right);
}
 catch (TimeoutException e) {
throw new TruncateException(e);
}
catch (IOException e) {
throw new RuntimeException(e);
}
result.type=CqlResultType.VOID;
return result;
case DELETE:
DeleteStatement delete=(DeleteStatement)statement.statement;
keyspace=delete.keyspace == null ? clientState.getKeyspace() : delete.keyspace;
List<IMutation> deletions=delete.prepareRowMutations(keyspace,clientState,variables);
for (IMutation deletion : deletions) {
validateKey(deletion.key());
}
StorageProxy.mutateWithTriggers(deletions,delete.getConsistencyLevel(),false);
result.type=CqlResultType.VOID;
return result;
case CREATE_KEYSPACE:
CreateKeyspaceStatement create=(CreateKeyspaceStatement)statement.statement;
create.validate();
ThriftValidation.validateKeyspaceNotSystem(create.getName());
clientState.hasAllKeyspacesAccess(Permission.CREATE);
try {
KSMetaData ksm=KSMetaData.newKeyspace(create.getName(),create.getStrategyClass(),create.getStrategyOptions(),true);
ThriftValidation.validateKeyspaceNotYetExisting(ksm.name);
MigrationManager.announceNewKeyspace(ksm);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_COLUMNFAMILY:
CreateColumnFamilyStatement createCf=(CreateColumnFamilyStatement)statement.statement;
clientState.hasKeyspaceAccess(keyspace,Permission.CREATE);
try {
MigrationManager.announceNewColumnFamily(createCf.getCFMetaData(keyspace,variables));
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case CREATE_INDEX:
CreateIndexStatement createIdx=(CreateIndexStatement)statement.statement;
clientState.hasColumnFamilyAccess(keyspace,createIdx.getColumnFamily(),Permission.ALTER);
CFMetaData oldCfm=Schema.instance.getCFMetaData(keyspace,createIdx.getColumnFamily());
if (oldCfm == null) throw new InvalidRequestException("No such column family: " + createIdx.getColumnFamily());
boolean columnExists=false;
ByteBuffer columnName=createIdx.getColumnName().getByteBuffer();
CFMetaData cfm=oldCfm.clone();
for (ColumnDefinition cd : cfm.regularColumns()) {
if (cd.name.equals(columnName)) {
if (cd.getIndexType() != null) throw new InvalidRequestException("Index already exists");
if (logger.isDebugEnabled()) logger.debug("Updating column {} definition for index {}",cfm.comparator.getString(columnName),createIdx.getIndexName());
cd.setIndexType(IndexType.KEYS,Collections.<String,String>emptyMap());
cd.setIndexName(createIdx.getIndexName());
columnExists=true;
break;
}
}
if (!columnExists) throw new InvalidRequestException("No column definition found for column " + oldCfm.comparator.getString(columnName));
try {
cfm.addDefaultIndexNames();
MigrationManager.announceColumnFamilyUpdate(cfm,true);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_INDEX:
DropIndexStatement dropIdx=(DropIndexStatement)statement.statement;
keyspace=clientState.getKeyspace();
dropIdx.setKeyspace(keyspace);
clientState.hasColumnFamilyAccess(keyspace,dropIdx.getColumnFamily(),Permission.ALTER);
try {
CFMetaData updatedCF=dropIdx.generateCFMetadataUpdate();
MigrationManager.announceColumnFamilyUpdate(updatedCF,true);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.toString());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_KEYSPACE:
String deleteKeyspace=(String)statement.statement;
ThriftValidation.validateKeyspaceNotSystem(deleteKeyspace);
clientState.hasKeyspaceAccess(deleteKeyspace,Permission.DROP);
try {
MigrationManager.announceKeyspaceDrop(deleteKeyspace);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case DROP_COLUMNFAMILY:
String deleteColumnFamily=(String)statement.statement;
clientState.hasColumnFamilyAccess(keyspace,deleteColumnFamily,Permission.DROP);
try {
MigrationManager.announceColumnFamilyDrop(keyspace,deleteColumnFamily);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
case ALTER_TABLE:
AlterTableStatement alterTable=(AlterTableStatement)statement.statement;
validateColumnFamily(keyspace,alterTable.columnFamily);
clientState.hasColumnFamilyAccess(keyspace,alterTable.columnFamily,Permission.ALTER);
try {
MigrationManager.announceColumnFamilyUpdate(alterTable.getCFMetaData(keyspace),true);
}
 catch (ConfigurationException e) {
InvalidRequestException ex=new InvalidRequestException(e.getMessage());
ex.initCause(e);
throw ex;
}
result.type=CqlResultType.VOID;
return result;
}
return null;
}
