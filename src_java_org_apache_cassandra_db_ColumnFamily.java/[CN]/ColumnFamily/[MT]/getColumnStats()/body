{
  long minTimestampSeen=deletionInfo().isLive() ? Long.MAX_VALUE : deletionInfo().minTimestamp();
  long maxTimestampSeen=deletionInfo().maxTimestamp();
  StreamingHistogram tombstones=new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
  int maxLocalDeletionTime=Integer.MIN_VALUE;
  List<ByteBuffer> minColumnNamesSeen=Collections.emptyList();
  List<ByteBuffer> maxColumnNamesSeen=Collections.emptyList();
  for (  Cell cell : this) {
    if (deletionInfo().getTopLevelDeletion().localDeletionTime < Integer.MAX_VALUE)     tombstones.update(deletionInfo().getTopLevelDeletion().localDeletionTime);
    Iterator<RangeTombstone> it=deletionInfo().rangeIterator();
    while (it.hasNext()) {
      RangeTombstone rangeTombstone=it.next();
      tombstones.update(rangeTombstone.getLocalDeletionTime());
    }
    minTimestampSeen=Math.min(minTimestampSeen,cell.timestamp());
    maxTimestampSeen=Math.max(maxTimestampSeen,cell.timestamp());
    maxLocalDeletionTime=Math.max(maxLocalDeletionTime,cell.getLocalDeletionTime());
    int deletionTime=cell.getLocalDeletionTime();
    if (deletionTime < Integer.MAX_VALUE)     tombstones.update(deletionTime);
    minColumnNamesSeen=ColumnNameHelper.minComponents(minColumnNamesSeen,cell.name,metadata.comparator);
    maxColumnNamesSeen=ColumnNameHelper.maxComponents(maxColumnNamesSeen,cell.name,metadata.comparator);
  }
  return new ColumnStats(getColumnCount(),minTimestampSeen,maxTimestampSeen,maxLocalDeletionTime,tombstones,minColumnNamesSeen,maxColumnNamesSeen);
}
