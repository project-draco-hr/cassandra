{
  List<Function> olds=Functions.find(functionName);
  if (!argsPresent && olds != null && olds.size() > 1)   throw new InvalidRequestException(String.format("'DROP FUNCTION %s' matches multiple function definitions; " + "specify the argument types by issuing a statement like " + "'DROP FUNCTION %s (type, type, ...)'. Hint: use cqlsh "+ "'DESCRIBE FUNCTION %s' command to find all overloads",functionName,functionName,functionName));
  List<AbstractType<?>> argTypes=new ArrayList<>(argRawTypes.size());
  for (  CQL3Type.Raw rawType : argRawTypes)   argTypes.add(rawType.prepare(typeKeyspace(rawType)).getType());
  Function old;
  if (argsPresent) {
    old=Functions.find(functionName,argTypes);
    if (old == null || !(old instanceof ScalarFunction)) {
      if (ifExists)       return false;
      StringBuilder sb=new StringBuilder();
      for (      CQL3Type.Raw rawType : argRawTypes) {
        if (sb.length() > 0)         sb.append(", ");
        sb.append(rawType);
      }
      throw new InvalidRequestException(String.format("Cannot drop non existing function '%s(%s)'",functionName,sb));
    }
  }
 else {
    if (olds == null || olds.isEmpty() || !(olds.get(0) instanceof ScalarFunction)) {
      if (ifExists)       return false;
      throw new InvalidRequestException(String.format("Cannot drop non existing function '%s'",functionName));
    }
    old=olds.get(0);
  }
  List<Function> references=Functions.getReferencesTo(old);
  if (!references.isEmpty())   throw new InvalidRequestException(String.format("Function '%s' still referenced by %s",functionName,references));
  MigrationManager.announceFunctionDrop((UDFunction)old,isLocalOnly);
  return true;
}
