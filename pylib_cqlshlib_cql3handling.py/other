from .cqlhandling import CqlParsingRuleSet, Hint
from cassandra.metadata import maybe_escape_name
from cassandra.metadata import escape_name
simple_cql_types = set(('ascii', 'bigint', 'blob', 'boolean', 'counter', 'decimal', 'double', 'float', 'inet', 'int', 'text', 'timestamp', 'timeuuid', 'uuid', 'varchar', 'varint'))
simple_cql_types.difference_update(('set', 'map', 'list'))
from . import helptopics
cqldocs = helptopics.CQL3HelpTopics()
try:
    import json
except ImportError:
    import simplejson as json
SYSTEM_KEYSPACES = ('system', 'system_traces', 'system_auth')
NONALTERBALE_KEYSPACES = 'system'
CqlRuleSet = Cql3ParsingRuleSet()
shorthands = ('completer_for', 'explain_completion', 'dequote_value', 'dequote_name', 'escape_value', 'maybe_escape_name')
for shorthand in shorthands:
    globals()[shorthand] = getattr(CqlRuleSet, shorthand)
syntax_rules = '\n<Start> ::= <CQL_Statement>*\n          ;\n\n<CQL_Statement> ::= [statements]=<statementBody> ";"\n                  ;\n\n# the order of these terminal productions is significant:\n<endline> ::= /\\n/ ;\n\nJUNK ::= /([ \\t\\r\\f\\v]+|(--|[/][/])[^\\n\\r]*([\\n\\r]|$)|[/][*].*?[*][/])/ ;\n\n<stringLiteral> ::= /\'([^\']|\'\')*\'/ ;\n<quotedName> ::=    /"([^"]|"")*"/ ;\n<float> ::=         /-?[0-9]+\\.[0-9]+/ ;\n<uuid> ::=          /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/ ;\n<blobLiteral> ::=    /0x[0-9a-f]+/ ;\n<wholenumber> ::=   /[0-9]+/ ;\n<identifier> ::=    /[a-z][a-z0-9_]*/ ;\n<colon> ::=         ":" ;\n<star> ::=          "*" ;\n<endtoken> ::=      ";" ;\n<op> ::=            /[-+=,().]/ ;\n<cmp> ::=           /[<>]=?/ ;\n<brackets> ::=      /[][{}]/ ;\n\n<integer> ::= "-"? <wholenumber> ;\n<boolean> ::= "true"\n            | "false"\n            ;\n\n<unclosedString>  ::= /\'([^\']|\'\')*/ ;\n<unclosedName>    ::= /"([^"]|"")*/ ;\n<unclosedComment> ::= /[/][*].*$/ ;\n\n<term> ::= <stringLiteral>\n         | <integer>\n         | <float>\n         | <uuid>\n         | <boolean>\n         | <blobLiteral>\n         | <collectionLiteral>\n         | <functionName> <functionArguments>\n         ;\n\n<functionArguments> ::= "(" ( <term> ( "," <term> )* )? ")"\n                 ;\n\n<tokenDefinition> ::= token="TOKEN" "(" <term> ( "," <term> )* ")"\n                    | <term>\n                    ;\n<cident> ::= <quotedName>\n           | <identifier>\n           | <unreservedKeyword>\n           ;\n<colname> ::= <cident> ;   # just an alias\n\n<collectionLiteral> ::= <listLiteral>\n                      | <setLiteral>\n                      | <mapLiteral>\n                      ;\n<listLiteral> ::= "[" ( <term> ( "," <term> )* )? "]"\n                ;\n<setLiteral> ::= "{" ( <term> ( "," <term> )* )? "}"\n               ;\n<mapLiteral> ::= "{" <term> ":" <term> ( "," <term> ":" <term> )* "}"\n               ;\n\n<functionName> ::= <identifier> ( ":" ":" <identifier> )?\n                 ;\n\n<statementBody> ::= <useStatement>\n                  | <selectStatement>\n                  | <dataChangeStatement>\n                  | <schemaChangeStatement>\n                  | <authenticationStatement>\n                  | <authorizationStatement>\n                  ;\n\n<dataChangeStatement> ::= <insertStatement>\n                        | <updateStatement>\n                        | <deleteStatement>\n                        | <truncateStatement>\n                        | <batchStatement>\n                        ;\n\n<schemaChangeStatement> ::= <createKeyspaceStatement>\n                          | <createColumnFamilyStatement>\n                          | <createIndexStatement>\n                          | <createUserTypeStatement>\n                          | <createFunctionStatement>\n                          | <dropKeyspaceStatement>\n                          | <dropColumnFamilyStatement>\n                          | <dropIndexStatement>\n                          | <dropUserTypeStatement>\n                          | <dropFunctionStatement>\n                          | <alterTableStatement>\n                          | <alterKeyspaceStatement>\n                          | <alterUserTypeStatement>\n                          ;\n\n<authenticationStatement> ::= <createUserStatement>\n                            | <alterUserStatement>\n                            | <dropUserStatement>\n                            | <listUsersStatement>\n                            ;\n\n<authorizationStatement> ::= <grantStatement>\n                           | <revokeStatement>\n                           | <listPermissionsStatement>\n                           ;\n\n# timestamp is included here, since it\'s also a keyword\n<simpleStorageType> ::= typename=( <identifier> | <stringLiteral> | <K_TIMESTAMP> ) ;\n\n<userType> ::= utname=<cfOrKsName> ;\n\n<storageType> ::= <simpleStorageType> | <collectionType> | <userType> ;\n\n<collectionType> ::= "map" "<" <simpleStorageType> "," ( <simpleStorageType> | <userType> ) ">"\n                   | "list" "<" ( <simpleStorageType> | <userType> ) ">"\n                   | "set" "<" ( <simpleStorageType> | <userType> ) ">"\n                   ;\n\n<columnFamilyName> ::= ( ksname=<cfOrKsName> dot="." )? cfname=<cfOrKsName> ;\n\n<userTypeName> ::= ( ksname=<cfOrKsName> dot="." )? utname=<cfOrKsName> ;\n\n<keyspaceName> ::= ksname=<cfOrKsName> ;\n\n<nonSystemKeyspaceName> ::= ksname=<cfOrKsName> ;\n\n<alterableKeyspaceName> ::= ksname=<cfOrKsName> ;\n\n<cfOrKsName> ::= <identifier>\n               | <quotedName>\n               | <unreservedKeyword>;\n\n<unreservedKeyword> ::= nocomplete=\n                        ( <K_KEY>\n                        | <K_CLUSTERING>\n                        # | <K_COUNT>  -- to get count(*) completion, treat count as reserved\n                        | <K_TTL>\n                        | <K_COMPACT>\n                        | <K_STORAGE>\n                        | <K_TYPE>\n                        | <K_VALUES> )\n                      ;\n\n<property> ::= [propname]=<cident> propeq="=" [propval]=<propertyValue>\n                ;\n<propertyValue> ::= propsimpleval=( <stringLiteral>\n                                  | <identifier>\n                                  | <integer>\n                                  | <float>\n                                  | <unreservedKeyword> )\n                    # we don\'t use <mapLiteral> here so we can get more targeted\n                    # completions:\n                    | propsimpleval="{" [propmapkey]=<term> ":" [propmapval]=<term>\n                            ( ender="," [propmapkey]=<term> ":" [propmapval]=<term> )*\n                      ender="}"\n                    ;\n\n'
completer_for('property', 'propeq')(prop_equals_completer)
completer_for('columnFamilyName', 'ksname')(cf_ks_name_completer)
completer_for('columnFamilyName', 'dot')(cf_ks_dot_completer)
completer_for('userTypeName', 'ksname')(cf_ks_name_completer)
completer_for('userTypeName', 'dot')(cf_ks_dot_completer)
completer_for('userTypeName', 'utname')(ut_name_completer)
completer_for('userType', 'utname')(ut_name_completer)
syntax_rules += '\n<useStatement> ::= "USE" <keyspaceName>\n                 ;\n<selectStatement> ::= "SELECT" <selectClause>\n                        "FROM" cf=<columnFamilyName>\n                          ( "WHERE" <whereClause> )?\n                          ( "ORDER" "BY" <orderByClause> ( "," <orderByClause> )* )?\n                          ( "LIMIT" limit=<wholenumber> )?\n                          ( "ALLOW" "FILTERING" )?\n                    ;\n<whereClause> ::= <relation> ( "AND" <relation> )*\n                ;\n<relation> ::= [rel_lhs]=<cident> ( "=" | "<" | ">" | "<=" | ">=" | "CONTAINS" ) <term>\n             | token="TOKEN" "(" [rel_tokname]=<cident>\n                                 ( "," [rel_tokname]=<cident> )*\n                             ")" ("=" | "<" | ">" | "<=" | ">=" | "CONTAINS") <tokenDefinition>\n             | [rel_lhs]=<cident> "IN" "(" <term> ( "," <term> )* ")"\n             ;\n<selectClause> ::= "DISTINCT"? <selector> ("AS" <cident>)? ("," <selector> ("AS" <cident>)?)*\n                 | "*"\n                 | "COUNT" "(" star=( "*" | "1" ) ")" ("AS" <cident>)?\n                 ;\n<selector> ::= [colname]=<cident>\n             | "WRITETIME" "(" [colname]=<cident> ")"\n             | "TTL" "(" [colname]=<cident> ")"\n             | <functionName> <selectionFunctionArguments>\n             ;\n<selectionFunctionArguments> ::= "(" ( <selector> ( "," <selector> )* )? ")"\n                          ;\n<orderByClause> ::= [ordercol]=<cident> ( "ASC" | "DESC" )?\n                  ;\n'
explain_completion('selector', 'colname')
syntax_rules += '\n<insertStatement> ::= "INSERT" "INTO" cf=<columnFamilyName>\n                               "(" [colname]=<cident> "," [colname]=<cident>\n                                   ( "," [colname]=<cident> )* ")"\n                      "VALUES" "(" [newval]=<term> valcomma="," [newval]=<term>\n                                   ( valcomma="," [newval]=<term> )* valcomma=")"\n                      ( "USING" [insertopt]=<usingOption>\n                                ( "AND" [insertopt]=<usingOption> )* )?\n                    ;\n<usingOption> ::= "TIMESTAMP" <wholenumber>\n                | "TTL" <wholenumber>\n                ;\n'
syntax_rules += '\n<updateStatement> ::= "UPDATE" cf=<columnFamilyName>\n                        ( "USING" [updateopt]=<usingOption>\n                                  ( "AND" [updateopt]=<usingOption> )* )?\n                        "SET" <assignment> ( "," <assignment> )*\n                        "WHERE" <whereClause>\n                    ;\n<assignment> ::= updatecol=<cident>\n                    ( "=" update_rhs=( <value> | <cident> )\n                                ( counterop=( "+" | "-" ) inc=<wholenumber>\n                                | listadder="+" listcol=<cident> )\n                    | indexbracket="[" <term> "]" "=" <term> )\n               ;\n'
syntax_rules += '\n<deleteStatement> ::= "DELETE" ( <deleteSelector> ( "," <deleteSelector> )* )?\n                        "FROM" cf=<columnFamilyName>\n                        ( "USING" [delopt]=<deleteOption> )?\n                        "WHERE" <whereClause>\n                    ;\n<deleteSelector> ::= delcol=<cident> ( memberbracket="[" memberselector=<term> "]" )?\n                   ;\n<deleteOption> ::= "TIMESTAMP" <wholenumber>\n                 ;\n'
syntax_rules += '\n<batchStatement> ::= "BEGIN" ( "UNLOGGED" | "COUNTER" )? "BATCH"\n                        ( "USING" [batchopt]=<usingOption>\n                                  ( "AND" [batchopt]=<usingOption> )* )?\n                        [batchstmt]=<batchStatementMember> ";"?\n                            ( [batchstmt]=<batchStatementMember> ";"? )*\n                     "APPLY" "BATCH"\n                   ;\n<batchStatementMember> ::= <insertStatement>\n                         | <updateStatement>\n                         | <deleteStatement>\n                         ;\n'
syntax_rules += '\n<truncateStatement> ::= "TRUNCATE" cf=<columnFamilyName>\n                      ;\n'
syntax_rules += '\n<createKeyspaceStatement> ::= "CREATE" wat=( "KEYSPACE" | "SCHEMA" ) ("IF" "NOT" "EXISTS")?  ksname=<cfOrKsName>\n                                "WITH" <property> ( "AND" <property> )*\n                            ;\n'
syntax_rules += '\n<createColumnFamilyStatement> ::= "CREATE" wat=( "COLUMNFAMILY" | "TABLE" ) ("IF" "NOT" "EXISTS")?\n                                    ( ks=<nonSystemKeyspaceName> dot="." )? cf=<cfOrKsName>\n                                    "(" ( <singleKeyCfSpec> | <compositeKeyCfSpec> ) ")"\n                                   ( "WITH" <cfamProperty> ( "AND" <cfamProperty> )* )?\n                                ;\n\n<cfamProperty> ::= <property>\n                 | "COMPACT" "STORAGE"\n                 | "CLUSTERING" "ORDER" "BY" "(" <cfamOrdering>\n                                                 ( "," <cfamOrdering> )* ")"\n                 ;\n\n<cfamOrdering> ::= [ordercol]=<cident> ( "ASC" | "DESC" )\n                 ;\n\n<singleKeyCfSpec> ::= [newcolname]=<cident> <simpleStorageType> "PRIMARY" "KEY"\n                      ( "," [newcolname]=<cident> <storageType> )*\n                    ;\n\n<compositeKeyCfSpec> ::= [newcolname]=<cident> <simpleStorageType>\n                         "," [newcolname]=<cident> <storageType> ( "static" )?\n                         ( "," [newcolname]=<cident> <storageType> ( "static" )? )*\n                         "," "PRIMARY" k="KEY" p="(" ( partkey=<pkDef> | [pkey]=<cident> )\n                                                     ( c="," [pkey]=<cident> )* ")"\n                       ;\n\n<pkDef> ::= "(" [ptkey]=<cident> "," [ptkey]=<cident>\n                               ( "," [ptkey]=<cident> )* ")"\n          ;\n'
explain_completion('createColumnFamilyStatement', 'cf', '<new_table_name>')
explain_completion('compositeKeyCfSpec', 'newcolname', '<new_column_name>')
syntax_rules += '\n<createIndexStatement> ::= "CREATE" "CUSTOM"? "INDEX" ("IF" "NOT" "EXISTS")? indexname=<identifier>? "ON"\n                               cf=<columnFamilyName> "(" col=<cident> ")"\n                               ( "USING" <stringLiteral> ( "WITH" "OPTIONS" "=" <mapLiteral> )? )?\n                         ;\n\n<createUserTypeStatement> ::= "CREATE" "TYPE" ( ks=<nonSystemKeyspaceName> dot="." )? typename=<cfOrKsName> "(" newcol=<cident> <storageType>\n                                ( "," [newcolname]=<cident> <storageType> )*\n                            ")"\n                         ;\n\n<createFunctionStatement> ::= "CREATE" ("OR" "REPLACE")? "FUNCTION"\n                            ("IF" "NOT" "EXISTS")?\n                            ("NON"? "DETERMINISTIC")?\n                            <functionName>\n                            ( "(" ( newcol=<cident> <storageType>\n                              ( "," [newcolname]=<cident> <storageType> )* )?\n                            ")" )?\n                            "RETURNS" <storageType>\n                            (\n                              ("LANGUAGE" <cident> "AS"\n                                (\n                                  <stringLiteral>\n                                )\n                              )\n                              | (<stringLiteral>)\n                            )\n                         ;\n\n'
explain_completion('createIndexStatement', 'indexname', '<new_index_name>')
explain_completion('createUserTypeStatement', 'typename', '<new_type_name>')
explain_completion('createUserTypeStatement', 'newcol', '<new_field_name>')
syntax_rules += '\n<dropKeyspaceStatement> ::= "DROP" "KEYSPACE" ("IF" "EXISTS")? ksname=<nonSystemKeyspaceName>\n                          ;\n\n<dropColumnFamilyStatement> ::= "DROP" ( "COLUMNFAMILY" | "TABLE" ) ("IF" "EXISTS")? cf=<columnFamilyName>\n                              ;\n\n<indexName> ::= ( ksname=<idxOrKsName> dot="." )? idxname=<idxOrKsName> ;\n\n<idxOrKsName> ::= <identifier>\n               | <quotedName>\n               | <unreservedKeyword>;\n\n<dropIndexStatement> ::= "DROP" "INDEX" ("IF" "EXISTS")? idx=<indexName>\n                       ;\n\n<dropUserTypeStatement> ::= "DROP" "TYPE" ut=<userTypeName>\n                          ;\n\n<dropFunctionStatement> ::= "DROP" "FUNCTION" ( "IF" "EXISTS" )? <functionName>\n                          ;\n\n'
syntax_rules += '\n<alterTableStatement> ::= "ALTER" wat=( "COLUMNFAMILY" | "TABLE" ) cf=<columnFamilyName>\n                               <alterInstructions>\n                        ;\n<alterInstructions> ::= "ALTER" existcol=<cident> "TYPE" <storageType>\n                      | "ADD" newcol=<cident> <storageType> ("static")?\n                      | "DROP" existcol=<cident>\n                      | "WITH" <cfamProperty> ( "AND" <cfamProperty> )*\n                      | "RENAME" existcol=<cident> "TO" newcol=<cident>\n                         ( "AND" existcol=<cident> "TO" newcol=<cident> )*\n                      ;\n\n<alterUserTypeStatement> ::= "ALTER" "TYPE" ut=<userTypeName>\n                               <alterTypeInstructions>\n                             ;\n<alterTypeInstructions> ::= "RENAME" "TO" typename=<cfOrKsName>\n                           | "ALTER" existcol=<cident> "TYPE" <storageType>\n                           | "ADD" newcol=<cident> <storageType>\n                           | "RENAME" existcol=<cident> "TO" newcol=<cident>\n                           ;\n'
explain_completion('alterInstructions', 'newcol', '<new_column_name>')
explain_completion('alterTypeInstructions', 'typename', '<new_type_name>')
explain_completion('alterTypeInstructions', 'newcol', '<new_field_name>')
syntax_rules += '\n<alterKeyspaceStatement> ::= "ALTER" ( "KEYSPACE" | "SCHEMA" ) ks=<alterableKeyspaceName>\n                                 "WITH" <property> ( "AND" <property> )*\n                           ;\n'
syntax_rules += '\n<username> ::= name=( <identifier> | <stringLiteral> )\n             ;\n\n<createUserStatement> ::= "CREATE" "USER" ( "IF" "NOT" "EXISTS" )? <username>\n                              ( "WITH" "PASSWORD" <stringLiteral> )?\n                              ( "SUPERUSER" | "NOSUPERUSER" )?\n                        ;\n\n<alterUserStatement> ::= "ALTER" "USER" <username>\n                              ( "WITH" "PASSWORD" <stringLiteral> )?\n                              ( "SUPERUSER" | "NOSUPERUSER" )?\n                       ;\n\n<dropUserStatement> ::= "DROP" "USER" ( "IF" "EXISTS" )? <username>\n                      ;\n\n<listUsersStatement> ::= "LIST" "USERS"\n                       ;\n'
syntax_rules += '\n<grantStatement> ::= "GRANT" <permissionExpr> "ON" <resource> "TO" <username>\n                   ;\n\n<revokeStatement> ::= "REVOKE" <permissionExpr> "ON" <resource> "FROM" <username>\n                    ;\n\n<listPermissionsStatement> ::= "LIST" <permissionExpr>\n                                    ( "ON" <resource> )? ( "OF" <username> )? "NORECURSIVE"?\n                             ;\n\n<permission> ::= "AUTHORIZE"\n               | "CREATE"\n               | "ALTER"\n               | "DROP"\n               | "SELECT"\n               | "MODIFY"\n               ;\n\n<permissionExpr> ::= ( <permission> "PERMISSION"? )\n                   | ( "ALL" "PERMISSIONS"? )\n                   ;\n\n<resource> ::= <dataResource>\n             ;\n\n<dataResource> ::= ( "ALL" "KEYSPACES" )\n                 | ( "KEYSPACE" <keyspaceName> )\n                 | ( "TABLE"? <columnFamilyName> )\n                 ;\n'
CqlRuleSet.append_rules(syntax_rules)
from cassandra.cqltypes import lookup_casstype
