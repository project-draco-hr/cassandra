import re
from warnings import warn
from .cqlhandling import CqlParsingRuleSet, Hint
from cql.cqltypes import cql_types, cql_typename
try:
    import json
except ImportError:
    import simplejson as json
CqlRuleSet = Cql3ParsingRuleSet()
shorthands = ('completer_for', 'explain_completion', 'dequote_value', 'dequote_name', 'escape_value', 'escape_name', 'maybe_escape_name')
for shorthand in shorthands:
    globals()[shorthand] = getattr(CqlRuleSet, shorthand)
syntax_rules = '\n<Start> ::= <CQL_Statement>*\n          ;\n\n<CQL_Statement> ::= [statements]=<statementBody> ";"\n                  ;\n\n# the order of these terminal productions is significant:\n<endline> ::= /\\n/ ;\n\nJUNK ::= /([ \\t\\r\\f\\v]+|(--|[/][/])[^\\n\\r]*([\\n\\r]|$)|[/][*].*?[*][/])/ ;\n\n<stringLiteral> ::= /\'([^\']|\'\')*\'/ ;\n<quotedName> ::=    /"([^"]|"")*"/ ;\n<float> ::=         /-?[0-9]+\\.[0-9]+/ ;\n<wholenumber> ::=   /[0-9]+/ ;\n<integer> ::=       /-?[0-9]+/ ;\n<uuid> ::=          /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/ ;\n<identifier> ::=    /[a-z][a-z0-9_]*/ ;\n<colon> ::=         ":" ;\n<star> ::=          "*" ;\n<endtoken> ::=      ";" ;\n<op> ::=            /[-+=,().]/ ;\n<cmp> ::=           /[<>]=?/ ;\n<brackets> ::=      /[][{}]/ ;\n\n<unclosedString>  ::= /\'([^\']|\'\')*/ ;\n<unclosedName>    ::= /"([^"]|"")*/ ;\n<unclosedComment> ::= /[/][*][^\\n]*$/ ;\n\n<term> ::= <stringLiteral>\n         | <integer>\n         | <float>\n         | <uuid>\n         ;\n<extendedTerm> ::= token="TOKEN" "(" <term> ")"\n                 | <term>\n                 ;\n<cident> ::= <quotedName>\n           | <identifier>\n           | <unreservedKeyword>\n           ;\n<colname> ::= <cident> ;   # just an alias\n\n<statementBody> ::= <useStatement>\n                  | <selectStatement>\n                  | <dataChangeStatement>\n                  | <schemaChangeStatement>\n                  ;\n\n<dataChangeStatement> ::= <insertStatement>\n                        | <updateStatement>\n                        | <deleteStatement>\n                        | <truncateStatement>\n                        | <batchStatement>\n                        ;\n\n<schemaChangeStatement> ::= <createKeyspaceStatement>\n                          | <createColumnFamilyStatement>\n                          | <createIndexStatement>\n                          | <dropKeyspaceStatement>\n                          | <dropColumnFamilyStatement>\n                          | <dropIndexStatement>\n                          | <alterTableStatement>\n                          ;\n\n<consistencylevel> ::= cl=( <K_ONE>\n                          | <K_QUORUM>\n                          | <K_ALL>\n                          | <K_ANY>\n                          | <K_LOCAL_QUORUM>\n                          | <K_EACH_QUORUM>\n                          | <K_TWO>\n                          | <K_THREE> )\n                          ;\n\n<storageType> ::= typename=( <identifier> | <stringLiteral> ) ;\n\n<columnFamilyName> ::= ( ksname=<cfOrKsName> "." )? cfname=<cfOrKsName> ;\n\n<keyspaceName> ::= ksname=<cfOrKsName> ;\n\n<cfOrKsName> ::= <identifier>\n               | <quotedName>\n               | <unreservedKeyword>;\n\n<unreservedKeyword> ::= nocomplete=\n                        ( <K_KEY>\n                        | <K_CONSISTENCY>\n                        | <K_CLUSTERING>\n                        # | <K_COUNT>  -- to get count(*) completion, treat count as reserved\n                        | <K_TTL>\n                        | <K_COMPACT>\n                        | <K_STORAGE>\n                        | <K_TYPE>\n                        | <K_VALUES>\n                        | <consistencylevel> )\n                      ;\n'
syntax_rules += '\n<useStatement> ::= "USE" <keyspaceName>\n                 ;\n<selectStatement> ::= "SELECT" <selectClause>\n                        "FROM" cf=<columnFamilyName>\n                          ("USING" "CONSISTENCY" selcl=<consistencylevel>)?\n                          ("WHERE" <whereClause>)?\n                          ("ORDER" "BY" <orderByClause> ( "," <orderByClause> )* )?\n                          ("LIMIT" <wholenumber>)?\n                    ;\n<whereClause> ::= <relation> ("AND" <relation>)*\n                ;\n<relation> ::= [rel_lhs]=<cident> ("=" | "<" | ">" | "<=" | ">=") <term>\n             | token="TOKEN" "(" rel_tokname=<cident> ")" ("=" | "<" | ">" | "<=" | ">=") <extendedTerm>\n             | [rel_lhs]=<cident> "IN" "(" <term> ( "," <term> )* ")"\n             ;\n<selectClause> ::= colname=<cident> ("," colname=<cident>)*\n                 | "*"\n                 | "COUNT" "(" star=( "*" | "1" ) ")"\n                 ;\n<orderByClause> ::= [ordercol]=<cident> ( "ASC" | "DESC" )?\n                  ;\n'
explain_completion('selectClause', 'colname')
syntax_rules += '\n<insertStatement> ::= "INSERT" "INTO" cf=<columnFamilyName>\n                               "(" keyname=<cident> ","\n                                   [colname]=<cident> ( "," [colname]=<cident> )* ")"\n                      "VALUES" "(" <term> "," <term> ( "," <term> )* ")"\n                      ( "USING" [insertopt]=<usingOption>\n                                ( "AND" [insertopt]=<usingOption> )* )?\n                    ;\n<usingOption> ::= "CONSISTENCY" <consistencylevel>\n                | "TIMESTAMP" <wholenumber>\n                | "TTL" <wholenumber>\n                ;\n'
explain_completion('insertStatement', 'colname')
syntax_rules += '\n<updateStatement> ::= "UPDATE" cf=<columnFamilyName>\n                        ( "USING" [updateopt]=<usingOption>\n                                  ( "AND" [updateopt]=<usingOption> )* )?\n                        "SET" <assignment> ( "," <assignment> )*\n                        "WHERE" <whereClause>\n                    ;\n<assignment> ::= updatecol=<cident> "=" update_rhs=<cident>\n                                         ( counterop=( "+" | "-" ) <wholenumber> )?\n               ;\n'
syntax_rules += '\n<deleteStatement> ::= "DELETE" ( [delcol]=<cident> ( "," [delcol]=<cident> )* )?\n                        "FROM" cf=<columnFamilyName>\n                        ( "USING" [delopt]=<deleteOption> ( "AND" [delopt]=<deleteOption> )* )?\n                        "WHERE" <whereClause>\n                    ;\n<deleteOption> ::= "CONSISTENCY" <consistencylevel>\n                 | "TIMESTAMP" <wholenumber>\n                 ;\n'
explain_completion('deleteStatement', 'delcol', '<column_to_delete>')
syntax_rules += '\n<batchStatement> ::= "BEGIN" "BATCH"\n                        ( "USING" [batchopt]=<usingOption>\n                                  ( "AND" [batchopt]=<usingOption> )* )?\n                        [batchstmt]=<batchStatementMember> ";"\n                            ( [batchstmt]=<batchStatementMember> ";" )*\n                     "APPLY" "BATCH"\n                   ;\n<batchStatementMember> ::= <insertStatement>\n                         | <updateStatement>\n                         | <deleteStatement>\n                         ;\n'
syntax_rules += '\n<truncateStatement> ::= "TRUNCATE" cf=<columnFamilyName>\n                      ;\n'
syntax_rules += '\n<createKeyspaceStatement> ::= "CREATE" "KEYSPACE" ksname=<cfOrKsName>\n                                 "WITH" [optname]=<optionName> "=" [optval]=<optionVal>\n                                 ( "AND" [optname]=<optionName> "=" [optval]=<optionVal> )*\n                            ;\n<optionName> ::= <identifier> ( ":" ( <identifier> | <wholenumber> ) )?\n               ;\n<optionVal> ::= <stringLiteral>\n              | <identifier>\n              | <integer>\n              ;\n'
explain_completion('createKeyspaceStatement', 'ksname', '<new_keyspace_name>')
syntax_rules += '\n<createColumnFamilyStatement> ::= "CREATE" ( "COLUMNFAMILY" | "TABLE" )\n                                    ( ks=<keyspaceName> "." )? cf=<cfOrKsName>\n                                    "(" ( <singleKeyCfSpec> | <compositeKeyCfSpec> ) ")"\n                                   ( "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                                     ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )* )?\n                                ;\n\n<singleKeyCfSpec> ::= keyalias=<cident> <storageType> "PRIMARY" "KEY"\n                      ( "," colname=<cident> <storageType> )*\n                    ;\n\n<compositeKeyCfSpec> ::= [newcolname]=<cident> <storageType>\n                         "," [newcolname]=<cident> <storageType>\n                         ( "," [newcolname]=<cident> <storageType> )*\n                         "," "PRIMARY" k="KEY" p="(" [pkey]=<cident>\n                                                     ( c="," [pkey]=<cident> )* ")"\n                       ;\n\n<cfOptionName> ::= cfoptname=<identifier> ( cfoptsep=":" cfsubopt=( <identifier> | <wholenumber> ) )?\n                 ;\n\n<cfOptionVal> ::= <identifier>\n                | <stringLiteral>\n                | <integer>\n                | <float>\n                ;\n'
explain_completion('createColumnFamilyStatement', 'cf', '<new_table_name>')
explain_completion('singleKeyCfSpec', 'keyalias', '<new_key_name>')
explain_completion('singleKeyCfSpec', 'colname', '<new_column_name>')
explain_completion('compositeKeyCfSpec', 'newcolname', '<new_column_name>')
completer_for('createColumnFamilyStatement', 'optval')(create_cf_option_val_completer)
syntax_rules += '\n<createIndexStatement> ::= "CREATE" "INDEX" indexname=<identifier>? "ON"\n                               cf=<columnFamilyName> "(" col=<cident> ")"\n                         ;\n'
explain_completion('createIndexStatement', 'indexname', '<new_index_name>')
syntax_rules += '\n<dropKeyspaceStatement> ::= "DROP" "KEYSPACE" ksname=<keyspaceName>\n                          ;\n\n<dropColumnFamilyStatement> ::= "DROP" ( "COLUMNFAMILY" | "TABLE" ) cf=<columnFamilyName>\n                              ;\n\n<dropIndexStatement> ::= "DROP" "INDEX" indexname=<identifier>\n                       ;\n'
syntax_rules += '\n<alterTableStatement> ::= "ALTER" ( "COLUMNFAMILY" | "TABLE" ) cf=<columnFamilyName>\n                               <alterInstructions>\n                        ;\n<alterInstructions> ::= "ALTER" existcol=<cident> "TYPE" <storageType>\n                      | "ADD" newcol=<cident> <storageType>\n                      | "DROP" existcol=<cident>\n                      | "WITH" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal>\n                        ( "AND" [cfopt]=<cfOptionName> "=" [optval]=<cfOptionVal> )*\n                      ;\n'
explain_completion('alterInstructions', 'newcol', '<new_column_name>')
completer_for('alterInstructions', 'optval')(create_cf_option_val_completer)
CqlRuleSet.append_rules(syntax_rules)
