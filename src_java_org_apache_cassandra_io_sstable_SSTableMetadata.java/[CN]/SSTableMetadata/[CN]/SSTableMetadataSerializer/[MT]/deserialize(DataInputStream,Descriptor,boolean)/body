{
  EstimatedHistogram rowSizes=EstimatedHistogram.serializer.deserialize(in);
  EstimatedHistogram columnCounts=EstimatedHistogram.serializer.deserialize(in);
  ReplayPosition replayPosition=ReplayPosition.serializer.deserialize(in);
  long minTimestamp=in.readLong();
  long maxTimestamp=in.readLong();
  int maxLocalDeletionTime=desc.version.tracksMaxLocalDeletionTime ? in.readInt() : Integer.MAX_VALUE;
  double bloomFilterFPChance=desc.version.hasBloomFilterFPChance ? in.readDouble() : NO_BLOOM_FLITER_FP_CHANCE;
  double compressionRatio=in.readDouble();
  String partitioner=in.readUTF();
  int nbAncestors=in.readInt();
  Set<Integer> ancestors=new HashSet<Integer>(nbAncestors);
  for (int i=0; i < nbAncestors; i++)   ancestors.add(in.readInt());
  StreamingHistogram tombstoneHistogram=StreamingHistogram.serializer.deserialize(in);
  int sstableLevel=0;
  if (loadSSTableLevel && in.available() > 0)   sstableLevel=in.readInt();
  List<ByteBuffer> minColumnNames;
  List<ByteBuffer> maxColumnNames;
  if (desc.version.tracksMaxMinColumnNames) {
    int colCount=in.readInt();
    minColumnNames=new ArrayList<ByteBuffer>(colCount);
    for (int i=0; i < colCount; i++) {
      minColumnNames.add(ByteBufferUtil.readWithShortLength(in));
    }
    colCount=in.readInt();
    maxColumnNames=new ArrayList<ByteBuffer>(colCount);
    for (int i=0; i < colCount; i++) {
      maxColumnNames.add(ByteBufferUtil.readWithShortLength(in));
    }
  }
 else {
    minColumnNames=Collections.emptyList();
    maxColumnNames=Collections.emptyList();
  }
  return new SSTableMetadata(rowSizes,columnCounts,replayPosition,minTimestamp,maxTimestamp,maxLocalDeletionTime,bloomFilterFPChance,compressionRatio,partitioner,ancestors,tombstoneHistogram,sstableLevel,minColumnNames,maxColumnNames);
}
