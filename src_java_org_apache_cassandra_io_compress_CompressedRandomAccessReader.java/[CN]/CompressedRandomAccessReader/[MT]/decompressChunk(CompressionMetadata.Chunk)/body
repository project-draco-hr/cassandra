{
  if (channel.position() != chunk.offset)   channel.position(chunk.offset);
  if (compressed.capacity() < chunk.length)   compressed=ByteBuffer.wrap(new byte[chunk.length]);
 else   compressed.clear();
  compressed.limit(chunk.length);
  if (channel.read(compressed) != chunk.length)   throw new CorruptBlockException(getPath(),chunk);
  compressed.flip();
  try {
    validBufferBytes=metadata.compressor().uncompress(compressed.array(),0,chunk.length,buffer,0);
  }
 catch (  IOException e) {
    throw new CorruptBlockException(getPath(),chunk,e);
  }
  if (metadata.parameters.getCrcCheckChance() > FBUtilities.threadLocalRandom().nextDouble()) {
    if (metadata.hasPostCompressionAdlerChecksums) {
      checksum.update(compressed.array(),0,chunk.length);
    }
 else {
      checksum.update(buffer,0,validBufferBytes);
    }
    if (checksum(chunk) != (int)checksum.getValue())     throw new CorruptBlockException(getPath(),chunk);
    checksum.reset();
  }
  bufferOffset=current & ~(buffer.length - 1);
}
