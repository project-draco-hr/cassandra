{
  Map<String,List<ColumnFamilyStoreMBean>> cfstoreMap=new HashMap<String,List<ColumnFamilyStoreMBean>>();
  Iterator<Map.Entry<String,ColumnFamilyStoreMBean>> cfamilies=probe.getColumnFamilyStoreMBeanProxies();
  while (cfamilies.hasNext()) {
    Entry<String,ColumnFamilyStoreMBean> entry=cfamilies.next();
    String keyspaceName=entry.getKey();
    ColumnFamilyStoreMBean cfsProxy=entry.getValue();
    if (!cfstoreMap.containsKey(keyspaceName)) {
      List<ColumnFamilyStoreMBean> columnFamilies=new ArrayList<ColumnFamilyStoreMBean>();
      columnFamilies.add(cfsProxy);
      cfstoreMap.put(keyspaceName,columnFamilies);
    }
 else {
      cfstoreMap.get(keyspaceName).add(cfsProxy);
    }
  }
  for (  Entry<String,List<ColumnFamilyStoreMBean>> entry : cfstoreMap.entrySet()) {
    String keyspaceName=entry.getKey();
    List<ColumnFamilyStoreMBean> columnFamilies=entry.getValue();
    long keyspaceReadCount=0;
    long keyspaceWriteCount=0;
    int keyspacePendingTasks=0;
    double keyspaceTotalReadTime=0.0f;
    double keyspaceTotalWriteTime=0.0f;
    outs.println("Keyspace: " + keyspaceName);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      long writeCount=cfstore.getWriteCount();
      long readCount=cfstore.getReadCount();
      if (readCount > 0) {
        keyspaceReadCount+=readCount;
        keyspaceTotalReadTime+=cfstore.getTotalReadLatencyMicros();
      }
      if (writeCount > 0) {
        keyspaceWriteCount+=writeCount;
        keyspaceTotalWriteTime+=cfstore.getTotalWriteLatencyMicros();
      }
      keyspacePendingTasks+=cfstore.getPendingTasks();
    }
    double keyspaceReadLatency=keyspaceReadCount > 0 ? keyspaceTotalReadTime / keyspaceReadCount / 1000 : Double.NaN;
    double keyspaceWriteLatency=keyspaceWriteCount > 0 ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000 : Double.NaN;
    outs.println("\tRead Count: " + keyspaceReadCount);
    outs.println("\tRead Latency: " + String.format("%s",keyspaceReadLatency) + " ms.");
    outs.println("\tWrite Count: " + keyspaceWriteCount);
    outs.println("\tWrite Latency: " + String.format("%s",keyspaceWriteLatency) + " ms.");
    outs.println("\tPending Tasks: " + keyspacePendingTasks);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      String cfName=cfstore.getColumnFamilyName();
      if (cfName.contains("."))       outs.println("\t\tTable (index): " + cfName);
 else       outs.println("\t\tTable: " + cfName);
      outs.println("\t\tSSTable count: " + cfstore.getLiveSSTableCount());
      int[] leveledSStables=cfstore.getSSTableCountPerLevel();
      if (leveledSStables != null) {
        outs.print("\t\tSSTables in each level: [");
        for (int level=0; level < leveledSStables.length; level++) {
          int count=leveledSStables[level];
          outs.print(count);
          long maxCount=4L;
          if (level > 0)           maxCount=(long)Math.pow(10,level);
          if (count > maxCount)           outs.print("/" + maxCount);
          if (level < leveledSStables.length - 1)           outs.print(", ");
 else           outs.println("]");
        }
      }
      outs.println("\t\tSpace used (live), bytes: " + cfstore.getLiveDiskSpaceUsed());
      outs.println("\t\tSpace used (total), bytes: " + cfstore.getTotalDiskSpaceUsed());
      outs.println("\t\tNumber of keys (estimate): " + cfstore.estimateKeys());
      outs.println("\t\tMemtable cell count: " + cfstore.getMemtableColumnsCount());
      outs.println("\t\tMemtable data size, bytes: " + cfstore.getMemtableDataSize());
      outs.println("\t\tMemtable switch count: " + cfstore.getMemtableSwitchCount());
      outs.println("\t\tRead count: " + cfstore.getReadCount());
      outs.println("\t\tRead latency, micros: " + String.format("%01.3f",cfstore.getRecentReadLatencyMicros() / 1000) + " ms.");
      outs.println("\t\tWrite count: " + cfstore.getWriteCount());
      outs.println("\t\tWrite latency, micros: " + String.format("%01.3f",cfstore.getRecentWriteLatencyMicros() / 1000) + " ms.");
      outs.println("\t\tPending tasks: " + cfstore.getPendingTasks());
      outs.println("\t\tBloom filter false positives: " + cfstore.getBloomFilterFalsePositives());
      outs.println("\t\tBloom filter false ratio: " + String.format("%01.5f",cfstore.getRecentBloomFilterFalseRatio()));
      outs.println("\t\tBloom filter space used, bytes: " + cfstore.getBloomFilterDiskSpaceUsed());
      outs.println("\t\tCompacted partition minimum size, bytes: " + cfstore.getMinRowSize());
      outs.println("\t\tCompacted partition maximum size, bytes: " + cfstore.getMaxRowSize());
      outs.println("\t\tCompacted partition mean size, bytes: " + cfstore.getMeanRowSize());
      outs.println("");
    }
    outs.println("----------------");
  }
}
