{
  OptionFilter filter=new OptionFilter(ignoreMode,filterList);
  Map<String,List<ColumnFamilyStoreMBean>> cfstoreMap=new HashMap<String,List<ColumnFamilyStoreMBean>>();
  Iterator<Map.Entry<String,ColumnFamilyStoreMBean>> cfamilies=probe.getColumnFamilyStoreMBeanProxies();
  while (cfamilies.hasNext()) {
    Entry<String,ColumnFamilyStoreMBean> entry=cfamilies.next();
    String keyspaceName=entry.getKey();
    ColumnFamilyStoreMBean cfsProxy=entry.getValue();
    if (!cfstoreMap.containsKey(keyspaceName) && filter.isColumnFamilyIncluded(entry.getKey(),cfsProxy.getColumnFamilyName())) {
      List<ColumnFamilyStoreMBean> columnFamilies=new ArrayList<ColumnFamilyStoreMBean>();
      columnFamilies.add(cfsProxy);
      cfstoreMap.put(keyspaceName,columnFamilies);
    }
 else     if (filter.isColumnFamilyIncluded(entry.getKey(),cfsProxy.getColumnFamilyName())) {
      cfstoreMap.get(keyspaceName).add(cfsProxy);
    }
  }
  filter.verifyKeyspaces(probe.getKeyspaces());
  filter.verifyColumnFamilies();
  for (  Entry<String,List<ColumnFamilyStoreMBean>> entry : cfstoreMap.entrySet()) {
    String keyspaceName=entry.getKey();
    List<ColumnFamilyStoreMBean> columnFamilies=entry.getValue();
    long keyspaceReadCount=0;
    long keyspaceWriteCount=0;
    int keyspacePendingTasks=0;
    double keyspaceTotalReadTime=0.0f;
    double keyspaceTotalWriteTime=0.0f;
    outs.println("Keyspace: " + keyspaceName);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      String cfName=cfstore.getColumnFamilyName();
      long writeCount=((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"WriteLatency")).getCount();
      long readCount=((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"ReadLatency")).getCount();
      if (readCount > 0) {
        keyspaceReadCount+=readCount;
        keyspaceTotalReadTime+=(long)probe.getColumnFamilyMetric(keyspaceName,cfName,"ReadTotalLatency");
      }
      if (writeCount > 0) {
        keyspaceWriteCount+=writeCount;
        keyspaceTotalWriteTime+=(long)probe.getColumnFamilyMetric(keyspaceName,cfName,"WriteTotalLatency");
      }
      keyspacePendingTasks+=(int)probe.getColumnFamilyMetric(keyspaceName,cfName,"PendingTasks");
    }
    double keyspaceReadLatency=keyspaceReadCount > 0 ? keyspaceTotalReadTime / keyspaceReadCount / 1000 : Double.NaN;
    double keyspaceWriteLatency=keyspaceWriteCount > 0 ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000 : Double.NaN;
    outs.println("\tRead Count: " + keyspaceReadCount);
    outs.println("\tRead Latency: " + String.format("%s",keyspaceReadLatency) + " ms.");
    outs.println("\tWrite Count: " + keyspaceWriteCount);
    outs.println("\tWrite Latency: " + String.format("%s",keyspaceWriteLatency) + " ms.");
    outs.println("\tPending Tasks: " + keyspacePendingTasks);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      String cfName=cfstore.getColumnFamilyName();
      if (cfName.contains("."))       outs.println("\t\tTable (index): " + cfName);
 else       outs.println("\t\tTable: " + cfName);
      outs.println("\t\tSSTable count: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"LiveSSTableCount"));
      int[] leveledSStables=cfstore.getSSTableCountPerLevel();
      if (leveledSStables != null) {
        outs.print("\t\tSSTables in each level: [");
        for (int level=0; level < leveledSStables.length; level++) {
          int count=leveledSStables[level];
          outs.print(count);
          long maxCount=4L;
          if (level > 0)           maxCount=(long)Math.pow(10,level);
          if (count > maxCount)           outs.print("/" + maxCount);
          if (level < leveledSStables.length - 1)           outs.print(", ");
 else           outs.println("]");
        }
      }
      outs.println("\t\tSpace used (live), bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"LiveDiskSpaceUsed"));
      outs.println("\t\tSpace used (total), bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"TotalDiskSpaceUsed"));
      outs.println("\t\tSpace used by snapshots (total), bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"SnapshotsSize"));
      outs.println("\t\tSSTable Compression Ratio: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"CompressionRatio"));
      outs.println("\t\tMemtable cell count: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MemtableColumnsCount"));
      outs.println("\t\tMemtable data size, bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MemtableDataSize"));
      outs.println("\t\tMemtable switch count: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MemtableSwitchCount"));
      outs.println("\t\tLocal read count: " + ((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"ReadLatency")).getCount());
      double localReadLatency=((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"ReadLatency")).getMean() / 1000;
      double localRLatency=localReadLatency > 0 ? localReadLatency : Double.NaN;
      outs.printf("\t\tLocal read latency: %01.3f ms%n",localRLatency);
      outs.println("\t\tLocal write count: " + ((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"WriteLatency")).getCount());
      double localWriteLatency=((JmxReporter.TimerMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"WriteLatency")).getMean() / 1000;
      double localWLatency=localWriteLatency > 0 ? localWriteLatency : Double.NaN;
      outs.printf("\t\tLocal write latency: %01.3f ms%n",localWLatency);
      outs.println("\t\tPending tasks: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"PendingTasks"));
      outs.println("\t\tBloom filter false positives: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"BloomFilterFalsePositives"));
      outs.println("\t\tBloom filter false ratio: " + String.format("%01.5f",probe.getColumnFamilyMetric(keyspaceName,cfName,"RecentBloomFilterFalseRatio")));
      outs.println("\t\tBloom filter space used, bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"BloomFilterDiskSpaceUsed"));
      outs.println("\t\tCompacted partition minimum bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MinRowSize"));
      outs.println("\t\tCompacted partition maximum bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MaxRowSize"));
      outs.println("\t\tCompacted partition mean bytes: " + probe.getColumnFamilyMetric(keyspaceName,cfName,"MeanRowSize"));
      outs.println("\t\tAverage live cells per slice (last five minutes): " + ((JmxReporter.HistogramMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"LiveScannedHistogram")).getMean());
      outs.println("\t\tAverage tombstones per slice (last five minutes): " + ((JmxReporter.HistogramMBean)probe.getColumnFamilyMetric(keyspaceName,cfName,"TombstoneScannedHistogram")).getMean());
      outs.println("");
    }
    outs.println("----------------");
  }
}
