{
  OptionFilter filter=new OptionFilter(ignoreMode,filterList);
  Map<String,List<ColumnFamilyStoreMBean>> cfstoreMap=new HashMap<String,List<ColumnFamilyStoreMBean>>();
  Iterator<Map.Entry<String,ColumnFamilyStoreMBean>> cfamilies=probe.getColumnFamilyStoreMBeanProxies();
  while (cfamilies.hasNext()) {
    Entry<String,ColumnFamilyStoreMBean> entry=cfamilies.next();
    String keyspaceName=entry.getKey();
    ColumnFamilyStoreMBean cfsProxy=entry.getValue();
    if (!cfstoreMap.containsKey(keyspaceName) && filter.isColumnFamilyIncluded(entry.getKey(),cfsProxy.getColumnFamilyName())) {
      List<ColumnFamilyStoreMBean> columnFamilies=new ArrayList<ColumnFamilyStoreMBean>();
      columnFamilies.add(cfsProxy);
      cfstoreMap.put(keyspaceName,columnFamilies);
    }
 else     if (filter.isColumnFamilyIncluded(entry.getKey(),cfsProxy.getColumnFamilyName())) {
      cfstoreMap.get(keyspaceName).add(cfsProxy);
    }
  }
  filter.verifyKeyspaces(probe.getKeyspaces());
  filter.verifyColumnFamilies();
  for (  Entry<String,List<ColumnFamilyStoreMBean>> entry : cfstoreMap.entrySet()) {
    String keyspaceName=entry.getKey();
    List<ColumnFamilyStoreMBean> columnFamilies=entry.getValue();
    long keyspaceReadCount=0;
    long keyspaceWriteCount=0;
    int keyspacePendingTasks=0;
    double keyspaceTotalReadTime=0.0f;
    double keyspaceTotalWriteTime=0.0f;
    outs.println("Keyspace: " + keyspaceName);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      long writeCount=cfstore.getWriteCount();
      long readCount=cfstore.getReadCount();
      if (readCount > 0) {
        keyspaceReadCount+=readCount;
        keyspaceTotalReadTime+=cfstore.getTotalReadLatencyMicros();
      }
      if (writeCount > 0) {
        keyspaceWriteCount+=writeCount;
        keyspaceTotalWriteTime+=cfstore.getTotalWriteLatencyMicros();
      }
      keyspacePendingTasks+=cfstore.getPendingTasks();
    }
    double keyspaceReadLatency=keyspaceReadCount > 0 ? keyspaceTotalReadTime / keyspaceReadCount / 1000 : Double.NaN;
    double keyspaceWriteLatency=keyspaceWriteCount > 0 ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000 : Double.NaN;
    outs.println("\tRead Count: " + keyspaceReadCount);
    outs.println("\tRead Latency: " + String.format("%s",keyspaceReadLatency) + " ms.");
    outs.println("\tWrite Count: " + keyspaceWriteCount);
    outs.println("\tWrite Latency: " + String.format("%s",keyspaceWriteLatency) + " ms.");
    outs.println("\tPending Tasks: " + keyspacePendingTasks);
    for (    ColumnFamilyStoreMBean cfstore : columnFamilies) {
      String cfName=cfstore.getColumnFamilyName();
      if (cfName.contains("."))       outs.println("\t\tTable (index): " + cfName);
 else       outs.println("\t\tTable: " + cfName);
      outs.println("\t\tSSTable count: " + cfstore.getLiveSSTableCount());
      int[] leveledSStables=cfstore.getSSTableCountPerLevel();
      if (leveledSStables != null) {
        outs.print("\t\tSSTables in each level: [");
        for (int level=0; level < leveledSStables.length; level++) {
          int count=leveledSStables[level];
          outs.print(count);
          long maxCount=4L;
          if (level > 0)           maxCount=(long)Math.pow(10,level);
          if (count > maxCount)           outs.print("/" + maxCount);
          if (level < leveledSStables.length - 1)           outs.print(", ");
 else           outs.println("]");
        }
      }
      long bloomFilterOffHeapSize=cfstore.getBloomFilterOffHeapMemoryUsed();
      long indexSummaryOffHeapSize=cfstore.getIndexSummaryOffHeapMemoryUsed();
      long compressionMetadataOffHeapSize=cfstore.getCompressionMetadataOffHeapMemoryUsed();
      long offHeapSize=bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize;
      outs.println("\t\tSpace used (live), bytes: " + cfstore.getLiveDiskSpaceUsed());
      outs.println("\t\tSpace used (total), bytes: " + cfstore.getTotalDiskSpaceUsed());
      outs.println("\t\tOff heap memory used (total), bytes: " + offHeapSize);
      outs.println("\t\tSSTable Compression Ratio: " + cfstore.getCompressionRatio());
      outs.println("\t\tNumber of keys (estimate): " + cfstore.estimateKeys());
      outs.println("\t\tMemtable cell count: " + cfstore.getMemtableColumnsCount());
      outs.println("\t\tMemtable data size, bytes: " + cfstore.getMemtableDataSize());
      outs.println("\t\tMemtable switch count: " + cfstore.getMemtableSwitchCount());
      outs.println("\t\tLocal read count: " + cfstore.getReadCount());
      outs.printf("\t\tLocal read latency: %01.3f ms%n",cfstore.getRecentReadLatencyMicros() / 1000);
      outs.println("\t\tLocal write count: " + cfstore.getWriteCount());
      outs.printf("\t\tLocal write latency: %01.3f ms%n",cfstore.getRecentWriteLatencyMicros() / 1000);
      outs.println("\t\tPending tasks: " + cfstore.getPendingTasks());
      outs.println("\t\tBloom filter false positives: " + cfstore.getBloomFilterFalsePositives());
      outs.println("\t\tBloom filter false ratio: " + String.format("%01.5f",cfstore.getRecentBloomFilterFalseRatio()));
      outs.println("\t\tBloom filter space used, bytes: " + cfstore.getBloomFilterDiskSpaceUsed());
      outs.println("\t\tBloom filter off heap memory used, bytes: " + bloomFilterOffHeapSize);
      outs.println("\t\tIndex summary off heap memory used, bytes: " + indexSummaryOffHeapSize);
      outs.println("\t\tCompression metadata off heap memory used, bytes: " + compressionMetadataOffHeapSize);
      outs.println("\t\tCompacted partition minimum bytes: " + cfstore.getMinRowSize());
      outs.println("\t\tCompacted partition maximum bytes: " + cfstore.getMaxRowSize());
      outs.println("\t\tCompacted partition mean bytes: " + cfstore.getMeanRowSize());
      outs.println("\t\tAverage live cells per slice (last five minutes): " + cfstore.getLiveCellsPerSlice());
      outs.println("\t\tAverage tombstones per slice (last five minutes): " + cfstore.getTombstonesPerSlice());
      outs.println("");
    }
    outs.println("----------------");
  }
}
