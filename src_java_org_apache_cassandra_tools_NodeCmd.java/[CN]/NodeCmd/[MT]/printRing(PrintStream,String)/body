{
  Map<String,String> tokensToEndpoints=probe.getTokenToEndpointMap();
  LinkedHashMultimap<String,String> endpointsToTokens=LinkedHashMultimap.create();
  for (  Map.Entry<String,String> entry : tokensToEndpoints.entrySet())   endpointsToTokens.put(entry.getValue(),entry.getKey());
  int maxAddressLength=Collections.max(endpointsToTokens.keys(),new Comparator<String>(){
    @Override public int compare(    String first,    String second){
      return ((Integer)first.length()).compareTo((Integer)second.length());
    }
  }
).length();
  String formatPlaceholder="%%-%ds  %%-12s%%-7s%%-8s%%-16s%%-20s%%-44s%%n";
  String format=String.format(formatPlaceholder,maxAddressLength);
  Map<InetAddress,Float> ownerships;
  boolean keyspaceSelected;
  try {
    ownerships=probe.effectiveOwnership(keyspace);
    keyspaceSelected=true;
  }
 catch (  IllegalStateException ex) {
    ownerships=probe.getOwnership();
    outs.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
    keyspaceSelected=false;
  }
  try {
    outs.println();
    for (    Entry<String,SetHostStat> entry : getOwnershipByDc(false,tokensToEndpoints,ownerships).entrySet())     printDc(outs,format,entry.getKey(),endpointsToTokens,keyspaceSelected,entry.getValue());
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
  if (DatabaseDescriptor.getNumTokens() > 1) {
    outs.println("  Warning: \"nodetool ring\" is used to output all the tokens of a node.");
    outs.println("  To view status related info of a node use \"nodetool status\" instead.\n");
  }
}
