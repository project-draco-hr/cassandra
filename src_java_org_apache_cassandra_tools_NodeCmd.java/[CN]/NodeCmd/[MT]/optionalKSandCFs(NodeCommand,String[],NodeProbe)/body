{
  if (cmdArgs.length == 1) {
    for (    String keyspace : probe.getKeyspaces()) {
switch (nc) {
case REPAIR:
        probe.forceTableRepair(keyspace);
      break;
case INVALIDATEKEYCACHE:
    probe.invalidateKeyCaches(keyspace);
  break;
case INVALIDATEROWCACHE:
probe.invalidateRowCaches(keyspace);
break;
case FLUSH:
try {
probe.forceTableFlush(keyspace);
}
 catch (ExecutionException ee) {
err(ee,"Error occured while flushing keyspace " + keyspace);
}
break;
case COMPACT:
try {
probe.forceTableCompaction(keyspace);
}
 catch (ExecutionException ee) {
err(ee,"Error occured while compacting keyspace " + keyspace);
}
break;
case CLEANUP:
if (keyspace.equals("system")) {
break;
}
try {
probe.forceTableCleanup(keyspace);
}
 catch (ExecutionException ee) {
err(ee,"Error occured while cleaning up keyspace " + keyspace);
}
break;
default :
throw new RuntimeException("Unreachable code.");
}
}
}
 else {
String keyspace=cmdArgs[1];
String[] columnFamilies=new String[cmdArgs.length - 2];
for (int i=0; i < columnFamilies.length; i++) {
columnFamilies[i]=cmdArgs[i + 2];
}
switch (nc) {
case REPAIR:
probe.forceTableRepair(keyspace,columnFamilies);
break;
case INVALIDATEKEYCACHE:
probe.invalidateKeyCaches(keyspace,columnFamilies);
break;
case INVALIDATEROWCACHE:
probe.invalidateRowCaches(keyspace,columnFamilies);
break;
case FLUSH:
try {
probe.forceTableFlush(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during flushing");
}
break;
case COMPACT:
try {
probe.forceTableCompaction(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during compaction");
}
break;
case CLEANUP:
try {
probe.forceTableCleanup(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during cleanup");
}
break;
default :
throw new RuntimeException("Unreachable code.");
}
}
}
