{
  List<String> keyspaces=cmdArgs.length == 0 ? probe.getKeyspaces() : Arrays.asList(cmdArgs[0]);
  for (  String keyspace : keyspaces) {
    if (!probe.getKeyspaces().contains(keyspace)) {
      System.err.println("Keyspace [" + keyspace + "] does not exist.");
      System.exit(1);
    }
  }
  for (  String keyspace : keyspaces) {
    String[] columnFamilies=cmdArgs.length <= 1 ? new String[0] : Arrays.copyOfRange(cmdArgs,1,cmdArgs.length);
switch (nc) {
case REPAIR:
      probe.forceTableRepair(keyspace,columnFamilies);
    break;
case INVALIDATEKEYCACHE:
  probe.invalidateKeyCaches(keyspace,columnFamilies);
break;
case INVALIDATEROWCACHE:
probe.invalidateRowCaches(keyspace,columnFamilies);
break;
case FLUSH:
try {
probe.forceTableFlush(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during flushing");
}
break;
case COMPACT:
try {
probe.forceTableCompaction(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during compaction");
}
break;
case CLEANUP:
if (keyspace.equals("system")) {
break;
}
try {
probe.forceTableCleanup(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured during cleanup");
}
break;
case SCRUB:
try {
probe.scrub(keyspace,columnFamilies);
}
 catch (ExecutionException ee) {
err(ee,"Error occured while scrubbing keyspace " + keyspace);
}
break;
default :
throw new RuntimeException("Unreachable code.");
}
}
}
