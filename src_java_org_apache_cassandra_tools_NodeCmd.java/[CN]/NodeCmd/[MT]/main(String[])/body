{
  CommandLineParser parser=new PosixParser();
  ToolCommandLine cmd=null;
  try {
    cmd=new ToolCommandLine(parser.parse(options,args));
  }
 catch (  ParseException p) {
    badUse(p.getMessage());
  }
  String host=cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;
  int port=DEFAULT_PORT;
  String portNum=cmd.getOptionValue(PORT_OPT.left);
  if (portNum != null) {
    try {
      port=Integer.parseInt(portNum);
    }
 catch (    NumberFormatException e) {
      throw new ParseException("Port must be a number");
    }
  }
  NodeCommand command=null;
  try {
    command=cmd.getCommand();
  }
 catch (  IllegalArgumentException e) {
    badUse(e.getMessage());
  }
  if (NodeCommand.HELP.equals(command)) {
    printUsage();
    System.exit(0);
  }
  NodeProbe probe=null;
  try {
    String username=cmd.getOptionValue(USERNAME_OPT.left);
    String password=cmd.getOptionValue(PASSWORD_OPT.left);
    try {
      probe=username == null ? new NodeProbe(host,port) : new NodeProbe(host,port,username,password);
    }
 catch (    IOException ioe) {
      Throwable inner=findInnermostThrowable(ioe);
      if (inner instanceof ConnectException) {
        System.err.printf("Failed to connect to '%s:%d': %s%n",host,port,inner.getMessage());
        System.exit(1);
      }
 else       if (inner instanceof UnknownHostException) {
        System.err.printf("Cannot resolve '%s': unknown host%n",host);
        System.exit(1);
      }
 else {
        err(ioe,"Error connecting to remote JMX agent!");
      }
    }
    NodeCmd nodeCmd=new NodeCmd(probe);
    printHistory(args,cmd);
    String[] arguments=cmd.getCommandArguments();
    String tag;
    String columnFamilyName=null;
switch (command) {
case RING:
      if (arguments.length > 0) {
        nodeCmd.printRing(System.out,arguments[0]);
      }
 else {
        nodeCmd.printRing(System.out,null);
      }
    ;
  break;
case INFO:
nodeCmd.printInfo(System.out,cmd);
break;
case CFSTATS:
boolean ignoreMode=cmd.hasOption(CFSTATS_IGNORE_OPT.left);
if (arguments.length > 0) {
nodeCmd.printColumnFamilyStats(System.out,ignoreMode,arguments);
}
 else {
nodeCmd.printColumnFamilyStats(System.out,false,null);
}
break;
case TPSTATS:
nodeCmd.printThreadPoolStats(System.out);
break;
case VERSION:
nodeCmd.printReleaseVersion(System.out);
break;
case COMPACTIONSTATS:
nodeCmd.printCompactionStats(System.out);
break;
case COMPACTIONHISTORY:
nodeCmd.printCompactionHistory(System.out);
break;
case DESCRIBECLUSTER:
nodeCmd.printClusterDescription(System.out,host);
break;
case DISABLEBINARY:
probe.stopNativeTransport();
break;
case ENABLEBINARY:
probe.startNativeTransport();
break;
case STATUSBINARY:
nodeCmd.printIsNativeTransportRunning(System.out);
break;
case DISABLEGOSSIP:
probe.stopGossiping();
break;
case ENABLEGOSSIP:
probe.startGossiping();
break;
case DISABLEHANDOFF:
probe.disableHintedHandoff();
break;
case ENABLEHANDOFF:
probe.enableHintedHandoff();
break;
case PAUSEHANDOFF:
probe.pauseHintsDelivery();
break;
case RESUMEHANDOFF:
probe.resumeHintsDelivery();
break;
case DISABLETHRIFT:
probe.stopThriftServer();
break;
case ENABLETHRIFT:
probe.startThriftServer();
break;
case STATUSTHRIFT:
nodeCmd.printIsThriftServerRunning(System.out);
break;
case RESETLOCALSCHEMA:
probe.resetLocalSchema();
break;
case ENABLEBACKUP:
probe.setIncrementalBackupsEnabled(true);
break;
case DISABLEBACKUP:
probe.setIncrementalBackupsEnabled(false);
break;
case TRUNCATEHINTS:
if (arguments.length > 1) badUse("Too many arguments.");
 else if (arguments.length == 1) probe.truncateHints(arguments[0]);
 else probe.truncateHints();
break;
case STATUS:
boolean resolveIp=cmd.hasOption(RESOLVE_IP.left);
if (arguments.length > 0) nodeCmd.printClusterStatus(System.out,arguments[0],resolveIp);
 else nodeCmd.printClusterStatus(System.out,null,resolveIp);
break;
case DECOMMISSION:
if (arguments.length > 0) {
System.err.println("Decommission will decommission the node you are connected to and does not take arguments!");
System.exit(1);
}
probe.decommission();
break;
case DRAIN:
try {
probe.drain();
}
 catch (ExecutionException ee) {
err(ee,"Error occured during flushing");
}
break;
case NETSTATS:
if (arguments.length > 0) {
nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]),System.out);
}
 else {
nodeCmd.printNetworkStats(null,System.out);
}
break;
case SNAPSHOT:
columnFamilyName=cmd.getOptionValue(SNAPSHOT_COLUMNFAMILY_OPT.left);
case CLEARSNAPSHOT:
tag=cmd.getOptionValue(TAG_OPT.left);
handleSnapshots(command,tag,arguments,columnFamilyName,probe);
break;
case MOVE:
if (arguments.length != 1) {
badUse("Missing token argument for move.");
}
try {
probe.move(arguments[0]);
}
 catch (UnsupportedOperationException uoerror) {
System.err.println(uoerror.getMessage());
System.exit(1);
}
break;
case JOIN:
if (probe.isJoined()) {
System.err.println("This node has already joined the ring.");
System.exit(1);
}
probe.joinRing();
break;
case SETCOMPACTIONTHROUGHPUT:
if (arguments.length != 1) {
badUse("Missing value argument.");
}
probe.setCompactionThroughput(Integer.parseInt(arguments[0]));
break;
case SETSTREAMTHROUGHPUT:
if (arguments.length != 1) {
badUse("Missing value argument.");
}
probe.setStreamThroughput(Integer.parseInt(arguments[0]));
break;
case SETTRACEPROBABILITY:
if (arguments.length != 1) {
badUse("Missing value argument.");
}
probe.setTraceProbability(Double.parseDouble(arguments[0]));
break;
case TAKETOKEN:
if (arguments.length < 1) {
badUse("Must supply at least one token to take");
}
probe.takeTokens(arguments);
break;
case REBUILD:
if (arguments.length > 1) {
badUse("Too many arguments.");
}
probe.rebuild(arguments.length == 1 ? arguments[0] : null);
break;
case REMOVETOKEN:
System.err.println("Warn: removetoken is deprecated, please use removenode instead");
case REMOVENODE:
if (arguments.length != 1) {
badUse("Missing an argument for removenode (either status, force, or an ID)");
}
 else if (arguments[0].equals("status")) {
nodeCmd.printRemovalStatus(System.out);
}
 else if (arguments[0].equals("force")) {
nodeCmd.printRemovalStatus(System.out);
probe.forceRemoveCompletion();
}
 else {
probe.removeNode(arguments[0]);
}
break;
case INVALIDATEKEYCACHE:
probe.invalidateKeyCache();
break;
case INVALIDATEROWCACHE:
probe.invalidateRowCache();
break;
case CLEANUP:
case COMPACT:
case REPAIR:
case FLUSH:
case SCRUB:
case UPGRADESSTABLES:
case DISABLEAUTOCOMPACTION:
case ENABLEAUTOCOMPACTION:
optionalKSandCFs(command,cmd,arguments,probe);
break;
case GETCOMPACTIONTHRESHOLD:
if (arguments.length != 2) {
badUse("getcompactionthreshold requires ks and cf args.");
}
nodeCmd.printCompactionThreshold(System.out,arguments[0],arguments[1]);
break;
case GETCOMPACTIONTHROUGHPUT:
nodeCmd.printCompactionThroughput(System.out);
break;
case GETSTREAMTHROUGHPUT:
nodeCmd.printStreamThroughput(System.out);
break;
case CFHISTOGRAMS:
if (arguments.length != 2) {
badUse("cfhistograms requires ks and cf args");
}
nodeCmd.printCfHistograms(arguments[0],arguments[1],System.out,cmd.hasOption(COMPACT_OPT.left));
break;
case SETCACHECAPACITY:
if (arguments.length != 2) {
badUse("setcachecapacity requires key-cache-capacity, and row-cache-capacity args.");
}
probe.setCacheCapacities(Integer.parseInt(arguments[0]),Integer.parseInt(arguments[1]));
break;
case SETCACHEKEYSTOSAVE:
if (arguments.length != 2) {
badUse("setcachekeystosave requires key-cache-keys-to-save, and row-cache-keys-to-save args.");
}
probe.setCacheKeysToSave(Integer.parseInt(arguments[0]),Integer.parseInt(arguments[1]));
break;
case SETCOMPACTIONTHRESHOLD:
if (arguments.length != 4) {
badUse("setcompactionthreshold requires ks, cf, min, and max threshold args.");
}
int minthreshold=Integer.parseInt(arguments[2]);
int maxthreshold=Integer.parseInt(arguments[3]);
if ((minthreshold < 0) || (maxthreshold < 0)) {
badUse("Thresholds must be positive integers");
}
if (minthreshold > maxthreshold) {
badUse("Min threshold cannot be greater than max.");
}
if (minthreshold < 2 && maxthreshold != 0) {
badUse("Min threshold must be at least 2");
}
probe.setCompactionThreshold(arguments[0],arguments[1],minthreshold,maxthreshold);
break;
case GETENDPOINTS:
if (arguments.length != 3) {
badUse("getendpoints requires ks, cf and key args");
}
nodeCmd.printEndPoints(arguments[0],arguments[1],arguments[2],System.out);
break;
case PROXYHISTOGRAMS:
if (arguments.length != 0) {
badUse("proxyhistograms does not take arguments");
}
nodeCmd.printProxyHistograms(System.out,cmd.hasOption(COMPACT_OPT.left));
break;
case GETSSTABLES:
if (arguments.length != 3) {
badUse("getsstables requires ks, cf and key args");
}
nodeCmd.printSSTables(arguments[0],arguments[1],arguments[2],System.out);
break;
case REFRESH:
if (arguments.length != 2) {
badUse("load_new_sstables requires ks and cf args");
}
probe.loadNewSSTables(arguments[0],arguments[1]);
break;
case REBUILD_INDEX:
if (arguments.length < 2) {
badUse("rebuild_index requires ks and cf args");
}
if (arguments.length >= 3) probe.rebuildIndex(arguments[0],arguments[1],arguments[2].split(","));
 else probe.rebuildIndex(arguments[0],arguments[1]);
break;
case GOSSIPINFO:
nodeCmd.printGossipInfo(System.out);
break;
case STOP:
if (arguments.length != 1) {
badUse("stop requires a type.");
}
probe.stop(arguments[0].toUpperCase());
break;
case STOPDAEMON:
if (arguments.length != 0) {
badUse("stopdaemon does not take arguments.");
}
try {
probe.stopCassandraDaemon();
}
 catch (Throwable t) {
System.out.println("Cassandra has shut down.\n");
}
break;
case DESCRIBERING:
if (arguments.length != 1) {
badUse("Missing keyspace argument for describering.");
}
nodeCmd.printDescribeRing(arguments[0],System.out);
break;
case RANGEKEYSAMPLE:
nodeCmd.printRangeKeySample(System.out);
break;
case RELOADTRIGGERS:
probe.reloadTriggers();
break;
default :
throw new RuntimeException("Unreachable code.");
}
}
  finally {
if (probe != null) {
try {
probe.close();
}
 catch (IOException ex) {
}
}
}
System.exit(probe.isFailed() ? 1 : 0);
}
