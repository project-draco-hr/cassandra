{
  CommandLineParser parser=new PosixParser();
  CommandLine cmd=null;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException parseExcep) {
    badUse(parseExcep.toString());
  }
  String host=cmd.getOptionValue(HOST_OPT_LONG);
  int port=defaultPort;
  String portNum=cmd.getOptionValue(PORT_OPT_LONG);
  if (portNum != null) {
    try {
      port=Integer.parseInt(portNum);
    }
 catch (    NumberFormatException e) {
      throw new ParseException("Port must be a number");
    }
  }
  String username=cmd.getOptionValue(USERNAME_OPT_LONG);
  String password=cmd.getOptionValue(PASSWORD_OPT_LONG);
  NodeProbe probe=null;
  try {
    probe=username == null ? new NodeProbe(host,port) : new NodeProbe(host,port,username,password);
  }
 catch (  IOException ioe) {
    err(ioe,"Error connection to remote JMX agent!");
  }
  if (cmd.getArgs().length < 1)   badUse("Missing argument for command.");
  NodeCmd nodeCmd=new NodeCmd(probe);
  String[] arguments=cmd.getArgs();
  String cmdName=arguments[0];
  boolean validCommand=false;
  for (  NodeCommand n : NodeCommand.values()) {
    if (cmdName.toUpperCase().equals(n.name()))     validCommand=true;
  }
  if (!validCommand)   badUse("Unrecognized command: " + cmdName);
  NodeCommand nc=NodeCommand.valueOf(cmdName.toUpperCase());
switch (nc) {
case RING:
    nodeCmd.printRing(System.out);
  break;
case INFO:
nodeCmd.printInfo(System.out);
break;
case CFSTATS:
nodeCmd.printColumnFamilyStats(System.out);
break;
case DECOMMISSION:
probe.decommission();
break;
case LOADBALANCE:
probe.loadBalance();
break;
case CLEARSNAPSHOT:
probe.clearSnapshot();
break;
case TPSTATS:
nodeCmd.printThreadPoolStats(System.out);
break;
case VERSION:
nodeCmd.printReleaseVersion(System.out);
break;
case COMPACTIONSTATS:
nodeCmd.printCompactionStats(System.out);
break;
case DRAIN:
try {
probe.drain();
}
 catch (ExecutionException ee) {
err(ee,"Error occured during flushing");
}
break;
case NETSTATS:
if (arguments.length > 1) {
nodeCmd.printNetworkStats(InetAddress.getByName(arguments[1]),System.out);
}
 else {
nodeCmd.printNetworkStats(null,System.out);
}
break;
case SNAPSHOT:
if (arguments.length > 1) {
probe.takeSnapshot(arguments[1]);
}
 else {
probe.takeSnapshot("");
}
break;
case MOVE:
if (arguments.length != 2) {
badUse("Missing token argument for move.");
}
probe.move(arguments[1]);
break;
case REMOVETOKEN:
if (arguments.length != 2) {
badUse("Missing an argument for removetoken (either status, force, or a token)");
}
 else if (arguments[1].equals("status")) {
nodeCmd.printRemovalStatus(System.out);
}
 else if (arguments[1].equals("force")) {
nodeCmd.printRemovalStatus(System.out);
probe.forceRemoveCompletion();
}
 else {
probe.removeToken(arguments[1]);
}
break;
case CLEANUP:
case COMPACT:
case REPAIR:
case FLUSH:
optionalKSandCFs(nc,arguments,probe);
break;
case GETCOMPACTIONTHRESHOLD:
if (arguments.length != 3) {
badUse("getcompactionthreshold requires ks and cf args.");
}
probe.getCompactionThreshold(System.out,arguments[1],arguments[2]);
break;
case CFHISTOGRAMS:
if (arguments.length != 3) {
badUse("cfhistograms requires ks and cf args");
}
nodeCmd.printCfHistograms(arguments[1],arguments[2],System.out);
break;
case SETCACHECAPACITY:
if (arguments.length != 5) {
badUse("setcachecapacity requires ks, cf, keycachecap, and rowcachecap args.");
}
probe.setCacheCapacities(arguments[1],arguments[2],Integer.parseInt(arguments[3]),Integer.parseInt(arguments[4]));
break;
case SETCOMPACTIONTHRESHOLD:
if (arguments.length != 5) {
badUse("setcompactionthreshold requires ks, cf, min, and max threshold args.");
}
int minthreshold=Integer.parseInt(arguments[3]);
int maxthreshold=Integer.parseInt(arguments[4]);
if ((minthreshold < 0) || (maxthreshold < 0)) {
badUse("Thresholds must be positive integers");
}
if (minthreshold > maxthreshold) {
badUse("Min threshold cannot be greater than max.");
}
if (minthreshold < 2 && maxthreshold != 0) {
badUse("Min threshold must be at least 2");
}
probe.setCompactionThreshold(arguments[1],arguments[2],minthreshold,maxthreshold);
break;
default :
throw new RuntimeException("Unreachable code.");
}
System.exit(0);
}
