{
  Map<InetAddress,Float> ownerships;
  boolean hasEffectiveOwns=false, isTokenPerNode=true;
  try {
    ownerships=probe.effectiveOwnership(kSpace);
    hasEffectiveOwns=true;
  }
 catch (  IllegalStateException e) {
    ownerships=probe.getOwnership();
  }
  if (tokensToEndpoints.values().size() < tokensToEndpoints.keySet().size())   isTokenPerNode=false;
  Map<String,SetHostStat> dcs=getOwnershipByDc(resolveIp,tokensToEndpoints,ownerships);
  findMaxAddressLength(dcs);
  for (  Map.Entry<String,SetHostStat> dc : dcs.entrySet()) {
    String dcHeader=String.format("Datacenter: %s%n",dc.getKey());
    outs.printf(dcHeader);
    for (int i=0; i < (dcHeader.length() - 1); i++)     outs.print('=');
    outs.println();
    printStatusLegend();
    printNodesHeader(hasEffectiveOwns,isTokenPerNode);
    ArrayListMultimap<String,String> hostToTokens=ArrayListMultimap.create();
    for (    HostStat stat : dc.getValue())     hostToTokens.put(stat.ipOrDns(),stat.token);
    for (    String endpoint : hostToTokens.keySet()) {
      Float owns=ownerships.get(InetAddress.getByName(endpoint));
      List<String> tokens=hostToTokens.get(endpoint);
      printNode(endpoint,owns,tokens,hasEffectiveOwns,isTokenPerNode);
    }
  }
}
