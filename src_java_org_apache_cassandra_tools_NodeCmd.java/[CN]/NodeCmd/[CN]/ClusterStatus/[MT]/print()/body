{
  Map<InetAddress,Float> ownerships;
  boolean hasEffectiveOwns=false, isTokenPerNode=true;
  try {
    ownerships=probe.effectiveOwnership(kSpace);
    hasEffectiveOwns=true;
  }
 catch (  IllegalStateException e) {
    ownerships=probe.getOwnership();
  }
  if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())   isTokenPerNode=false;
  maxAddressLength=0;
  for (  Map.Entry<String,Map<InetAddress,Float>> dc : getOwnershipByDc(ownerships).entrySet()) {
    int dcMaxAddressLength=Collections.max(dc.getValue().keySet(),new Comparator<InetAddress>(){
      @Override public int compare(      InetAddress first,      InetAddress second){
        return ((Integer)first.getHostAddress().length()).compareTo((Integer)second.getHostAddress().length());
      }
    }
).getHostAddress().length();
    if (dcMaxAddressLength > maxAddressLength)     maxAddressLength=dcMaxAddressLength;
  }
  for (  Map.Entry<String,Map<InetAddress,Float>> dc : getOwnershipByDc(ownerships).entrySet()) {
    String dcHeader=String.format("Datacenter: %s%n",dc.getKey());
    outs.printf(dcHeader);
    for (int i=0; i < (dcHeader.length() - 1); i++)     outs.print('=');
    outs.println();
    printStatusLegend();
    printNodesHeader(hasEffectiveOwns,isTokenPerNode);
    for (    Map.Entry<InetAddress,Float> entry : dc.getValue().entrySet())     printNode(entry.getKey().getHostAddress(),entry.getValue(),ownerships,hasEffectiveOwns,isTokenPerNode);
  }
}
