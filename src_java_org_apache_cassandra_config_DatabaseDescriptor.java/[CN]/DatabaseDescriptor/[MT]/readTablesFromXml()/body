{
  List<KSMetaData> defs=new ArrayList<KSMetaData>();
  XMLUtils xmlUtils=null;
  try {
    xmlUtils=new XMLUtils(configFileName);
  }
 catch (  ParserConfigurationException e) {
    ConfigurationException ex=new ConfigurationException(e.getMessage());
    ex.initCause(e);
    throw ex;
  }
catch (  SAXException e) {
    ConfigurationException ex=new ConfigurationException(e.getMessage());
    ex.initCause(e);
    throw ex;
  }
catch (  IOException e) {
    ConfigurationException ex=new ConfigurationException(e.getMessage());
    ex.initCause(e);
    throw ex;
  }
  try {
    NodeList tablesxml=xmlUtils.getRequestedNodeList("/Storage/Keyspaces/Keyspace");
    int size=tablesxml.getLength();
    for (int i=0; i < size; ++i) {
      String value=null;
      Node table=tablesxml.item(i);
      String ksName=XMLUtils.getAttributeValue(table,"Name");
      if (ksName == null) {
        throw new ConfigurationException("Table name attribute is required");
      }
      if (ksName.equalsIgnoreCase(Table.SYSTEM_TABLE)) {
        throw new ConfigurationException("'system' is a reserved table name for Cassandra internals");
      }
      value=xmlUtils.getNodeValue("/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/ReplicaPlacementStrategy");
      if (value == null) {
        throw new ConfigurationException("Missing replicaplacementstrategy directive for " + ksName);
      }
      Class<? extends AbstractReplicationStrategy> strategyClass=null;
      try {
        strategyClass=(Class<? extends AbstractReplicationStrategy>)Class.forName(value);
      }
 catch (      ClassNotFoundException e) {
        throw new ConfigurationException("Invalid replicaplacementstrategy class " + value);
      }
      value=xmlUtils.getNodeValue("/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/ReplicationFactor");
      int replicationFactor=-1;
      if (value == null)       throw new ConfigurationException("Missing replicationfactor directory for keyspace " + ksName);
 else {
        replicationFactor=Integer.parseInt(value);
      }
      String xqlTable="/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/";
      NodeList columnFamilies=xmlUtils.getRequestedNodeList(xqlTable + "ColumnFamily");
      int size2=columnFamilies.getLength();
      CFMetaData[] cfDefs=new CFMetaData[size2];
      for (int j=0; j < size2; ++j) {
        Node columnFamily=columnFamilies.item(j);
        String tableName=ksName;
        String cfName=XMLUtils.getAttributeValue(columnFamily,"Name");
        if (cfName == null) {
          throw new ConfigurationException("ColumnFamily name attribute is required");
        }
        if (cfName.contains("-")) {
          throw new ConfigurationException("ColumnFamily names cannot contain hyphens");
        }
        String xqlCF=xqlTable + "ColumnFamily[@Name='" + cfName+ "']/";
        String rawColumnType=XMLUtils.getAttributeValue(columnFamily,"ColumnType");
        String columnType=ColumnFamily.getColumnType(rawColumnType);
        if (columnType == null) {
          throw new ConfigurationException("ColumnFamily " + cfName + " has invalid type "+ rawColumnType);
        }
        if (XMLUtils.getAttributeValue(columnFamily,"ColumnSort") != null) {
          throw new ConfigurationException("ColumnSort is no longer an accepted attribute.  Use CompareWith instead.");
        }
        AbstractType comparator=getComparator(XMLUtils.getAttributeValue(columnFamily,"CompareWith"));
        AbstractType subcolumnComparator=null;
        if (columnType.equals("Super")) {
          subcolumnComparator=getComparator(XMLUtils.getAttributeValue(columnFamily,"CompareSubcolumnsWith"));
        }
 else         if (XMLUtils.getAttributeValue(columnFamily,"CompareSubcolumnsWith") != null) {
          throw new ConfigurationException("CompareSubcolumnsWith is only a valid attribute on super columnfamilies (not regular columnfamily " + cfName + ")");
        }
        double keyCacheSize=CFMetaData.DEFAULT_KEY_CACHE_SIZE;
        if ((value=XMLUtils.getAttributeValue(columnFamily,"KeysCachedFraction")) != null) {
          keyCacheSize=Double.valueOf(value);
          logger.warn("KeysCachedFraction is deprecated: use KeysCached instead.");
        }
        if ((value=XMLUtils.getAttributeValue(columnFamily,"KeysCached")) != null) {
          keyCacheSize=FBUtilities.parseDoubleOrPercent(value);
        }
        double rowCacheSize=CFMetaData.DEFAULT_ROW_CACHE_SIZE;
        if ((value=XMLUtils.getAttributeValue(columnFamily,"RowsCached")) != null) {
          rowCacheSize=FBUtilities.parseDoubleOrPercent(value);
        }
        double readRepairChance=CFMetaData.DEFAULT_READ_REPAIR_CHANCE;
        if ((value=XMLUtils.getAttributeValue(columnFamily,"ReadRepairChance")) != null) {
          readRepairChance=FBUtilities.parseDoubleOrPercent(value);
          if (readRepairChance < 0.0 || readRepairChance > 1.0) {
            throw new ConfigurationException("ReadRepairChance must be between 0.0 and 1.0");
          }
        }
        String comment=xmlUtils.getNodeValue(xqlCF + "Comment");
        cfDefs[j]=new CFMetaData(tableName,cfName,columnType,comparator,subcolumnComparator,comment,rowCacheSize,keyCacheSize,readRepairChance);
      }
      defs.add(new KSMetaData(ksName,strategyClass,replicationFactor,cfDefs));
    }
  }
 catch (  XPathExpressionException e) {
    ConfigurationException ex=new ConfigurationException(e.getMessage());
    ex.initCause(e);
    throw ex;
  }
catch (  TransformerException e) {
    ConfigurationException ex=new ConfigurationException(e.getMessage());
    ex.initCause(e);
    throw ex;
  }
  return defs;
}
