{
  conf=config;
  if (conf.commitlog_sync == null) {
    throw new ConfigurationException("Missing required directive CommitLogSync",false);
  }
  if (conf.commitlog_sync == Config.CommitLogSync.batch) {
    if (conf.commitlog_sync_batch_window_in_ms == null) {
      throw new ConfigurationException("Missing value for commitlog_sync_batch_window_in_ms: Double expected.",false);
    }
 else     if (conf.commitlog_sync_period_in_ms != null) {
      throw new ConfigurationException("Batch sync specified, but commitlog_sync_period_in_ms found. Only specify commitlog_sync_batch_window_in_ms when using batch sync",false);
    }
    logger.debug("Syncing log with a batch window of {}",conf.commitlog_sync_batch_window_in_ms);
  }
 else {
    if (conf.commitlog_sync_period_in_ms == null) {
      throw new ConfigurationException("Missing value for commitlog_sync_period_in_ms: Integer expected",false);
    }
 else     if (conf.commitlog_sync_batch_window_in_ms != null) {
      throw new ConfigurationException("commitlog_sync_period_in_ms specified, but commitlog_sync_batch_window_in_ms found.  Only specify commitlog_sync_period_in_ms when using periodic sync.",false);
    }
    logger.debug("Syncing log with a period of {}",conf.commitlog_sync_period_in_ms);
  }
  if (conf.commitlog_total_space_in_mb == null)   conf.commitlog_total_space_in_mb=hasLargeAddressSpace() ? 8192 : 32;
  if (FBUtilities.isWindows()) {
    conf.disk_access_mode=Config.DiskAccessMode.standard;
    indexAccessMode=conf.disk_access_mode;
    logger.info("Windows environment detected.  DiskAccessMode set to {}, indexAccessMode {}",conf.disk_access_mode,indexAccessMode);
  }
 else {
    if (conf.disk_access_mode == Config.DiskAccessMode.auto) {
      conf.disk_access_mode=hasLargeAddressSpace() ? Config.DiskAccessMode.mmap : Config.DiskAccessMode.standard;
      indexAccessMode=conf.disk_access_mode;
      logger.info("DiskAccessMode 'auto' determined to be {}, indexAccessMode is {}",conf.disk_access_mode,indexAccessMode);
    }
 else     if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only) {
      conf.disk_access_mode=Config.DiskAccessMode.standard;
      indexAccessMode=Config.DiskAccessMode.mmap;
      logger.info("DiskAccessMode is {}, indexAccessMode is {}",conf.disk_access_mode,indexAccessMode);
    }
 else {
      indexAccessMode=conf.disk_access_mode;
      logger.info("DiskAccessMode is {}, indexAccessMode is {}",conf.disk_access_mode,indexAccessMode);
    }
  }
  if (conf.authenticator != null)   authenticator=FBUtilities.newAuthenticator(conf.authenticator);
  if (conf.authorizer != null)   authorizer=FBUtilities.newAuthorizer(conf.authorizer);
  if (authenticator instanceof AllowAllAuthenticator && !(authorizer instanceof AllowAllAuthorizer))   throw new ConfigurationException("AllowAllAuthenticator can't be used with " + conf.authorizer,false);
  if (conf.role_manager != null)   roleManager=FBUtilities.newRoleManager(conf.role_manager);
  if (authenticator instanceof PasswordAuthenticator && !(roleManager instanceof CassandraRoleManager))   throw new ConfigurationException("CassandraRoleManager must be used with PasswordAuthenticator",false);
  if (conf.internode_authenticator != null)   internodeAuthenticator=FBUtilities.construct(conf.internode_authenticator,"internode_authenticator");
 else   internodeAuthenticator=new AllowAllInternodeAuthenticator();
  authenticator.validateConfiguration();
  authorizer.validateConfiguration();
  roleManager.validateConfiguration();
  internodeAuthenticator.validateConfiguration();
  if (conf.partitioner == null) {
    throw new ConfigurationException("Missing directive: partitioner",false);
  }
  try {
    partitioner=FBUtilities.newPartitioner(System.getProperty("cassandra.partitioner",conf.partitioner));
  }
 catch (  Exception e) {
    throw new ConfigurationException("Invalid partitioner class " + conf.partitioner,false);
  }
  paritionerName=partitioner.getClass().getCanonicalName();
  if (conf.max_hint_window_in_ms == null) {
    throw new ConfigurationException("max_hint_window_in_ms cannot be set to null",false);
  }
  if (conf.phi_convict_threshold < 5 || conf.phi_convict_threshold > 16) {
    throw new ConfigurationException("phi_convict_threshold must be between 5 and 16",false);
  }
  if (conf.concurrent_reads != null && conf.concurrent_reads < 2) {
    throw new ConfigurationException("concurrent_reads must be at least 2",false);
  }
  if (conf.concurrent_writes != null && conf.concurrent_writes < 2) {
    throw new ConfigurationException("concurrent_writes must be at least 2",false);
  }
  if (conf.concurrent_counter_writes != null && conf.concurrent_counter_writes < 2)   throw new ConfigurationException("concurrent_counter_writes must be at least 2",false);
  if (conf.concurrent_replicates != null)   logger.warn("concurrent_replicates has been deprecated and should be removed from cassandra.yaml");
  if (conf.file_cache_size_in_mb == null)   conf.file_cache_size_in_mb=Math.min(512,(int)(Runtime.getRuntime().maxMemory() / (4 * 1048576)));
  if (conf.memtable_offheap_space_in_mb == null)   conf.memtable_offheap_space_in_mb=(int)(Runtime.getRuntime().maxMemory() / (4 * 1048576));
  if (conf.memtable_offheap_space_in_mb < 0)   throw new ConfigurationException("memtable_offheap_space_in_mb must be positive",false);
  if (conf.memtable_heap_space_in_mb == null)   conf.memtable_heap_space_in_mb=(int)(Runtime.getRuntime().maxMemory() / (4 * 1048576));
  if (conf.memtable_heap_space_in_mb <= 0)   throw new ConfigurationException("memtable_heap_space_in_mb must be positive",false);
  logger.info("Global memtable on-heap threshold is enabled at {}MB",conf.memtable_heap_space_in_mb);
  if (conf.memtable_offheap_space_in_mb == 0)   logger.info("Global memtable off-heap threshold is disabled, HeapAllocator will be used instead");
 else   logger.info("Global memtable off-heap threshold is enabled at {}MB",conf.memtable_offheap_space_in_mb);
  if (conf.listen_address != null && conf.listen_interface != null) {
    throw new ConfigurationException("Set listen_address OR listen_interface, not both",false);
  }
 else   if (conf.listen_address != null) {
    try {
      listenAddress=InetAddress.getByName(conf.listen_address);
    }
 catch (    UnknownHostException e) {
      throw new ConfigurationException("Unknown listen_address '" + conf.listen_address + "'",false);
    }
    if (listenAddress.isAnyLocalAddress())     throw new ConfigurationException("listen_address cannot be a wildcard address (" + conf.listen_address + ")!",false);
  }
 else   if (conf.listen_interface != null) {
    listenAddress=getNetworkInterfaceAddress(conf.listen_interface,"listen_interface");
  }
  if (conf.broadcast_address != null) {
    try {
      broadcastAddress=InetAddress.getByName(conf.broadcast_address);
    }
 catch (    UnknownHostException e) {
      throw new ConfigurationException("Unknown broadcast_address '" + conf.broadcast_address + "'",false);
    }
    if (broadcastAddress.isAnyLocalAddress())     throw new ConfigurationException("broadcast_address cannot be a wildcard address (" + conf.broadcast_address + ")!",false);
  }
  if (conf.rpc_address != null && conf.rpc_interface != null) {
    throw new ConfigurationException("Set rpc_address OR rpc_interface, not both",false);
  }
 else   if (conf.rpc_address != null) {
    try {
      rpcAddress=InetAddress.getByName(conf.rpc_address);
    }
 catch (    UnknownHostException e) {
      throw new ConfigurationException("Unknown host in rpc_address " + conf.rpc_address,false);
    }
  }
 else   if (conf.rpc_interface != null) {
    rpcAddress=getNetworkInterfaceAddress(conf.rpc_interface,"rpc_interface");
  }
 else {
    rpcAddress=FBUtilities.getLocalAddress();
  }
  if (conf.broadcast_rpc_address != null) {
    try {
      broadcastRpcAddress=InetAddress.getByName(conf.broadcast_rpc_address);
    }
 catch (    UnknownHostException e) {
      throw new ConfigurationException("Unknown broadcast_rpc_address '" + conf.broadcast_rpc_address + "'",false);
    }
    if (broadcastRpcAddress.isAnyLocalAddress())     throw new ConfigurationException("broadcast_rpc_address cannot be a wildcard address (" + conf.broadcast_rpc_address + ")!",false);
  }
 else {
    if (rpcAddress.isAnyLocalAddress())     throw new ConfigurationException("If rpc_address is set to a wildcard address (" + conf.rpc_address + "), then "+ "you must set broadcast_rpc_address to a value other than "+ conf.rpc_address,false);
    broadcastRpcAddress=rpcAddress;
  }
  if (conf.thrift_framed_transport_size_in_mb <= 0)   throw new ConfigurationException("thrift_framed_transport_size_in_mb must be positive",false);
  if (conf.native_transport_max_frame_size_in_mb <= 0)   throw new ConfigurationException("native_transport_max_frame_size_in_mb must be positive",false);
  if (ThriftServer.HSHA.equals(conf.rpc_server_type) && conf.rpc_max_threads == Integer.MAX_VALUE)   throw new ConfigurationException("The hsha rpc_server_type is not compatible with an rpc_max_threads " + "setting of 'unlimited'.  Please see the comments in cassandra.yaml " + "for rpc_server_type and rpc_max_threads.",false);
  if (conf.endpoint_snitch == null) {
    throw new ConfigurationException("Missing endpoint_snitch directive",false);
  }
  snitch=createEndpointSnitch(conf.endpoint_snitch);
  EndpointSnitchInfo.create();
  localDC=snitch.getDatacenter(FBUtilities.getBroadcastAddress());
  localComparator=new Comparator<InetAddress>(){
    public int compare(    InetAddress endpoint1,    InetAddress endpoint2){
      boolean local1=localDC.equals(snitch.getDatacenter(endpoint1));
      boolean local2=localDC.equals(snitch.getDatacenter(endpoint2));
      if (local1 && !local2)       return -1;
      if (local2 && !local1)       return 1;
      return 0;
    }
  }
;
  requestSchedulerOptions=conf.request_scheduler_options;
  if (conf.request_scheduler != null) {
    try {
      if (requestSchedulerOptions == null) {
        requestSchedulerOptions=new RequestSchedulerOptions();
      }
      Class<?> cls=Class.forName(conf.request_scheduler);
      requestScheduler=(IRequestScheduler)cls.getConstructor(RequestSchedulerOptions.class).newInstance(requestSchedulerOptions);
    }
 catch (    ClassNotFoundException e) {
      throw new ConfigurationException("Invalid Request Scheduler class " + conf.request_scheduler,false);
    }
catch (    Exception e) {
      throw new ConfigurationException("Unable to instantiate request scheduler",e);
    }
  }
 else {
    requestScheduler=new NoScheduler();
  }
  if (conf.request_scheduler_id == RequestSchedulerId.keyspace) {
    requestSchedulerId=conf.request_scheduler_id;
  }
 else {
    requestSchedulerId=RequestSchedulerId.keyspace;
  }
  if (conf.commitlog_directory == null) {
    conf.commitlog_directory=System.getProperty("cassandra.storagedir",null);
    if (conf.commitlog_directory == null)     throw new ConfigurationException("commitlog_directory is missing and -Dcassandra.storagedir is not set",false);
    conf.commitlog_directory+=File.separator + "commitlog";
  }
  if (conf.saved_caches_directory == null) {
    conf.saved_caches_directory=System.getProperty("cassandra.storagedir",null);
    if (conf.saved_caches_directory == null)     throw new ConfigurationException("saved_caches_directory is missing and -Dcassandra.storagedir is not set",false);
    conf.saved_caches_directory+=File.separator + "saved_caches";
  }
  if (conf.data_file_directories == null) {
    String defaultDataDir=System.getProperty("cassandra.storagedir",null);
    if (defaultDataDir == null)     throw new ConfigurationException("data_file_directories is not missing and -Dcassandra.storagedir is not set",false);
    conf.data_file_directories=new String[]{defaultDataDir + File.separator + "data"};
  }
  for (  String datadir : conf.data_file_directories) {
    if (datadir.equals(conf.commitlog_directory))     throw new ConfigurationException("commitlog_directory must not be the same as any data_file_directories",false);
    if (datadir.equals(conf.saved_caches_directory))     throw new ConfigurationException("saved_caches_directory must not be the same as any data_file_directories",false);
  }
  if (conf.commitlog_directory.equals(conf.saved_caches_directory))   throw new ConfigurationException("saved_caches_directory must not be the same as the commitlog_directory",false);
  if (conf.memtable_flush_writers == null)   conf.memtable_flush_writers=Math.min(8,Math.max(2,Math.min(FBUtilities.getAvailableProcessors(),conf.data_file_directories.length)));
  if (conf.memtable_flush_writers < 1)   throw new ConfigurationException("memtable_flush_writers must be at least 1",false);
  if (conf.memtable_cleanup_threshold == null)   conf.memtable_cleanup_threshold=(float)(1.0 / (1 + conf.memtable_flush_writers));
  if (conf.memtable_cleanup_threshold < 0.01f)   throw new ConfigurationException("memtable_cleanup_threshold must be >= 0.01",false);
  if (conf.memtable_cleanup_threshold > 0.99f)   throw new ConfigurationException("memtable_cleanup_threshold must be <= 0.99",false);
  if (conf.memtable_cleanup_threshold < 0.1f)   logger.warn("memtable_cleanup_threshold is set very low, which may cause performance degradation");
  if (conf.concurrent_compactors == null)   conf.concurrent_compactors=Math.min(8,Math.max(2,Math.min(FBUtilities.getAvailableProcessors(),conf.data_file_directories.length)));
  if (conf.concurrent_compactors <= 0)   throw new ConfigurationException("concurrent_compactors should be strictly greater than 0",false);
  if (conf.initial_token != null)   for (  String token : tokensFromString(conf.initial_token))   partitioner.getTokenFactory().validate(token);
  if (conf.num_tokens == null)   conf.num_tokens=1;
 else   if (conf.num_tokens > MAX_NUM_TOKENS)   throw new ConfigurationException(String.format("A maximum number of %d tokens per node is supported",MAX_NUM_TOKENS),false);
  try {
    keyCacheSizeInMB=(conf.key_cache_size_in_mb == null) ? Math.min(Math.max(1,(int)(Runtime.getRuntime().totalMemory() * 0.05 / 1024 / 1024)),100) : conf.key_cache_size_in_mb;
    if (keyCacheSizeInMB < 0)     throw new NumberFormatException();
  }
 catch (  NumberFormatException e) {
    throw new ConfigurationException("key_cache_size_in_mb option was set incorrectly to '" + conf.key_cache_size_in_mb + "', supported values are <integer> >= 0.",false);
  }
  try {
    counterCacheSizeInMB=(conf.counter_cache_size_in_mb == null) ? Math.min(Math.max(1,(int)(Runtime.getRuntime().totalMemory() * 0.025 / 1024 / 1024)),50) : conf.counter_cache_size_in_mb;
    if (counterCacheSizeInMB < 0)     throw new NumberFormatException();
  }
 catch (  NumberFormatException e) {
    throw new ConfigurationException("counter_cache_size_in_mb option was set incorrectly to '" + conf.counter_cache_size_in_mb + "', supported values are <integer> >= 0.",false);
  }
  indexSummaryCapacityInMB=(conf.index_summary_capacity_in_mb == null) ? Math.max(1,(int)(Runtime.getRuntime().totalMemory() * 0.05 / 1024 / 1024)) : conf.index_summary_capacity_in_mb;
  if (indexSummaryCapacityInMB < 0)   throw new ConfigurationException("index_summary_capacity_in_mb option was set incorrectly to '" + conf.index_summary_capacity_in_mb + "', it should be a non-negative integer.",false);
  memoryAllocator=FBUtilities.newOffHeapAllocator(conf.memory_allocator);
  if (conf.encryption_options != null) {
    logger.warn("Please rename encryption_options as server_encryption_options in the yaml");
    conf.server_encryption_options=conf.encryption_options;
  }
  if (conf.seed_provider == null) {
    throw new ConfigurationException("seeds configuration is missing; a minimum of one seed is required.",false);
  }
  try {
    Class<?> seedProviderClass=Class.forName(conf.seed_provider.class_name);
    seedProvider=(SeedProvider)seedProviderClass.getConstructor(Map.class).newInstance(conf.seed_provider.parameters);
  }
 catch (  Exception e) {
    throw new ConfigurationException(e.getMessage() + "\nFatal configuration error; unable to start server.  See log for stacktrace.",false);
  }
  if (seedProvider.getSeeds().size() == 0)   throw new ConfigurationException("The seed provider lists no seeds.",false);
  if (conf.batch_size_fail_threshold_in_kb == null) {
    conf.batch_size_fail_threshold_in_kb=conf.batch_size_warn_threshold_in_kb * 10;
  }
}
