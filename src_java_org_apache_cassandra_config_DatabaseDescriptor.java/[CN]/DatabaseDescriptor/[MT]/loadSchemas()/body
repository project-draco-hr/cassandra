{
  UUID uuid=Migration.getLastMigrationId();
  if (uuid == null) {
    logger.info("Couldn't detect any schema definitions in local storage.");
    boolean hasExistingTables=false;
    for (    String dataDir : DatabaseDescriptor.getAllDataFileLocations()) {
      File dataPath=new File(dataDir);
      if (dataPath.exists() && dataPath.isDirectory()) {
        int dirCount=dataPath.listFiles(new FileFilter(){
          public boolean accept(          File pathname){
            return pathname.isDirectory();
          }
        }
).length;
        if (dirCount > 0)         hasExistingTables=true;
      }
      if (hasExistingTables) {
        break;
      }
    }
    if (hasExistingTables)     logger.info("Found table data in data directories. Consider using the CLI to define your schema.");
 else     logger.info("To create keyspaces and column families, see 'help create keyspace' in the CLI, or set up a schema using the thrift system_* calls.");
  }
 else {
    logger.info("Loading schema version " + uuid.toString());
    Collection<KSMetaData> tableDefs=DefsTable.loadFromStorage(uuid);
    for (    KSMetaData def : tableDefs) {
      if (!def.name.matches(Migration.NAME_VALIDATOR_REGEX))       throw new RuntimeException("invalid keyspace name: " + def.name);
      for (      CFMetaData cfm : def.cfMetaData().values()) {
        if (!cfm.cfName.matches(Migration.NAME_VALIDATOR_REGEX))         throw new RuntimeException("invalid column family name: " + cfm.cfName);
        try {
          CFMetaData.map(cfm);
        }
 catch (        ConfigurationException ex) {
          throw new IOError(ex);
        }
      }
      DatabaseDescriptor.setTableDefinition(def,uuid);
    }
    if (tableDefs.size() == 0) {
      logger.warn("No schema definitions were found in local storage.");
      defsVersion=uuid;
    }
  }
  CFMetaData.fixMaxId();
}
