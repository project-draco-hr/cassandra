{
  UUID uuid=Migration.getLastMigrationId();
  if (uuid == null) {
    logger.info("Couldn't detect any schema definitions in local storage.");
    boolean hasExistingTables=false;
    for (    String dataDir : DatabaseDescriptor.getAllDataFileLocations()) {
      File dataPath=new File(dataDir);
      if (dataPath.exists() && dataPath.isDirectory()) {
        int dirCount=dataPath.listFiles(new FileFilter(){
          @Override public boolean accept(          File pathname){
            return pathname.isDirectory();
          }
        }
).length;
        if (dirCount > 0)         hasExistingTables=true;
      }
      if (hasExistingTables) {
        break;
      }
    }
    if (hasExistingTables)     logger.info("Found table data in data directories. Consider using JMX to call org.apache.cassandra.service.StorageService.loadSchemaFromYaml().");
 else     logger.info("Consider using JMX to org.apache.cassandra.service.StorageService.loadSchemaFromYaml() or set up a schema using the system_* calls provided via thrift.");
  }
 else {
    logger.info("Loading schema version " + uuid.toString());
    Collection<KSMetaData> tableDefs=DefsTable.loadFromStorage(uuid);
    for (    KSMetaData def : tableDefs) {
      for (      CFMetaData cfm : def.cfMetaData().values()) {
        try {
          CFMetaData.map(cfm);
        }
 catch (        ConfigurationException ex) {
          throw new IOError(ex);
        }
      }
      DatabaseDescriptor.setTableDefinition(def,uuid);
      Table.open(def.name);
    }
    if (conf.keyspaces != null && conf.keyspaces.size() > 0)     logger.warn("Schema definitions were defined both locally and in " + STORAGE_CONF_FILE + ". Definitions in "+ STORAGE_CONF_FILE+ " were ignored.");
  }
  CFMetaData.fixMaxId();
}
