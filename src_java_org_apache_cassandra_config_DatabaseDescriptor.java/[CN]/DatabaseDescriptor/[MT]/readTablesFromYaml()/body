{
  List<KSMetaData> defs=new ArrayList<KSMetaData>();
  for (  RawKeyspace keyspace : conf.keyspaces) {
    if (keyspace.name == null) {
      throw new ConfigurationException("Keyspace name attribute is required");
    }
    if (keyspace.name.equalsIgnoreCase(Table.SYSTEM_TABLE)) {
      throw new ConfigurationException("'system' is a reserved table name for Cassandra internals");
    }
    if (keyspace.replica_placement_strategy == null) {
      throw new ConfigurationException("Missing replica_placement_strategy directive for " + keyspace.name);
    }
    Class<? extends AbstractReplicationStrategy> strategyClass=null;
    try {
      strategyClass=(Class<? extends AbstractReplicationStrategy>)Class.forName(keyspace.replica_placement_strategy);
    }
 catch (    ClassNotFoundException e) {
      throw new ConfigurationException("Invalid replicaplacementstrategy class " + keyspace.replica_placement_strategy);
    }
    if (keyspace.replication_factor == null) {
      throw new ConfigurationException("Missing replication_factor directory for keyspace " + keyspace.name);
    }
    int size2=keyspace.column_families.length;
    CFMetaData[] cfDefs=new CFMetaData[size2];
    int j=0;
    for (    RawColumnFamily cf : keyspace.column_families) {
      if (cf.name == null) {
        throw new ConfigurationException("ColumnFamily name attribute is required");
      }
      if (!cf.name.matches("\\w+")) {
        throw new ConfigurationException("ColumnFamily name contains invalid characters.");
      }
      AbstractType comparator=getComparator(cf.compare_with);
      AbstractType subcolumnComparator=null;
      ColumnFamilyType cfType=cf.column_type == null ? ColumnFamilyType.Standard : cf.column_type;
      if (cfType == ColumnFamilyType.Super) {
        subcolumnComparator=getComparator(cf.compare_subcolumns_with);
      }
 else       if (cf.compare_subcolumns_with != null) {
        throw new ConfigurationException("compare_subcolumns_with is only a valid attribute on super columnfamilies (not regular columnfamily " + cf.name + ")");
      }
      if (cf.clock_type == null)       cf.clock_type=ClockType.Timestamp;
      AbstractReconciler reconciler=getReconciler(cf.reconciler);
      if (reconciler == null) {
        if (cf.clock_type == ClockType.Timestamp)         reconciler=new TimestampReconciler();
 else         throw new ConfigurationException("No reconciler specified for column family " + cf.name);
      }
      if (cf.read_repair_chance < 0.0 || cf.read_repair_chance > 1.0) {
        throw new ConfigurationException("read_repair_chance must be between 0.0 and 1.0");
      }
      Map<byte[],ColumnDefinition> metadata=new TreeMap<byte[],ColumnDefinition>(FBUtilities.byteArrayComparator);
      for (      RawColumnDefinition rcd : cf.column_metadata) {
        try {
          byte[] columnName=rcd.name.getBytes("UTF-8");
          metadata.put(columnName,new ColumnDefinition(columnName,rcd.validator_class,rcd.index_type,rcd.index_name));
        }
 catch (        UnsupportedEncodingException e) {
          throw new AssertionError(e);
        }
      }
      cfDefs[j++]=new CFMetaData(keyspace.name,cf.name,cfType,cf.clock_type,comparator,subcolumnComparator,reconciler,cf.comment,cf.rows_cached,cf.preload_row_cache,cf.keys_cached,cf.read_repair_chance,cf.gc_grace_seconds,metadata);
    }
    defs.add(new KSMetaData(keyspace.name,strategyClass,keyspace.strategy_options,keyspace.replication_factor,cfDefs));
  }
  return defs;
}
