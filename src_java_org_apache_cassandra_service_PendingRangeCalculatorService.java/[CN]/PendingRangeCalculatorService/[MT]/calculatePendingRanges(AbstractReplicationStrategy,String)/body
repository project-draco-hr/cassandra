{
  TokenMetadata tm=StorageService.instance.getTokenMetadata();
  Multimap<Range<Token>,InetAddress> pendingRanges=HashMultimap.create();
  BiMultiValMap<Token,InetAddress> bootstrapTokens=tm.getBootstrapTokens();
  Set<InetAddress> leavingEndpoints=tm.getLeavingEndpoints();
  if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty()) {
    if (logger.isDebugEnabled())     logger.debug("No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}",keyspaceName);
    tm.setPendingRanges(keyspaceName,pendingRanges);
    return;
  }
  Multimap<InetAddress,Range<Token>> addressRanges=strategy.getAddressRanges();
  TokenMetadata allLeftMetadata=tm.cloneAfterAllLeft();
  Set<Range<Token>> affectedRanges=new HashSet<Range<Token>>();
  for (  InetAddress endpoint : leavingEndpoints)   affectedRanges.addAll(addressRanges.get(endpoint));
  TokenMetadata metadata=tm.cloneOnlyTokenMap();
  for (  Range<Token> range : affectedRanges) {
    Set<InetAddress> currentEndpoints=ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right,metadata));
    Set<InetAddress> newEndpoints=ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right,allLeftMetadata));
    pendingRanges.putAll(range,Sets.difference(newEndpoints,currentEndpoints));
  }
  Multimap<InetAddress,Token> bootstrapAddresses=bootstrapTokens.inverse();
  for (  InetAddress endpoint : bootstrapAddresses.keySet()) {
    Collection<Token> tokens=bootstrapAddresses.get(endpoint);
    allLeftMetadata.updateNormalTokens(tokens,endpoint);
    for (    Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))     pendingRanges.put(range,endpoint);
    allLeftMetadata.removeEndpoint(endpoint);
  }
  for (  Pair<Token,InetAddress> moving : tm.getMovingEndpoints()) {
    Set<Range<Token>> moveAffectedRanges=new HashSet<>();
    InetAddress endpoint=moving.right;
    for (    Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) {
      moveAffectedRanges.add(range);
    }
    allLeftMetadata.updateNormalToken(moving.left,endpoint);
    for (    Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) {
      moveAffectedRanges.add(range);
    }
    for (    Range<Token> range : moveAffectedRanges) {
      Set<InetAddress> currentEndpoints=ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right,metadata));
      Set<InetAddress> newEndpoints=ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right,allLeftMetadata));
      Set<InetAddress> difference=Sets.difference(newEndpoints,currentEndpoints);
      for (      final InetAddress address : difference) {
        Collection<Range<Token>> newRanges=strategy.getAddressRanges(allLeftMetadata).get(address);
        Collection<Range<Token>> oldRanges=strategy.getAddressRanges(metadata).get(address);
        newRanges.removeAll(oldRanges);
        for (        Range<Token> newRange : newRanges) {
          for (          Range<Token> pendingRange : newRange.subtractAll(oldRanges)) {
            pendingRanges.put(pendingRange,address);
          }
        }
      }
    }
    allLeftMetadata.removeEndpoint(endpoint);
  }
  tm.setPendingRanges(keyspaceName,pendingRanges);
  if (logger.isDebugEnabled())   logger.debug("Pending ranges:\n" + (pendingRanges.isEmpty() ? "<empty>" : tm.printPendingRanges()));
}
