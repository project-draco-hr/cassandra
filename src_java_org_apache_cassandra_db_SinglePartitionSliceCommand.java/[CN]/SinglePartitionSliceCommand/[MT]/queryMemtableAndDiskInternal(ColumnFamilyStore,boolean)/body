{
  Tracing.trace("Acquiring sstable references");
  ColumnFamilyStore.ViewFragment view=cfs.select(View.select(SSTableSet.LIVE,partitionKey()));
  List<UnfilteredRowIterator> iterators=new ArrayList<>(Iterables.size(view.memtables) + view.sstables.size());
  ClusteringIndexSliceFilter filter=clusteringIndexFilter();
  try {
    for (    Memtable memtable : view.memtables) {
      Partition partition=memtable.getPartition(partitionKey());
      if (partition == null)       continue;
      UnfilteredRowIterator iter=filter.getUnfilteredRowIterator(columnFilter(),partition);
      UnfilteredRowIterator maybeCopied=copyOnHeap ? UnfilteredRowIterators.cloningIterator(iter,HeapAllocator.instance) : iter;
      oldestUnrepairedTombstone=Math.min(oldestUnrepairedTombstone,partition.stats().minLocalDeletionTime);
      iterators.add(isForThrift() ? ThriftResultsMerger.maybeWrap(maybeCopied,nowInSec()) : maybeCopied);
    }
    int sstablesIterated=0;
    Collections.sort(view.sstables,SSTableReader.maxTimestampComparator);
    List<SSTableReader> skippedSSTables=null;
    long mostRecentPartitionTombstone=Long.MIN_VALUE;
    long minTimestamp=Long.MAX_VALUE;
    int nonIntersectingSSTables=0;
    for (    SSTableReader sstable : view.sstables) {
      minTimestamp=Math.min(minTimestamp,sstable.getMinTimestamp());
      if (sstable.getMaxTimestamp() < mostRecentPartitionTombstone)       break;
      if (!filter.shouldInclude(sstable)) {
        nonIntersectingSSTables++;
        if (sstable.getSSTableMetadata().maxLocalDeletionTime != Integer.MAX_VALUE) {
          if (skippedSSTables == null)           skippedSSTables=new ArrayList<>();
          skippedSSTables.add(sstable);
        }
        continue;
      }
      sstable.incrementReadCount();
      UnfilteredRowIterator iter=filter.filter(sstable.iterator(partitionKey(),columnFilter(),filter.isReversed(),isForThrift()));
      if (!sstable.isRepaired())       oldestUnrepairedTombstone=Math.min(oldestUnrepairedTombstone,sstable.getMinLocalDeletionTime());
      iterators.add(isForThrift() ? ThriftResultsMerger.maybeWrap(iter,nowInSec()) : iter);
      mostRecentPartitionTombstone=Math.max(mostRecentPartitionTombstone,iter.partitionLevelDeletion().markedForDeleteAt());
      sstablesIterated++;
    }
    int includedDueToTombstones=0;
    if (skippedSSTables != null) {
      for (      SSTableReader sstable : skippedSSTables) {
        if (sstable.getMaxTimestamp() <= minTimestamp)         continue;
        sstable.incrementReadCount();
        UnfilteredRowIterator iter=filter.filter(sstable.iterator(partitionKey(),columnFilter(),filter.isReversed(),isForThrift()));
        if (iter.partitionLevelDeletion().markedForDeleteAt() > minTimestamp) {
          iterators.add(iter);
          if (!sstable.isRepaired())           oldestUnrepairedTombstone=Math.min(oldestUnrepairedTombstone,sstable.getMinLocalDeletionTime());
          includedDueToTombstones++;
          sstablesIterated++;
        }
 else {
          iter.close();
        }
      }
    }
    if (Tracing.isTracing())     Tracing.trace("Skipped {}/{} non-slice-intersecting sstables, included {} due to tombstones",nonIntersectingSSTables,view.sstables.size(),includedDueToTombstones);
    cfs.metric.updateSSTableIterated(sstablesIterated);
    if (iterators.isEmpty())     return UnfilteredRowIterators.emptyIterator(cfs.metadata,partitionKey(),filter.isReversed());
    Tracing.trace("Merging data from memtables and {} sstables",sstablesIterated);
    UnfilteredRowIterator merged=UnfilteredRowIterators.merge(iterators,nowInSec());
    if (!merged.isEmpty()) {
      DecoratedKey key=merged.partitionKey();
      cfs.metric.samplers.get(TableMetrics.Sampler.READS).addSample(key.getKey(),key.hashCode(),1);
    }
    return withStateTracking(merged);
  }
 catch (  RuntimeException|Error e) {
    try {
      FBUtilities.closeAll(iterators);
    }
 catch (    Exception suppressed) {
      e.addSuppressed(suppressed);
    }
    throw e;
  }
}
