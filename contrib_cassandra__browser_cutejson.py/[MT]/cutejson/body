def cutejson(v, nest=0, metanest=0):
    t = type(v).__name__
    comment = ''
    prefix = ''
    postfix = ''
    s = ''
    if ((t == 'unicode') or (t == 'str')):
        try:
            v = json.loads(v)
            comment = '&nbsp;&nbsp;## Parsed contents'
            metanest += 1
            prefix = ('<span class="interpreted metanest%d">' % metanest)
            postfix = '</span>'
        except ValueError:
            comment = ''
    t = type(v).__name__
    if (t == 'dict'):
        s = ('%s{%s<br/>\n' % (prefix, comment))
        for (key, val) in v.iteritems():
            s += ('%s<span class="key">%s</span>: %s<br/>\n' % (_rep('&nbsp;', ((nest + 1) * 3)), key, cutejson(val, (nest + 1), metanest)))
        s += ('%s}%s' % (_rep('&nbsp;', (nest * 3)), postfix))
    elif (t == 'list'):
        s = '[<br/>\n'
        sep = '&nbsp;'
        for val in v:
            spc = ((_rep('&nbsp;', (nest * 3)) + sep) + _rep('&nbsp;', 2))
            s += ('%s%s<br/>\n' % (spc, cutejson(val, (nest + 1), metanest)))
            sep = ','
        s += ('%s]' % _rep('&nbsp;', (nest * 3)))
    else:
        if ((t == 'str') or (t == 'unicode')):
            prefix = postfix = '"'
        elif ((t == 'int') and (v > 900000000) and (v < 1300000000)):
            postfix = ('&nbsp;&nbsp;<span class="interpreted metanest%d">## Seconds: %s</span>' % ((metanest + 1), str(datetime.fromtimestamp(v))))
        elif ((t == 'long') and (v > 900000000000) and (v < 1300000000000)):
            postfix = ('&nbsp;&nbsp;<span class="interpreted metanest%d">## Millis: %s</span>' % ((metanest + 1), str(datetime.fromtimestamp((v / 1000)))))
        s = ('%s<span class="%s">%s%s%s</span>' % (comment, t, prefix, str(v), postfix))
    return s
