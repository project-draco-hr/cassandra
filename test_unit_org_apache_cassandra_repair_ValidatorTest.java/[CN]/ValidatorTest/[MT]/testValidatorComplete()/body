{
  Range<Token> range=new Range<>(partitioner.getMinimumToken(),partitioner.getRandomToken());
  final RepairJobDesc desc=new RepairJobDesc(UUID.randomUUID(),UUID.randomUUID(),keyspace,columnFamily,range);
  final SimpleCondition lock=new SimpleCondition();
  MessagingService.instance().addMessageSink(new IMessageSink(){
    @SuppressWarnings("unchecked") public boolean allowOutgoingMessage(    MessageOut message,    int id,    InetAddress to){
      try {
        if (message.verb == MessagingService.Verb.REPAIR_MESSAGE) {
          RepairMessage m=(RepairMessage)message.payload;
          assertEquals(RepairMessage.Type.VALIDATION_COMPLETE,m.messageType);
          assertEquals(desc,m.desc);
          assertTrue(((ValidationComplete)m).success);
          assertNotNull(((ValidationComplete)m).tree);
        }
      }
  finally {
        lock.signalAll();
      }
      return false;
    }
    public boolean allowIncomingMessage(    MessageIn message,    int id){
      return false;
    }
  }
);
  InetAddress remote=InetAddress.getByName("127.0.0.2");
  ColumnFamilyStore cfs=Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);
  Validator validator=new Validator(desc,remote,0);
  MerkleTree tree=new MerkleTree(cfs.partitioner,validator.desc.range,MerkleTree.RECOMMENDED_DEPTH,(int)Math.pow(2,15));
  validator.prepare(cfs,tree);
  assertTrue(tree.size() > 1);
  Token mid=partitioner.midpoint(range.left,range.right);
  validator.add(new CompactedRowStub(new BufferDecoratedKey(mid,ByteBufferUtil.bytes("inconceivable!"))));
  validator.complete();
  Token min=tree.partitioner().getMinimumToken();
  assertNotNull(tree.hash(new Range<>(min,min)));
  if (!lock.isSignaled())   lock.await();
}
