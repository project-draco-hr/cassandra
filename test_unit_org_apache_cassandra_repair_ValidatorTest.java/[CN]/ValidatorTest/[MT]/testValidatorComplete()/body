{
  Range<Token> range=new Range<>(partitioner.getMinimumToken(),partitioner.getRandomToken());
  final RepairJobDesc desc=new RepairJobDesc(UUID.randomUUID(),keyspace,columnFamily,range);
  final SimpleCondition lock=new SimpleCondition();
  SinkManager.add(new IMessageSink(){
    @SuppressWarnings("unchecked") public MessageOut handleMessage(    MessageOut message,    int id,    InetAddress to){
      try {
        if (message.verb == MessagingService.Verb.REPAIR_MESSAGE) {
          RepairMessage m=(RepairMessage)message.payload;
          assertEquals(RepairMessage.Type.VALIDATION_COMPLETE,m.messageType);
          assertEquals(desc,m.desc);
          assertTrue(((ValidationComplete)m).success);
          assertNotNull(((ValidationComplete)m).tree);
        }
      }
  finally {
        lock.signalAll();
      }
      return null;
    }
    public MessageIn handleMessage(    MessageIn message,    int id,    InetAddress to){
      return null;
    }
  }
);
  InetAddress remote=InetAddress.getByName("127.0.0.2");
  ColumnFamilyStore cfs=Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);
  Validator validator=new Validator(desc,remote,0);
  validator.prepare(cfs);
  assertTrue(validator.tree.size() > 1);
  Token mid=partitioner.midpoint(range.left,range.right);
  validator.add(new PrecompactedRow(new DecoratedKey(mid,ByteBufferUtil.bytes("inconceivable!")),TreeMapBackedSortedColumns.factory.create(cfs.metadata)));
  validator.complete();
  Token min=validator.tree.partitioner().getMinimumToken();
  assertNotNull(validator.tree.hash(new Range<>(min,min)));
  if (!lock.isSignaled())   lock.await();
}
