{
  Range<Token> range=new Range<>(partitioner.getMinimumToken(),partitioner.getRandomToken());
  final RepairJobDesc desc=new RepairJobDesc(UUID.randomUUID(),UUID.randomUUID(),keyspace,columnFamily,range);
  final ListenableFuture<MessageOut> outgoingMessageSink=registerOutgoingMessageSink();
  InetAddress remote=InetAddress.getByName("127.0.0.2");
  ColumnFamilyStore cfs=Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);
  Validator validator=new Validator(desc,remote,0);
  MerkleTree tree=new MerkleTree(cfs.partitioner,validator.desc.range,MerkleTree.RECOMMENDED_DEPTH,(int)Math.pow(2,15));
  validator.prepare(cfs,tree);
  assertTrue(tree.size() > 1);
  Token mid=partitioner.midpoint(range.left,range.right);
  validator.add(new CompactedRowStub(new BufferDecoratedKey(mid,ByteBufferUtil.bytes("inconceivable!"))));
  validator.complete();
  Token min=tree.partitioner().getMinimumToken();
  assertNotNull(tree.hash(new Range<>(min,min)));
  MessageOut message=outgoingMessageSink.get(TEST_TIMEOUT,TimeUnit.SECONDS);
  assertEquals(MessagingService.Verb.REPAIR_MESSAGE,message.verb);
  RepairMessage m=(RepairMessage)message.payload;
  assertEquals(RepairMessage.Type.VALIDATION_COMPLETE,m.messageType);
  assertEquals(desc,m.desc);
  assertTrue(((ValidationComplete)m).success);
  assertNotNull(((ValidationComplete)m).tree);
}
