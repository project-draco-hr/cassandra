{
  List<UDFunction> created=new ArrayList<>();
  List<UDFunction> altered=new ArrayList<>();
  List<UDFunction> dropped=new ArrayList<>();
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(before,after);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet())   if (entry.getValue().hasColumns())   created.addAll(createFunctionsFromFunctionsPartition(new Row(entry.getKey(),entry.getValue())).values());
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> entry : diff.entriesDiffering().entrySet()) {
    ColumnFamily pre=entry.getValue().leftValue();
    ColumnFamily post=entry.getValue().rightValue();
    if (pre.hasColumns() && post.hasColumns()) {
      MapDifference<ByteBuffer,UDFunction> delta=Maps.difference(createFunctionsFromFunctionsPartition(new Row(entry.getKey(),pre)),createFunctionsFromFunctionsPartition(new Row(entry.getKey(),post)));
      dropped.addAll(delta.entriesOnlyOnLeft().values());
      created.addAll(delta.entriesOnlyOnRight().values());
      Iterables.addAll(altered,Iterables.transform(delta.entriesDiffering().values(),new Function<MapDifference.ValueDifference<UDFunction>,UDFunction>(){
        public UDFunction apply(        MapDifference.ValueDifference<UDFunction> pair){
          return pair.rightValue();
        }
      }
));
    }
 else     if (pre.hasColumns()) {
      dropped.addAll(createFunctionsFromFunctionsPartition(new Row(entry.getKey(),pre)).values());
    }
 else     if (post.hasColumns()) {
      created.addAll(createFunctionsFromFunctionsPartition(new Row(entry.getKey(),post)).values());
    }
  }
  for (  UDFunction udf : created)   Schema.instance.addFunction(udf);
  for (  UDFunction udf : altered)   Schema.instance.updateFunction(udf);
  for (  UDFunction udf : dropped)   Schema.instance.dropFunction(udf);
}
