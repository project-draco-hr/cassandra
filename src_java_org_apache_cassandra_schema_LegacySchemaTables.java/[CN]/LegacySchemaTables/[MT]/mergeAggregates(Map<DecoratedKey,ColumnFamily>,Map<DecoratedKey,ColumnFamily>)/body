{
  List<UDAggregate> created=new ArrayList<>();
  List<UDAggregate> altered=new ArrayList<>();
  List<UDAggregate> dropped=new ArrayList<>();
  MapDifference<DecoratedKey,ColumnFamily> diff=Maps.difference(before,after);
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet())   if (entry.getValue().hasColumns())   created.addAll(createAggregatesFromAggregatesPartition(new Row(entry.getKey(),entry.getValue())).values());
  for (  Map.Entry<DecoratedKey,MapDifference.ValueDifference<ColumnFamily>> entry : diff.entriesDiffering().entrySet()) {
    ColumnFamily pre=entry.getValue().leftValue();
    ColumnFamily post=entry.getValue().rightValue();
    if (pre.hasColumns() && post.hasColumns()) {
      MapDifference<ByteBuffer,UDAggregate> delta=Maps.difference(createAggregatesFromAggregatesPartition(new Row(entry.getKey(),pre)),createAggregatesFromAggregatesPartition(new Row(entry.getKey(),post)));
      dropped.addAll(delta.entriesOnlyOnLeft().values());
      created.addAll(delta.entriesOnlyOnRight().values());
      Iterables.addAll(altered,Iterables.transform(delta.entriesDiffering().values(),new Function<MapDifference.ValueDifference<UDAggregate>,UDAggregate>(){
        public UDAggregate apply(        MapDifference.ValueDifference<UDAggregate> pair){
          return pair.rightValue();
        }
      }
));
    }
 else     if (pre.hasColumns()) {
      dropped.addAll(createAggregatesFromAggregatesPartition(new Row(entry.getKey(),pre)).values());
    }
 else     if (post.hasColumns()) {
      created.addAll(createAggregatesFromAggregatesPartition(new Row(entry.getKey(),post)).values());
    }
  }
  for (  UDAggregate udf : created)   Schema.instance.addAggregate(udf);
  for (  UDAggregate udf : altered)   Schema.instance.updateAggregate(udf);
  for (  UDAggregate udf : dropped)   Schema.instance.dropAggregate(udf);
}
