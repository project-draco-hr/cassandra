{
  String ksName=row.getString("keyspace_name");
  String functionName=row.getString("function_name");
  FunctionName name=new FunctionName(ksName,functionName);
  List<ColumnIdentifier> argNames=new ArrayList<>();
  if (row.has("argument_names"))   for (  String arg : row.getList("argument_names",UTF8Type.instance))   argNames.add(new ColumnIdentifier(arg,true));
  List<AbstractType<?>> argTypes=new ArrayList<>();
  if (row.has("argument_types"))   for (  String type : row.getList("argument_types",UTF8Type.instance))   argTypes.add(parseType(type));
  AbstractType<?> returnType=parseType(row.getString("return_type"));
  String language=row.getString("language");
  String body=row.getString("body");
  boolean calledOnNullInput=row.getBoolean("called_on_null_input");
  org.apache.cassandra.cql3.functions.Function existing=org.apache.cassandra.cql3.functions.Functions.find(name,argTypes);
  if (existing instanceof UDFunction) {
    UDFunction udf=(UDFunction)existing;
    if (udf.argNames().equals(argNames) && udf.returnType().equals(returnType) && !udf.isAggregate()&& udf.language().equals(language)&& udf.body().equals(body)&& udf.isCalledOnNullInput() == calledOnNullInput) {
      logger.debug("Skipping duplicate compilation of already existing UDF {}",name);
      return udf;
    }
  }
  try {
    return UDFunction.create(name,argNames,argTypes,returnType,calledOnNullInput,language,body);
  }
 catch (  InvalidRequestException e) {
    logger.error(String.format("Cannot load function '%s' from schema: this function won't be available (on this node)",name),e);
    return UDFunction.createBrokenFunction(name,argNames,argTypes,returnType,calledOnNullInput,language,body,e);
  }
}
