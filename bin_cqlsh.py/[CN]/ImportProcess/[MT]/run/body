def run(self):
    new_cluster = Cluster(contact_points=(self.hostname,), port=self.port, cql_version=self.cql_version, protocol_version=DEFAULT_PROTOCOL_VERSION, auth_provider=self.auth_provider, ssl_options=(sslhandling.ssl_settings(self.hostname, CONFIG_FILE) if self.ssl else None), load_balancing_policy=WhiteListRoundRobinPolicy([self.hostname]), compression=None, connect_timeout=self.connect_timeout)
    session = new_cluster.connect(self.ks)
    conn = session._pools.values()[0]._connection
    table_meta = new_cluster.metadata.keyspaces[self.ks].tables[self.cf]
    pk_cols = [col.name for col in table_meta.primary_key]
    cqltypes = [table_meta.columns[name].typestring for name in self.columns]
    pk_indexes = [self.columns.index(col.name) for col in table_meta.primary_key]
    query = ('INSERT INTO %s.%s (%s) VALUES (%%s)' % (protect_name(table_meta.keyspace.name), protect_name(table_meta.name), ', '.join(protect_names(self.columns))))
    should_escape = [(t in ('ascii', 'text', 'timestamp', 'date', 'time', 'inet')) for t in cqltypes]
    insert_timestamp = int((time.time() * 1000000.0))

    def callback(record_num, response):
        with conn.lock:
            conn.in_flight -= 1
        if (not isinstance(response, ResultMessage)):
            self.pipe.send((record_num, str(response)))
            if (isinstance(response, Exception) and self.debug):
                traceback.print_exc(response)
    current_record = 0
    insert_num = 0
    try:
        try:
            while True:
                if (conn.in_flight > (conn.max_request_id * 0.9)):
                    conn._readable = True
                    time.sleep(0.05)
                    continue
                try:
                    (current_record, row) = self.pipe.recv()
                except EOFError:
                    sys.stdout.write('Failed to read from pipe:\n\n')
                    sys.stdout.flush()
                    conn._writable = True
                    conn._readable = True
                    break
                if ((current_record, row) == (None, None)):
                    conn._writable = True
                    conn._readable = True
                    self.pipe.close()
                    break
                for (i, value) in enumerate(row):
                    if (value != self.nullval):
                        if should_escape[i]:
                            row[i] = protect_value(value)
                    elif (i in pk_indexes):
                        message = ("Cannot insert null value for primary key column '%s'." % (pk_cols[i],))
                        if (self.nullval == ''):
                            message += ' If you want to insert empty strings, consider using the WITH NULL=<marker> option for COPY.'
                        self.pipe.send((current_record, message))
                        return
                    else:
                        row[i] = 'null'
                full_query = (query % (','.join(row),))
                query_message = QueryMessage(full_query, self.consistency_level, serial_consistency_level=None, fetch_size=None, paging_state=None, timestamp=insert_timestamp)
                request_id = conn.get_request_id()
                conn.send_msg(query_message, request_id=request_id, cb=partial(callback, current_record))
                with conn.lock:
                    conn.in_flight += 1
                if ((insert_num % 50) == 0):
                    conn._writable = True
                    conn._readable = True
                insert_num += 1
        except Exception as exc:
            self.pipe.send((current_record, str(exc)))
    finally:
        while (conn.in_flight > 0):
            conn._readable = True
            time.sleep(0.1)
        new_cluster.shutdown()
