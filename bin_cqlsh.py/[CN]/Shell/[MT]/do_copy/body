def do_copy(self, parsed):
    '\n        COPY [cqlsh only]\n\n          COPY x FROM: Imports CSV data into a Cassandra table\n          COPY x TO: Exports data from a Cassandra table in CSV format.\n\n        COPY <table_name> [ ( column [, ...] ) ]\n             FROM ( \'<file_pattern_1, file_pattern_2, ... file_pattern_n>\' | STDIN )\n             [ WITH <option>=\'value\' [AND ...] ];\n\n        File patterns are either file names or valid python glob expressions, e.g. *.csv or folder/*.csv.\n\n        COPY <table_name> [ ( column [, ...] ) ]\n             TO ( \'<filename>\' | STDOUT )\n             [ WITH <option>=\'value\' [AND ...] ];\n\n        Available common COPY options and defaults:\n\n          DELIMITER=\',\'           - character that appears between records\n          QUOTE=\'"\'               - quoting character to be used to quote fields\n          ESCAPE=\'\\\'              - character to appear before the QUOTE char when quoted\n          HEADER=false            - whether to ignore the first line\n          NULL=\'\'                 - string that represents a null value\n          DATETIMEFORMAT=         - timestamp strftime format\n            \'%Y-%m-%d %H:%M:%S%z\'   defaults to time_format value in cqlshrc\n          MAXATTEMPTS=5           - the maximum number of attempts per batch or range\n          REPORTFREQUENCY=0.25    - the frequency with which we display status updates in seconds\n          DECIMALSEP=\'.\'          - the separator for decimal values\n          THOUSANDSSEP=\'\'         - the separator for thousands digit groups\n          BOOLSTYLE=\'True,False\'  - the representation for booleans, case insensitive, specify true followed by false,\n                                    for example yes,no or 1,0\n          NUMPROCESSES=n          - the number of worker processes, by default the number of cores minus one\n                                    capped at 16\n          CONFIGFILE=\'\'           - a configuration file with the same format as .cqlshrc (see the Python ConfigParser\n                                    documentation) where you can specify WITH options under the following optional\n                                    sections: [copy], [copy-to], [copy-from], [copy:ks.table], [copy-to:ks.table],\n                                    [copy-from:ks.table], where <ks> is your keyspace name and <table> is your table\n                                    name. Options are read from these sections, in the order specified\n                                    above, and command line options always override options in configuration files.\n                                    Depending on the COPY direction, only the relevant copy-from or copy-to sections\n                                    are used. If no configfile is specified then .cqlshrc is searched instead.\n          RATEFILE=\'\'             - an optional file where to print the output statistics\n\n        Available COPY FROM options and defaults:\n\n          CHUNKSIZE=1000          - the size of chunks passed to worker processes\n          INGESTRATE=100000       - an approximate ingest rate in rows per second\n          MINBATCHSIZE=2          - the minimum size of an import batch\n          MAXBATCHSIZE=20         - the maximum size of an import batch\n          MAXROWS=-1              - the maximum number of rows, -1 means no maximum\n          SKIPROWS=0              - the number of rows to skip\n          SKIPCOLS=\'\'             - a comma separated list of column names to skip\n          MAXPARSEERRORS=-1       - the maximum global number of parsing errors, -1 means no maximum\n          MAXINSERTERRORS=-1      - the maximum global number of insert errors, -1 means no maximum\n          ERRFILE=\'\'              - a file where to store all rows that could not be imported, by default this is\n                                    import_ks_table.err where <ks> is your keyspace and <table> is your table name.\n          TTL=3600                - the time to live in seconds, by default data will not expire\n\n        Available COPY TO options and defaults:\n\n          ENCODING=\'utf8\'          - encoding for CSV output\n          PAGESIZE=\'1000\'          - the page size for fetching results\n          PAGETIMEOUT=10           - the page timeout in seconds for fetching results\n          BEGINTOKEN=\'\'            - the minimum token string to consider when exporting data\n          ENDTOKEN=\'\'              - the maximum token string to consider when exporting data\n          MAXREQUESTS=6            - the maximum number of requests each worker process can work on in parallel\n          MAXOUTPUTSIZE=\'-1\'       - the maximum size of the output file measured in number of lines,\n                                     beyond this maximum the output file will be split into segments,\n                                     -1 means unlimited.\n\n        When entering CSV data on STDIN, you can use the sequence "\\."\n        on a line by itself to end the data input.\n        '
    ks = self.cql_unprotect_name(parsed.get_binding('ksname', None))
    if (ks is None):
        ks = self.current_keyspace
        if (ks is None):
            raise NoKeyspaceError('Not in any keyspace.')
    table = self.cql_unprotect_name(parsed.get_binding('cfname'))
    columns = parsed.get_binding('colnames', None)
    if (columns is not None):
        columns = map(self.cql_unprotect_name, columns)
    else:
        columns = self.get_column_names(ks, table)
    fname = parsed.get_binding('fname', None)
    if (fname is not None):
        fname = self.cql_unprotect_value(fname)
    copyoptnames = map(str.lower, parsed.get_binding('optnames', ()))
    copyoptvals = map(self.cql_unprotect_value, parsed.get_binding('optvals', ()))
    opts = dict(zip(copyoptnames, copyoptvals))
    direction = parsed.get_binding('dir').upper()
    if (direction == 'FROM'):
        task = ImportTask(self, ks, table, columns, fname, opts, DEFAULT_PROTOCOL_VERSION, CONFIG_FILE)
    elif (direction == 'TO'):
        task = ExportTask(self, ks, table, columns, fname, opts, DEFAULT_PROTOCOL_VERSION, CONFIG_FILE)
    else:
        raise SyntaxError(('Unknown direction %s' % direction))
    task.run()
