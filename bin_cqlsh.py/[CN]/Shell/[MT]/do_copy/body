def do_copy(self, parsed):
    '\n        COPY [cqlsh only]\n\n          COPY x FROM: Imports CSV data into a Cassandra table\n          COPY x TO: Exports data from a Cassandra table in CSV format.\n\n        COPY <table_name> [ ( column [, ...] ) ]\n             FROM ( \'<filename>\' | STDIN )\n             [ WITH <option>=\'value\' [AND ...] ];\n\n        COPY <table_name> [ ( column [, ...] ) ]\n             TO ( \'<filename>\' | STDOUT )\n             [ WITH <option>=\'value\' [AND ...] ];\n\n        Available options and defaults:\n\n          DELIMITER=\',\'    - character that appears between records\n          QUOTE=\'"\'        - quoting character to be used to quote fields\n          ESCAPE=\'\\\'       - character to appear before the QUOTE char when quoted\n          HEADER=false     - whether to ignore the first line\n          NULL=\'\'          - string that represents a null value\n          ENCODING=\'utf8\'  - encoding for CSV output (COPY TO only)\n\n        When entering CSV data on STDIN, you can use the sequence "\\."\n        on a line by itself to end the data input.\n        '
    ks = self.cql_unprotect_name(parsed.get_binding('ksname', None))
    if (ks is None):
        ks = self.current_keyspace
        if (ks is None):
            raise NoKeyspaceError('Not in any keyspace.')
    cf = self.cql_unprotect_name(parsed.get_binding('cfname'))
    columns = parsed.get_binding('colnames', None)
    if (columns is not None):
        columns = map(self.cql_unprotect_name, columns)
    else:
        columns = self.get_column_names(ks, cf)
    fname = parsed.get_binding('fname', None)
    if (fname is not None):
        fname = os.path.expanduser(self.cql_unprotect_value(fname))
    copyoptnames = map(str.lower, parsed.get_binding('optnames', ()))
    copyoptvals = map(self.cql_unprotect_value, parsed.get_binding('optvals', ()))
    cleancopyoptvals = [optval.decode('string-escape') for optval in copyoptvals]
    opts = dict(zip(copyoptnames, cleancopyoptvals))
    timestart = time.time()
    direction = parsed.get_binding('dir').upper()
    if (direction == 'FROM'):
        rows = self.perform_csv_import(ks, cf, columns, fname, opts)
        verb = 'imported'
    elif (direction == 'TO'):
        rows = self.perform_csv_export(ks, cf, columns, fname, opts)
        verb = 'exported'
    else:
        raise SyntaxError(('Unknown direction %s' % direction))
    timeend = time.time()
    print ('\n%d rows %s in %s.' % (rows, verb, describe_interval((timeend - timestart))))
