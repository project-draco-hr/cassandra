def perform_csv_export(self, ks, cf, columns, fname, opts):
    dialect_options = self.csv_dialect_defaults.copy()
    if ('quote' in opts):
        dialect_options['quotechar'] = opts.pop('quote')
    if ('escape' in opts):
        dialect_options['escapechar'] = opts.pop('escape')
    if ('delimiter' in opts):
        dialect_options['delimiter'] = opts.pop('delimiter')
    encoding = opts.pop('encoding', 'utf8')
    nullval = opts.pop('null', '')
    header = bool((opts.pop('header', '').lower() == 'true'))
    timestamp_format = opts.pop('timeformat', self.display_timestamp_format)
    if (dialect_options['quotechar'] == dialect_options['escapechar']):
        dialect_options['doublequote'] = True
        del dialect_options['escapechar']
    if opts:
        self.printerr(('Unrecognized COPY TO options: %s' % ', '.join(opts.keys())))
        return 0
    if (fname is None):
        do_close = False
        csvdest = sys.stdout
    else:
        do_close = True
        try:
            csvdest = open(fname, 'wb')
        except IOError as e:
            self.printerr(("Can't open %r for writing: %s" % (fname, e)))
            return 0
    meter = RateMeter(10000)
    try:
        dtformats = DateTimeFormat(timestamp_format, self.display_date_format, self.display_nanotime_format)
        dump = self.prep_export_dump(ks, cf, columns)
        writer = csv.writer(csvdest, **dialect_options)
        if header:
            writer.writerow(columns)
        for row in dump:
            fmt = (lambda v: format_value(v, output_encoding=encoding, nullval=nullval, date_time_format=dtformats, float_precision=self.display_float_precision).strval)
            writer.writerow(map(fmt, row.values()))
            meter.increment()
    finally:
        if do_close:
            csvdest.close()
    return meter.current_record
