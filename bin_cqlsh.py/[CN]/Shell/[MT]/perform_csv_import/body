def perform_csv_import(self, ks, cf, columns, fname, opts):
    dialect_options = self.csv_dialect_defaults.copy()
    if ('quote' in opts):
        dialect_options['quotechar'] = opts.pop('quote')
    if ('escape' in opts):
        dialect_options['escapechar'] = opts.pop('escape')
    if ('delimiter' in opts):
        dialect_options['delimiter'] = opts.pop('delimiter')
    nullval = opts.pop('null', '')
    header = bool((opts.pop('header', '').lower() == 'true'))
    if (dialect_options['quotechar'] == dialect_options['escapechar']):
        dialect_options['doublequote'] = True
        del dialect_options['escapechar']
    if opts:
        self.printerr(('Unrecognized COPY FROM options: %s' % ', '.join(opts.keys())))
        return 0
    if (fname is None):
        do_close = False
        print '[Use \\. on a line by itself to end input]'
        linesource = self.use_stdin_reader(prompt='[copy] ', until='\\.')
    else:
        do_close = True
        try:
            linesource = open(fname, 'rb')
        except IOError as e:
            self.printerr(("Can't open %r for reading: %s" % (fname, e)))
            return 0
    current_record = None
    try:
        try:
            if header:
                linesource.next()
            reader = csv.reader(linesource, **dialect_options)
            from multiprocessing import Process, Pipe, cpu_count
            try:
                num_processes = max(1, min(4, (cpu_count() - 1)))
            except NotImplementedError:
                num_processes = 1
            (processes, pipes) = ([], [])
            for i in range(num_processes):
                (parent_conn, child_conn) = Pipe()
                pipes.append(parent_conn)
                processes.append(ImportProcess(self, child_conn, ks, cf, columns, nullval))
            for process in processes:
                process.start()
            meter = RateMeter(10000)
            for (current_record, row) in enumerate(reader, start=1):
                pipes[(current_record % num_processes)].send((current_record, row))
                meter.increment()
                if ((current_record % 100) == 0):
                    if self._check_child_pipes(current_record, pipes):
                        continue
                    else:
                        break
        except Exception as exc:
            if (current_record is None):
                self.printerr('\nError starting import process:\n')
                self.printerr(str(exc))
                if self.debug:
                    traceback.print_exc()
            else:
                self.printerr(('\n' + str(exc)))
                self.printerr(('\nAborting import at record #%d. Previously inserted records and some records after this number may be present.' % (current_record,)))
                if self.debug:
                    traceback.print_exc()
    finally:
        for pipe in pipes:
            pipe.send((None, None))
        for process in processes:
            process.join()
        self._check_child_pipes(current_record, pipes)
        for pipe in pipes:
            pipe.close()
        if do_close:
            linesource.close()
        elif self.tty:
            print 
    return current_record
