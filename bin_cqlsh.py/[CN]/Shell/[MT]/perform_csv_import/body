def perform_csv_import(self, ks, cf, columns, fname, opts):
    (csv_options, dialect_options, unrecognized_options) = copyutil.parse_options(self, opts)
    if unrecognized_options:
        self.printerr(('Unrecognized COPY FROM options: %s' % ', '.join(unrecognized_options.keys())))
        return 0
    (nullval, header) = (csv_options['nullval'], csv_options['header'])
    if (fname is None):
        do_close = False
        print '[Use \\. on a line by itself to end input]'
        linesource = self.use_stdin_reader(prompt='[copy] ', until='\\.')
    else:
        do_close = True
        try:
            linesource = open(fname, 'rb')
        except IOError as e:
            self.printerr(("Can't open %r for reading: %s" % (fname, e)))
            return 0
    current_record = None
    (processes, pipes) = ([], [])
    try:
        try:
            if header:
                linesource.next()
            reader = csv.reader(linesource, **dialect_options)
            num_processes = copyutil.get_num_processes(cap=4)
            for i in range(num_processes):
                (parent_conn, child_conn) = mp.Pipe()
                pipes.append(parent_conn)
                processes.append(ImportProcess(self, child_conn, ks, cf, columns, nullval))
            for process in processes:
                process.start()
            meter = copyutil.RateMeter(10000)
            for (current_record, row) in enumerate(reader, start=1):
                pipes[(current_record % num_processes)].send((current_record, row))
                meter.increment()
                if ((current_record % 100) == 0):
                    if self._check_import_processes(current_record, pipes):
                        continue
                    else:
                        break
        except Exception as exc:
            if (current_record is None):
                self.printerr('\nError starting import process:\n')
                self.printerr(str(exc))
                if self.debug:
                    traceback.print_exc()
            else:
                self.printerr(('\n' + str(exc)))
                self.printerr(('\nAborting import at record #%d. Previously inserted records and some records after this number may be present.' % (current_record,)))
                if self.debug:
                    traceback.print_exc()
    finally:
        for pipe in pipes:
            pipe.send((None, None))
        for process in processes:
            process.join()
        self._check_import_processes(current_record, pipes)
        for pipe in pipes:
            pipe.close()
        if do_close:
            linesource.close()
        elif self.tty:
            print 
    return current_record
