{
  if (ast.getChildCount() > 0) {
    int helpType=ast.getChild(0).getType();
switch (helpType) {
case CliParser.NODE_HELP:
      css_.out.println("help <command>\n");
    css_.out.println("Display the general help page with a list of available commands.");
  break;
case CliParser.NODE_CONNECT:
css_.out.println("connect <hostname>/<port>\n");
css_.out.println("Connect to the specified host on the specified port.\n");
css_.out.println("example:");
css_.out.println("connect localhost/9160");
break;
case CliParser.NODE_USE_TABLE:
css_.out.println("use <keyspace>");
css_.out.println("use <keyspace> <username> '<password>'\n");
css_.out.println("Switch to the specified keyspace. The optional username and password fields");
css_.out.println("are needed when performing authentication.\n");
break;
case CliParser.NODE_DESCRIBE_TABLE:
css_.out.println("describe keyspace <keyspace>\n");
css_.out.println("Show additional information about the specified keyspace.\n");
css_.out.println("example:");
css_.out.println("describe keyspace system");
break;
case CliParser.NODE_EXIT:
css_.out.println("exit");
css_.out.println("quit\n");
css_.out.println("Exit this utility.");
break;
case CliParser.NODE_SHOW_CLUSTER_NAME:
css_.out.println("show cluster name\n");
css_.out.println("Displays the name of the currently connected cluster.");
break;
case CliParser.NODE_SHOW_VERSION:
css_.out.println("show api version\n");
css_.out.println("Displays the API version number.");
break;
case CliParser.NODE_SHOW_TABLES:
css_.out.println("show keyspaces\n");
css_.out.println("Displays a list of the keyspaces available on the currently connected cluster.");
break;
case CliParser.NODE_ADD_KEYSPACE:
css_.out.println("create keyspace <keyspace>");
css_.out.println("create keyspace <keyspace> with <att1>=<value1>");
css_.out.println("create keyspace <keyspace> with <att1>=<value1> and <att2>=<value2> ...\n");
css_.out.println("Create a new keyspace with the specified values for the given set of attributes.\n");
css_.out.println("valid attributes are:");
css_.out.println("    replication_factor: to how many nodes should entries to this keyspace be");
css_.out.println("                        replicated. Valid entries are integers greater than 0.");
css_.out.println("    placement_strategy: the fully qualified class used to place replicas in");
css_.out.println("                        this keyspace. Valid values are");
css_.out.println("                        org.apache.cassandra.locator.SimpleStrategy,");
css_.out.println("                        org.apache.cassandra.locator.NetworkTopologyStrategy,");
css_.out.println("                        and org.apache.cassandra.locator.OldNetworkTopologyStrategy");
css_.out.println("      strategy_options: additional options for placement_strategy.\n");
css_.out.println("example:");
css_.out.println("create keyspace foo with replication_factor = 3 and ");
css_.out.println("        placement_strategy = 'org.apache.cassandra.locator.SimpleStrategy'");
css_.out.println("        and strategy_options=[{DC1:2, DC2:2}]");
break;
case CliParser.NODE_UPDATE_KEYSPACE:
css_.out.println("update keyspace <keyspace>");
css_.out.println("update keyspace <keyspace> with <att1>=<value1>");
css_.out.println("update keyspace <keyspace> with <att1>=<value1> and <att2>=<value2> ...\n");
css_.out.println("Update a keyspace with the specified values for the given set of attributes.\n");
css_.out.println("valid attributes are:");
css_.out.println("    replication_factor: to how many nodes should entries to this keyspace be");
css_.out.println("                        replicated. Valid entries are integers greater than 0.");
css_.out.println("    placement_strategy: the fully qualified class used to place replicas in");
css_.out.println("                        this keyspace. Valid values are");
css_.out.println("                        org.apache.cassandra.locator.SimpleStrategy,");
css_.out.println("                        org.apache.cassandra.locator.NetworkTopologyStrategy,");
css_.out.println("                        and org.apache.cassandra.locator.OldNetworkTopologyStrategy");
css_.out.println("      strategy_options: additional options for placement_strategy.\n");
css_.out.println("example:");
css_.out.println("update keyspace foo with replication_factor = 2 and ");
css_.out.println("        placement_strategy = 'org.apache.cassandra.locator.LocalStrategy'");
css_.out.println("        and strategy_options=[{DC1:1, DC2:4, DC3:2}]");
break;
case CliParser.NODE_ADD_COLUMN_FAMILY:
css_.out.println("create column family Bar");
css_.out.println("create column family Bar with <att1>=<value1>");
css_.out.println("create column family Bar with <att1>=<value1> and <att2>=<value2>...\n");
css_.out.println("Create a new column family with the specified values for the given set of");
css_.out.println("attributes. Note that you must be using a keyspace.\n");
css_.out.println("valid attributes are:");
css_.out.println("    - column_type: One of Super or Standard");
css_.out.println("    - comparator: The class used as a comparator when sorting column names.");
css_.out.println("                  Valid options include: AsciiType, BytesType, LexicalUUIDType,");
css_.out.println("                  LongType, TimeUUIDType, and UTF8Type");
css_.out.println("    - subcomparator: Name of comparator used for subcolumns (when");
css_.out.println("                     column_type=Super only). Valid options are identical to");
css_.out.println("                     comparator above.");
css_.out.println("    - comment: Human-readable column family description. Any string is valid.");
css_.out.println("    - rows_cached: Number of rows to cache");
css_.out.println("    - preload_row_cache: Set to true to automatically load the row cache");
css_.out.println("    - key_cache_size: Number of keys to cache");
css_.out.println("    - read_repair_chance: Valid values for this attribute are any number");
css_.out.println("                          between 0.0 and 1.0\n");
css_.out.println("    - column_metadata: Metadata which describes columns of column family.");
css_.out.println("        Supported format is [{ k:v, k:v, ... }, { ... }, ...]");
css_.out.println("        Valid attributes: column_name, validation_class (see comparator),");
css_.out.println("                          index_type (integer), index_name.");
css_.out.println("example:\n");
css_.out.println("create column family Bar with column_type = 'Super' and comparator = 'AsciiType'");
css_.out.println("      and rows_cached = 10000");
css_.out.println("create column family Baz with comparator = 'LongType' and rows_cached = 10000");
css_.out.print("create column family Foo with comparator=LongType and column_metadata=");
css_.out.print("[{ column_name:Test, validation_class:IntegerType, index_type:0, index_name:IdxName");
css_.out.println("}, { column_name:'other name', validation_class:LongType }]");
break;
case CliParser.NODE_UPDATE_COLUMN_FAMILY:
css_.out.println("update column family Bar");
css_.out.println("update column family Bar with <att1>=<value1>");
css_.out.println("update column family Bar with <att1>=<value1> and <att2>=<value2>...\n");
css_.out.println("Update a column family with the specified values for the given set of");
css_.out.println("attributes. Note that you must be using a keyspace.\n");
css_.out.println("valid attributes are:");
css_.out.println("    - comment: Human-readable column family description. Any string is valid.");
css_.out.println("    - rows_cached: Number of rows to cache");
css_.out.println("    - preload_row_cache: Set to true to automatically load the row cache");
css_.out.println("    - key_cache_size: Number of keys to cache");
css_.out.println("    - read_repair_chance: Valid values for this attribute are any number");
css_.out.println("                          between 0.0 and 1.0\n");
css_.out.println("    - column_metadata: Metadata which describes columns of column family.");
css_.out.println("        Supported format is [{ k:v, k:v, ... }, { ... }, ...]");
css_.out.println("        Valid attributes: column_name, validation_class (see comparator),");
css_.out.println("                          index_type (integer), index_name.");
css_.out.println("example:\n");
css_.out.print("update column family Foo with column_metadata=");
css_.out.print("[{ column_name:Test, validation_class:IntegerType, index_type:0, index_name:IdxName");
css_.out.println("}] and rows_cached=100 and comment='this is helpful comment.'");
break;
case CliParser.NODE_DEL_KEYSPACE:
css_.out.println("drop keyspace <keyspace>\n");
css_.out.println("Drops the specified keyspace.\n");
css_.out.println("example:");
css_.out.println("drop keyspace foo");
break;
case CliParser.NODE_DEL_COLUMN_FAMILY:
css_.out.println("drop column family <name>\n");
css_.out.println("Drops the specified column family.\n");
css_.out.println("example:");
css_.out.println("drop column family foo");
break;
case CliParser.NODE_THRIFT_GET:
css_.out.println("get <cf>['<key>']");
css_.out.println("get <cf>['<key>']['<col>'] (as <type>)*");
css_.out.println("get <cf>['<key>']['<super>']");
css_.out.println("get <cf> where <column> = <value> [and <column> > <value> and ...] [limit <integer>]");
css_.out.println("Default LIMIT is 100. Available operations: =, >, >=, <, <=\n");
css_.out.println("get <cf>['<key>']['<super>']['<col>'] (as <type>)*");
css_.out.print("Note: `as <type>` is optional, it dynamically converts column value to the specified type");
css_.out.println(", column value validator will be set to <type>.");
css_.out.println("Available types: IntegerType, LongType, UTF8Type, ASCIIType, TimeUUIDType, LexicalUUIDType.\n");
css_.out.println("examples:");
css_.out.println("get bar[testkey]");
css_.out.println("get bar[testkey][test_column] as IntegerType");
break;
case CliParser.NODE_THRIFT_SET:
css_.out.println("set <cf>['<key>']['<col>'] = <value>");
css_.out.println("set <cf>['<key>']['<super>']['<col>'] = <value>");
css_.out.println("set <cf>['<key>']['<col>'] = <function>(<argument>)");
css_.out.println("set <cf>['<key>']['<super>']['<col>'] = <function>(<argument>)");
css_.out.println("Available functions: " + Function.getFunctionNames() + "\n");
css_.out.println("examples:");
css_.out.println("set bar['testkey']['my super']['test col']='this is a test'");
css_.out.println("set baz['testkey']['test col']='this is also a test'");
css_.out.println("set diz[testkey][testcol] = utf8('this is utf8 string.')");
break;
case CliParser.NODE_THRIFT_DEL:
css_.out.println("del <cf>['<key>'] ");
css_.out.println("del <cf>['<key>']['<col>'] ");
css_.out.println("del <cf>['<key>']['<super>']['<col>']\n");
css_.out.println("Deletes a record, a column, or a subcolumn.\n");
css_.out.println("example:");
css_.out.println("del bar['testkey']['my super']['test col']");
css_.out.println("del baz['testkey']['test col']");
css_.out.println("del baz['testkey']");
break;
case CliParser.NODE_THRIFT_COUNT:
css_.out.println("count <cf>['<key>']");
css_.out.println("count <cf>['<key>']['<super>']\n");
css_.out.println("Count the number of columns in the specified key or subcolumns in the specified");
css_.out.println("super column.\n");
css_.out.println("example:");
css_.out.println("count bar['testkey']['my super']");
css_.out.println("count baz['testkey']");
break;
case CliParser.NODE_LIST:
css_.out.println("list <cf>");
css_.out.println("list <cf>[<startKey>:]");
css_.out.println("list <cf>[<startKey>:<endKey>]");
css_.out.println("list ... limit N");
css_.out.println("List a range of rows in the column or supercolumn family.\n");
css_.out.println("example:");
css_.out.println("list Users[j:] limit 40");
break;
default :
css_.out.println("?");
break;
}
}
 else {
css_.out.println("List of all CLI commands:");
css_.out.println("?                                                          Display this message.");
css_.out.println("help                                                          Display this help.");
css_.out.println("help <command>                          Display detailed, command-specific help.");
css_.out.println("connect <hostname>/<port>                             Connect to thrift service.");
css_.out.println("use <keyspace> [<username> 'password']                     Switch to a keyspace.");
css_.out.println("describe keyspace <keyspacename>                              Describe keyspace.");
css_.out.println("exit                                                                   Exit CLI.");
css_.out.println("quit                                                                   Exit CLI.");
css_.out.println("show cluster name                                          Display cluster name.");
css_.out.println("show keyspaces                                           Show list of keyspaces.");
css_.out.println("show api version                                        Show server API version.");
css_.out.println("create keyspace <keyspace> [with <att1>=<value1> [and <att2>=<value2> ...]]");
css_.out.println("                Add a new keyspace with the specified attribute(s) and value(s).");
css_.out.println("update keyspace <keyspace> [with <att1>=<value1> [and <att2>=<value2> ...]]");
css_.out.println("                 Update a keyspace with the specified attribute(s) and value(s).");
css_.out.println("create column family <cf> [with <att1>=<value1> [and <att2>=<value2> ...]]");
css_.out.println("        Create a new column family with the specified attribute(s) and value(s).");
css_.out.println("update column family <cf> [with <att1>=<value1> [and <att2>=<value2> ...]]");
css_.out.println("            Update a column family with the specified attribute(s) and value(s).");
css_.out.println("drop keyspace <keyspace>                                      Delete a keyspace.");
css_.out.println("drop column family <cf>                                  Delete a column family.");
css_.out.println("rename keyspace <keyspace> <keyspace_new_name>                Rename a keyspace.");
css_.out.println("rename column family <cf> <new_name>                     Rename a column family.");
css_.out.println("get <cf>['<key>']                                        Get a slice of columns.");
css_.out.println("get <cf>['<key>']['<super>']                         Get a slice of sub columns.");
css_.out.println("get <cf> where <column> = <value> [and <column> > <value> and ...] [limit int]. ");
css_.out.println("get <cf>['<key>']['<col>'] (as <type>)*                      Get a column value.");
css_.out.println("get <cf>['<key>']['<super>']['<col>'] (as <type>)*       Get a sub column value.");
css_.out.println("set <cf>['<key>']['<col>'] = <value>                               Set a column.");
css_.out.println("set <cf>['<key>']['<super>']['<col>'] = <value>                Set a sub column.");
css_.out.println("del <cf>['<key>']                                                 Delete record.");
css_.out.println("del <cf>['<key>']['<col>']                                        Delete column.");
css_.out.println("del <cf>['<key>']['<super>']['<col>']                         Delete sub column.");
css_.out.println("count <cf>['<key>']                                     Count columns in record.");
css_.out.println("count <cf>['<key>']['<super>']                  Count columns in a super column.");
css_.out.println("list <cf>                                  List all rows in the column family.");
css_.out.println("list <cf>[<startKey>:]");
css_.out.println("                       List rows in the column family beginning with <startKey>.");
css_.out.println("list <cf>[<startKey>:<endKey>]");
css_.out.println("        List rows in the column family in the range from <startKey> to <endKey>.");
css_.out.println("list ... limit N                                    Limit the list results to N.");
}
}
