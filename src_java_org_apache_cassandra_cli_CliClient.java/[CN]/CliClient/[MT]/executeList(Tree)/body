{
  if (!CliMain.isConnected() || !hasKeySpace())   return;
  String columnFamily=statement.getChild(0).getText();
  String startKey="";
  String endKey="";
  int limitCount=Integer.MAX_VALUE;
  for (int i=1; i < statement.getChildCount(); i++) {
    Tree child=statement.getChild(i);
    if (child.getType() == CliParser.NODE_KEY_RANGE) {
      if (child.getChildCount() > 0) {
        startKey=CliUtils.unescapeSQLString(child.getChild(0).getText());
        if (child.getChildCount() > 1)         endKey=CliUtils.unescapeSQLString(child.getChild(1).getText());
      }
    }
 else {
      if (child.getChildCount() != 1) {
        sessionState.out.println("Invalid limit clause");
        return;
      }
      limitCount=Integer.parseInt(child.getChild(0).getText());
      if (limitCount <= 0) {
        sessionState.out.println("Invalid limit " + limitCount);
        return;
      }
    }
  }
  if (limitCount == Integer.MAX_VALUE) {
    limitCount=100;
    sessionState.out.println("Using default limit of 100");
  }
  CfDef columnFamilyDef=getCfDef(columnFamily);
  SlicePredicate predicate=new SlicePredicate();
  SliceRange sliceRange=new SliceRange();
  sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
  sliceRange.setCount(Integer.MAX_VALUE);
  predicate.setSlice_range(sliceRange);
  KeyRange range=new KeyRange(limitCount);
  AbstractType keyComparator=this.cfKeysComparators.get(columnFamily);
  range.setStart_key(getBytesAccordingToType(startKey,keyComparator)).setEnd_key(getBytesAccordingToType(endKey,keyComparator));
  ColumnParent columnParent=new ColumnParent(columnFamily);
  List<KeySlice> keySlices=thriftClient.get_range_slices(columnParent,predicate,range,ConsistencyLevel.ONE);
  printSliceList(columnFamilyDef,keySlices);
}
