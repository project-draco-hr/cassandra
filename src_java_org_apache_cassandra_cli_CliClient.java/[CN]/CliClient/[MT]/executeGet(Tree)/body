{
  if (!CliMain.isConnected() || !hasKeySpace())   return;
  Tree columnFamilySpec=statement.getChild(0);
  String columnFamily=CliCompiler.getColumnFamily(columnFamilySpec,keyspacesMap.get(keySpace).cf_defs);
  ByteBuffer key=getKeyAsBytes(columnFamily,columnFamilySpec.getChild(1));
  int columnSpecCnt=CliCompiler.numColumnSpecifiers(columnFamilySpec);
  CfDef cfDef=getCfDef(columnFamily);
  boolean isSuper=cfDef.column_type.equals("Super");
  byte[] superColumnName=null;
  ByteBuffer columnName;
  Tree typeTree=null;
  Tree limitTree=null;
  int limit=1000000;
  if (statement.getChildCount() >= 2) {
    if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE) {
      typeTree=statement.getChild(1).getChild(0);
      if (statement.getChildCount() == 3)       limitTree=statement.getChild(2).getChild(0);
    }
 else {
      limitTree=statement.getChild(1).getChild(0);
    }
  }
  if (limitTree != null) {
    limit=Integer.parseInt(limitTree.getText());
    if (limit == 0) {
      throw new IllegalArgumentException("LIMIT should be greater than zero.");
    }
  }
  if (columnSpecCnt == 0) {
    doSlice(keySpace,key,columnFamily,superColumnName,limit);
    return;
  }
 else   if (columnSpecCnt == 1) {
    columnName=getColumnName(columnFamily,columnFamilySpec.getChild(2));
    if (isSuper) {
      superColumnName=columnName.array();
      doSlice(keySpace,key,columnFamily,superColumnName,limit);
      return;
    }
  }
 else   if (columnSpecCnt == 2) {
    superColumnName=getColumnName(columnFamily,columnFamilySpec.getChild(2)).array();
    columnName=getSubColumnName(columnFamily,columnFamilySpec.getChild(3));
  }
 else {
    sessionState.out.println("Invalid row, super column, or column specification.");
    return;
  }
  AbstractType validator=getValidatorForValue(cfDef,TBaseHelper.byteBufferToByteArray(columnName));
  ColumnPath path=new ColumnPath(columnFamily);
  if (superColumnName != null)   path.setSuper_column(superColumnName);
  path.setColumn(columnName);
  if (isCounterCF(cfDef)) {
    doGetCounter(key,path);
    return;
  }
  Column column;
  try {
    column=thriftClient.get(key,path,consistencyLevel).column;
  }
 catch (  NotFoundException e) {
    sessionState.out.println("Value was not found");
    return;
  }
  byte[] columnValue=column.getValue();
  String valueAsString;
  if (typeTree != null) {
    String typeName=CliUtils.unescapeSQLString(typeTree.getText());
    AbstractType valueValidator=getFormatType(typeName);
    valueAsString=valueValidator.getString(ByteBuffer.wrap(columnValue));
    updateColumnMetaData(cfDef,columnName,valueValidator.getClass().getName());
  }
 else {
    valueAsString=(validator == null) ? new String(columnValue,Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));
  }
  String formattedColumnName=isSuper ? formatSubcolumnName(keySpace,columnFamily,column.name) : formatColumnName(keySpace,columnFamily,column.name);
  sessionState.out.printf("=> (column=%s, value=%s, timestamp=%d%s)%n",formattedColumnName,valueAsString,column.timestamp,column.isSetTtl() ? String.format(", ttl=%d",column.getTtl()) : "");
}
