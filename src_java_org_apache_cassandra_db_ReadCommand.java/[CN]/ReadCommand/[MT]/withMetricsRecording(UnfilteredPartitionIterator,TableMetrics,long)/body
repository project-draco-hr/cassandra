{
  return new WrappingUnfilteredPartitionIterator(iter){
    private final int failureThreshold=DatabaseDescriptor.getTombstoneFailureThreshold();
    private final int warningThreshold=DatabaseDescriptor.getTombstoneWarnThreshold();
    private final boolean respectTombstoneThresholds=!Schema.isSystemKeyspace(ReadCommand.this.metadata().ksName);
    private int liveRows=0;
    private int tombstones=0;
    private DecoratedKey currentKey;
    @Override public UnfilteredRowIterator computeNext(    UnfilteredRowIterator iter){
      currentKey=iter.partitionKey();
      return new AlteringUnfilteredRowIterator(iter){
        @Override protected Row computeNextStatic(        Row row){
          return computeNext(row);
        }
        @Override protected Row computeNext(        Row row){
          if (row.hasLiveData(ReadCommand.this.nowInSec()))           ++liveRows;
          for (          Cell cell : row.cells()) {
            if (!cell.isLive(ReadCommand.this.nowInSec()))             countTombstone(row.clustering());
          }
          return row;
        }
        @Override protected RangeTombstoneMarker computeNext(        RangeTombstoneMarker marker){
          countTombstone(marker.clustering());
          return marker;
        }
        private void countTombstone(        ClusteringPrefix clustering){
          ++tombstones;
          if (tombstones > failureThreshold && respectTombstoneThresholds) {
            String query=ReadCommand.this.toCQLString();
            Tracing.trace("Scanned over {} tombstones for query {}; query aborted (see tombstone_failure_threshold)",failureThreshold,query);
            throw new TombstoneOverwhelmingException(tombstones,query,ReadCommand.this.metadata(),currentKey,clustering);
          }
        }
      }
;
    }
    @Override public void close(){
      try {
        super.close();
      }
  finally {
        recordLatency(metric,System.nanoTime() - startTimeNanos);
        metric.tombstoneScannedHistogram.update(tombstones);
        metric.liveScannedHistogram.update(liveRows);
        boolean warnTombstones=tombstones > warningThreshold && respectTombstoneThresholds;
        if (warnTombstones) {
          String msg=String.format("Read %d live rows and %d tombstone cells for query %1.512s (see tombstone_warn_threshold)",liveRows,tombstones,ReadCommand.this.toCQLString());
          ClientWarn.warn(msg);
          logger.warn(msg);
        }
        Tracing.trace("Read {} live and {} tombstone cells{}",liveRows,tombstones,(warnTombstones ? " (see tombstone_warn_threshold)" : ""));
      }
    }
  }
;
}
