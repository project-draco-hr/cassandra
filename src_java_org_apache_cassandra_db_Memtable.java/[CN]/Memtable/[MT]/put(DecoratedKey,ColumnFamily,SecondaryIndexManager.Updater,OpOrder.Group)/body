{
  AtomicBTreeColumns previous=rows.get(key);
  long initialSize=0;
  if (previous == null) {
    AtomicBTreeColumns empty=cf.cloneMeShallow(AtomicBTreeColumns.factory,false);
    final DecoratedKey cloneKey=allocator.clone(key,opGroup);
    previous=rows.putIfAbsent(cloneKey,empty);
    if (previous == null) {
      previous=empty;
      int overhead=(int)(key.getToken().getHeapSize() + ROW_OVERHEAD_HEAP_SIZE);
      allocator.onHeap().allocate(overhead,opGroup);
      initialSize=8;
    }
 else {
      allocator.reclaimer().reclaimImmediately(cloneKey);
    }
  }
  final AtomicBTreeColumns.ColumnUpdater updater=previous.addAllWithSizeDelta(cf,allocator,opGroup,indexer);
  minTimestamp=Math.min(minTimestamp,updater.minTimestamp);
  liveDataSize.addAndGet(initialSize + updater.dataSize);
  currentOperations.addAndGet(cf.getColumnCount() + (cf.isMarkedForDelete() ? 1 : 0) + cf.deletionInfo().rangeCount());
  return updater.colUpdateTimeDelta;
}
