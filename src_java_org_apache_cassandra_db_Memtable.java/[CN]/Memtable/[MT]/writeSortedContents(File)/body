{
  logger.info("Writing {}",Memtable.this.toString());
  SSTableReader ssTable;
  try (SSTableWriter writer=createFlushWriter(cfs.getTempSSTablePath(sstableDirectory))){
    boolean trackContention=logger.isTraceEnabled();
    int heavilyContendedRowCount=0;
    for (    Map.Entry<RowPosition,AtomicBTreeColumns> entry : rows.entrySet()) {
      AtomicBTreeColumns cf=entry.getValue();
      if (cf.isMarkedForDelete() && cf.hasColumns()) {
        if (cfs.name.equals(SystemKeyspace.BATCHLOG) && cfs.keyspace.getName().equals(SystemKeyspace.NAME))         continue;
      }
      if (trackContention && cf.usePessimisticLocking())       heavilyContendedRowCount++;
      if (!cf.isEmpty())       writer.append((DecoratedKey)entry.getKey(),cf);
    }
    if (writer.getFilePointer() > 0) {
      logger.debug(String.format("Completed flushing %s (%s) for commitlog position %s",writer.getFilename(),FBUtilities.prettyPrintMemory(writer.getOnDiskFilePointer()),commitLogUpperBound));
      ssTable=writer.finish(true);
    }
 else {
      logger.debug("Completed flushing {}; nothing needed to be retained.  Commitlog position was {}",writer.getFilename(),commitLogUpperBound);
      writer.abort();
      ssTable=null;
    }
    if (heavilyContendedRowCount > 0)     logger.trace(String.format("High update contention in %d/%d partitions of %s ",heavilyContendedRowCount,rows.size(),Memtable.this.toString()));
    return ssTable;
  }
 }
