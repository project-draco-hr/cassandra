{
  boolean isBatchLogTable=cfs.name.equals(SystemKeyspace.BATCHES) && cfs.keyspace.getName().equals(SystemKeyspace.NAME);
  logger.debug("Writing {}",Memtable.this.toString());
  Collection<SSTableReader> ssTables;
  try (SSTableTxnWriter writer=createFlushWriter(cfs.getSSTablePath(sstableDirectory),columnsCollector.get(),statsCollector.get())){
    boolean trackContention=logger.isTraceEnabled();
    int heavilyContendedRowCount=0;
    for (    AtomicBTreePartition partition : partitions.values()) {
      if (isBatchLogTable && !partition.partitionLevelDeletion().isLive() && partition.hasRows())       continue;
      if (trackContention && partition.usePessimisticLocking())       heavilyContendedRowCount++;
      if (!partition.isEmpty()) {
        try (UnfilteredRowIterator iter=partition.unfilteredIterator()){
          writer.append(iter);
        }
       }
    }
    if (writer.getFilePointer() > 0) {
      logger.debug(String.format("Completed flushing %s (%s) for commitlog position %s",writer.getFilename(),FBUtilities.prettyPrintMemory(writer.getFilePointer()),commitLogUpperBound));
      ssTables=writer.finish(true);
    }
 else {
      logger.debug("Completed flushing {}; nothing needed to be retained.  Commitlog position was {}",writer.getFilename(),commitLogUpperBound);
      writer.abort();
      ssTables=Collections.emptyList();
    }
    if (heavilyContendedRowCount > 0)     logger.trace(String.format("High update contention in %d/%d partitions of %s ",heavilyContendedRowCount,partitions.size(),Memtable.this.toString()));
    return ssTables;
  }
 }
