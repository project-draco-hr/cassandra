{
  final OpOrder.Group group=new OpOrder().start();
  int rowOverhead;
  MemtableAllocator allocator=MEMORY_POOL.newAllocator();
  ConcurrentNavigableMap<RowPosition,Object> rows=new ConcurrentSkipListMap<>();
  final Object val=new Object();
  for (int i=0; i < count; i++)   rows.put(allocator.clone(new BufferDecoratedKey(new LongToken((long)i),ByteBufferUtil.EMPTY_BYTE_BUFFER),group),val);
  double avgSize=ObjectSizes.measureDeep(rows) / (double)count;
  rowOverhead=(int)((avgSize - Math.floor(avgSize)) < 0.05 ? Math.floor(avgSize) : Math.ceil(avgSize));
  rowOverhead-=ObjectSizes.measureDeep(new LongToken((long)0));
  rowOverhead+=AtomicBTreeColumns.EMPTY_SIZE;
  allocator.setDiscarding();
  allocator.setDiscarded();
  return rowOverhead;
}
