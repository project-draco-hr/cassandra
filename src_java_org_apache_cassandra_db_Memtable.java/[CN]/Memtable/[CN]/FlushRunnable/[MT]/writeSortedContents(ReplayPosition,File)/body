{
  logger.info("Writing {}",Memtable.this.toString());
  SSTableReader ssTable;
  SSTableWriter writer=createFlushWriter(cfs.getTempSSTablePath(sstableDirectory));
  try {
    for (    Map.Entry<RowPosition,AtomicBTreeColumns> entry : rows.entrySet()) {
      ColumnFamily cf=entry.getValue();
      if (cf.isMarkedForDelete() && cf.hasColumns()) {
        if (cfs.name.equals(SystemKeyspace.BATCHLOG_CF) && cfs.keyspace.getName().equals(Keyspace.SYSTEM_KS))         continue;
      }
      if (!cf.isEmpty())       writer.append((DecoratedKey)entry.getKey(),cf);
    }
    if (writer.getFilePointer() > 0) {
      writer.isolateReferences();
      ssTable=writer.closeAndOpenReader();
      logger.info(String.format("Completed flushing %s (%d bytes) for commitlog position %s",ssTable.getFilename(),new File(ssTable.getFilename()).length(),context));
    }
 else {
      writer.abort();
      ssTable=null;
      logger.info("Completed flushing; nothing needed to be retained.  Commitlog position was {}",context);
    }
    return ssTable;
  }
 catch (  Throwable e) {
    writer.abort();
    throw Throwables.propagate(e);
  }
}
