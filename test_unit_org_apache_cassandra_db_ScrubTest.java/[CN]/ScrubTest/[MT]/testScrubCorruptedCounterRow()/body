{
  CompactionManager.instance.disableAutoCompaction();
  Keyspace keyspace=Keyspace.open(KEYSPACE);
  ColumnFamilyStore cfs=keyspace.getColumnFamilyStore(COUNTER_CF);
  cfs.clearUnsafe();
  fillCounterCF(cfs,2);
  List<Row> rows=cfs.getRangeSlice(Util.range("",""),null,new IdentityQueryFilter(),1000);
  assertEquals(2,rows.size());
  SSTableReader sstable=cfs.getSSTables().iterator().next();
  long row0Start=sstable.getPosition(RowPosition.forKey(ByteBufferUtil.bytes("0"),sstable.partitioner),SSTableReader.Operator.EQ).position;
  long row1Start=sstable.getPosition(RowPosition.forKey(ByteBufferUtil.bytes("1"),sstable.partitioner),SSTableReader.Operator.EQ).position;
  long startPosition=row0Start < row1Start ? row0Start : row1Start;
  long endPosition=row0Start < row1Start ? row1Start : row0Start;
  RandomAccessFile file=new RandomAccessFile(sstable.getFilename(),"rw");
  file.seek(startPosition);
  file.writeBytes(StringUtils.repeat('z',(int)(endPosition - startPosition)));
  file.close();
  Scrubber scrubber=new Scrubber(cfs,sstable,false);
  try {
    scrubber.scrub();
    fail("Expected a CorruptSSTableException to be thrown");
  }
 catch (  IOError err) {
  }
  scrubber=new Scrubber(cfs,sstable,true);
  scrubber.scrub();
  scrubber.close();
  cfs.replaceCompactedSSTables(Collections.singletonList(sstable),Collections.singletonList(scrubber.getNewSSTable()),OperationType.SCRUB);
  assertEquals(1,cfs.getSSTables().size());
  rows=cfs.getRangeSlice(Util.range("",""),null,new IdentityQueryFilter(),1000);
  assertEquals(1,rows.size());
}
