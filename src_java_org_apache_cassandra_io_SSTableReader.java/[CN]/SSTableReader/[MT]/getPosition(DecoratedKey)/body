{
  if (!bf.isPresent(partitioner.convertToDiskFormat(decoratedKey)))   return null;
  if (keyCache != null) {
    PositionSize cachedPosition=keyCache.get(decoratedKey);
    if (cachedPosition != null) {
      return cachedPosition;
    }
  }
  KeyPosition sampledPosition=getIndexScanPosition(decoratedKey);
  if (sampledPosition == null) {
    return null;
  }
  if (spannedIndexDataPositions != null) {
    PositionSize info=spannedIndexDataPositions.get(sampledPosition);
    if (info != null)     return info;
  }
  long p=sampledPosition.position;
  FileDataInput input;
  if (indexBuffers == null) {
    input=new BufferedRandomAccessFile(indexFilename(),"r");
    input.seek(p);
  }
 else {
    input=new MappedFileDataInput(indexBuffers[bufferIndex(p)],indexFilename(),(int)(p % BUFFER_SIZE));
  }
  try {
    int i=0;
    do {
      DecoratedKey indexDecoratedKey;
      try {
        indexDecoratedKey=partitioner.convertFromDiskFormat(input.readUTF());
      }
 catch (      EOFException e) {
        return null;
      }
      long position=input.readLong();
      int v=indexDecoratedKey.compareTo(decoratedKey);
      if (v == 0) {
        PositionSize info;
        if (input.getFilePointer() < input.length()) {
          int utflen=input.readUnsignedShort();
          if (utflen != input.skipBytes(utflen))           throw new EOFException();
          info=new PositionSize(position,input.readLong() - position);
        }
 else {
          info=new PositionSize(position,length() - position);
        }
        if (keyCache != null)         keyCache.put(decoratedKey,info);
        return info;
      }
      if (v > 0)       return null;
    }
 while (++i < INDEX_INTERVAL);
  }
  finally {
    input.close();
  }
  return null;
}
