{
  Refs<SSTableReader> refs=new Refs<>();
  try {
    for (    ColumnFamilyStore cfStore : stores) {
      final List<AbstractBounds<RowPosition>> rowBoundsList=new ArrayList<>(ranges.size());
      for (      Range<Token> range : ranges)       rowBoundsList.add(range.toRowBounds());
      refs.addAll(cfStore.selectAndReference(new Function<DataTracker.View,List<SSTableReader>>(){
        public List<SSTableReader> apply(        DataTracker.View view){
          Map<SSTableReader,SSTableReader> permittedInstances=new HashMap<>();
          for (          SSTableReader reader : ColumnFamilyStore.CANONICAL_SSTABLES.apply(view))           permittedInstances.put(reader,reader);
          Set<SSTableReader> sstables=Sets.newHashSet();
          for (          AbstractBounds<RowPosition> rowBounds : rowBoundsList) {
            for (            SSTableReader sstable : view.sstablesInBounds(rowBounds)) {
              if (isIncremental && sstable.isRepaired())               continue;
              sstable=permittedInstances.get(sstable);
              if (sstable != null)               sstables.add(sstable);
            }
          }
          return ImmutableList.copyOf(sstables);
        }
      }
).refs);
    }
    List<SSTableStreamingSections> sections=new ArrayList<>(refs.size());
    for (    SSTableReader sstable : refs) {
      long repairedAt=overriddenRepairedAt;
      if (overriddenRepairedAt == ActiveRepairService.UNREPAIRED_SSTABLE)       repairedAt=sstable.getSSTableMetadata().repairedAt;
      sections.add(new SSTableStreamingSections(refs.get(sstable),sstable.getPositionsForRanges(ranges),sstable.estimatedKeysForRanges(ranges),repairedAt));
    }
    return sections;
  }
 catch (  Throwable t) {
    refs.release();
    throw t;
  }
}
