{
  Refs<SSTableReader> refs=new Refs<>();
  try {
    for (    ColumnFamilyStore cfStore : stores) {
      final List<Range<RowPosition>> keyRanges=new ArrayList<>(ranges.size());
      for (      Range<Token> range : ranges)       keyRanges.add(Range.makeRowRange(range));
      refs.addAll(cfStore.selectAndReference(new Function<View,List<SSTableReader>>(){
        public List<SSTableReader> apply(        View view){
          SSTableIntervalTree intervalTree=SSTableIntervalTree.build(ColumnFamilyStore.CANONICAL_SSTABLES.apply(view));
          Set<SSTableReader> sstables=Sets.newHashSet();
          for (          Range<RowPosition> keyRange : keyRanges) {
            for (            SSTableReader sstable : View.sstablesInBounds(keyRange.left,keyRange.right,intervalTree)) {
              if (!isIncremental || !sstable.isRepaired())               sstables.add(sstable);
            }
          }
          logger.debug("ViewFilter for {}/{} sstables",sstables.size(),view.sstables.size());
          return ImmutableList.copyOf(sstables);
        }
      }
).refs);
    }
    List<SSTableStreamingSections> sections=new ArrayList<>(refs.size());
    for (    SSTableReader sstable : refs) {
      long repairedAt=overriddenRepairedAt;
      if (overriddenRepairedAt == ActiveRepairService.UNREPAIRED_SSTABLE)       repairedAt=sstable.getSSTableMetadata().repairedAt;
      sections.add(new SSTableStreamingSections(refs.get(sstable),sstable.getPositionsForRanges(ranges),sstable.estimatedKeysForRanges(ranges),repairedAt));
    }
    return sections;
  }
 catch (  Throwable t) {
    refs.release();
    throw t;
  }
}
