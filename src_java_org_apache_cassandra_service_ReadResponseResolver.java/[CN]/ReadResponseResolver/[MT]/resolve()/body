{
  if (logger_.isDebugEnabled())   logger_.debug("resolving " + results.size() + " responses");
  long startTime=System.currentTimeMillis();
  List<ColumnFamily> versions=new ArrayList<ColumnFamily>();
  List<InetAddress> endpoints=new ArrayList<InetAddress>();
  for (  Map.Entry<Message,ReadResponse> entry : results.entrySet()) {
    ReadResponse result=entry.getValue();
    Message message=entry.getKey();
    if (result.isDigestQuery()) {
      if (digest == null) {
        digest=result.digest();
      }
 else {
        ByteBuffer digest2=result.digest();
        if (!digest.equals(digest2))         throw new DigestMismatchException(key,digest,digest2);
      }
    }
 else {
      ColumnFamily cf=result.row().cf;
      InetAddress from=message.getFrom();
      if (cf != null) {
        AbstractType defaultValidator=cf.metadata().getDefaultValidator();
        if (!FBUtilities.getLocalAddress().equals(from) && defaultValidator.isCommutative()) {
          cf=cf.cloneMe();
          ((AbstractCommutativeType)defaultValidator).cleanContext(cf,FBUtilities.getLocalAddress());
        }
      }
      versions.add(cf);
      endpoints.add(from);
    }
    results.remove(message);
  }
  if (digest != null) {
    for (    ColumnFamily cf : versions) {
      ByteBuffer digest2=ColumnFamily.digest(cf);
      if (!digest.equals(digest2))       throw new DigestMismatchException(key,digest,digest2);
    }
    if (logger_.isDebugEnabled())     logger_.debug("digests verified");
  }
  ColumnFamily resolved;
  if (versions.size() > 1) {
    resolved=resolveSuperset(versions);
    if (logger_.isDebugEnabled())     logger_.debug("versions merged");
    maybeScheduleRepairs(resolved,table,key,versions,endpoints);
  }
 else {
    resolved=versions.get(0);
  }
  if (logger_.isDebugEnabled())   logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
  return new Row(key,resolved);
}
