{
  long startTime=System.currentTimeMillis();
  List<Row> rows=new ArrayList<Row>();
  List<InetAddress> endPoints=new ArrayList<InetAddress>();
  String key=null;
  byte[] digest=new byte[0];
  boolean isDigestQuery=false;
  DataInputBuffer bufIn=new DataInputBuffer();
  for (  Message response : responses) {
    byte[] body=response.getMessageBody();
    bufIn.reset(body,body.length);
    ReadResponse result=ReadResponse.serializer().deserialize(bufIn);
    if (result.isDigestQuery()) {
      digest=result.digest();
      isDigestQuery=true;
    }
 else {
      rows.add(result.row());
      endPoints.add(response.getFrom());
      key=result.row().key;
    }
  }
  if (isDigestQuery) {
    for (    Row row : rows) {
      if (!Arrays.equals(row.digest(),digest)) {
        String s=String.format("Mismatch for key %s (%s vs %s)",row.key,FBUtilities.bytesToHex(row.digest()),FBUtilities.bytesToHex(digest));
        throw new DigestMismatchException(s);
      }
    }
  }
  Row resolved=resolveSuperset(rows);
  for (int i=0; i < rows.size(); i++) {
    ColumnFamily diffCf=rows.get(i).diff(resolved);
    if (diffCf == null)     continue;
    RowMutation rowMutation=new RowMutation(table,key);
    rowMutation.add(diffCf);
    RowMutationMessage rowMutationMessage=new RowMutationMessage(rowMutation);
    ReadRepairManager.instance().schedule(endPoints.get(i),rowMutationMessage);
  }
  if (logger_.isDebugEnabled())   logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
  return resolved;
}
