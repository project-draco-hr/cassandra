{
  long startTime=System.currentTimeMillis();
  Row retRow=null;
  List<Row> rowList=new ArrayList<Row>();
  List<InetAddress> endPoints=new ArrayList<InetAddress>();
  String key=null;
  byte[] digest=new byte[0];
  boolean isDigestQuery=false;
  DataInputBuffer bufIn=new DataInputBuffer();
  for (  Message response : responses) {
    byte[] body=response.getMessageBody();
    bufIn.reset(body,body.length);
    ReadResponse result=ReadResponse.serializer().deserialize(bufIn);
    if (result.isDigestQuery()) {
      digest=result.digest();
      isDigestQuery=true;
    }
 else {
      rowList.add(result.row());
      endPoints.add(response.getFrom());
      key=result.row().key();
    }
  }
  if (isDigestQuery) {
    for (    Row row : rowList) {
      if (!Arrays.equals(row.digest(),digest)) {
        String s=String.format("Mismatch for key %s (%s vs %s)",row.key(),FBUtilities.bytesToHex(row.digest()),FBUtilities.bytesToHex(digest));
        throw new DigestMismatchException(s);
      }
    }
  }
  if (rowList.size() == 0) {
    return retRow;
  }
  retRow=new Row(key);
  for (int i=0; i < rowList.size(); i++) {
    retRow.repair(rowList.get(i));
  }
  for (int i=0; i < rowList.size(); i++) {
    Row diffRow=rowList.get(i).diff(retRow);
    if (diffRow == null)     continue;
    RowMutation rowMutation=new RowMutation(table,key);
    for (    ColumnFamily cf : diffRow.getColumnFamilies()) {
      rowMutation.add(cf);
    }
    RowMutationMessage rowMutationMessage=new RowMutationMessage(rowMutation);
    ReadRepairManager.instance().schedule(endPoints.get(i),rowMutationMessage);
  }
  if (logger_.isDebugEnabled())   logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
  return retRow;
}
