{
  long startTime=System.currentTimeMillis();
  List<ColumnFamily> versions=new ArrayList<ColumnFamily>();
  List<InetAddress> endpoints=new ArrayList<InetAddress>();
  DecoratedKey key=null;
  byte[] digest=new byte[0];
  boolean isDigestQuery=false;
  for (  Message response : responses) {
    byte[] body=response.getMessageBody();
    ByteArrayInputStream bufIn=new ByteArrayInputStream(body);
    ReadResponse result=ReadResponse.serializer().deserialize(new DataInputStream(bufIn));
    if (result.isDigestQuery()) {
      digest=result.digest();
      isDigestQuery=true;
    }
 else {
      versions.add(result.row().cf);
      endpoints.add(response.getFrom());
      key=result.row().key;
    }
  }
  if (isDigestQuery) {
    for (    ColumnFamily cf : versions) {
      if (!Arrays.equals(ColumnFamily.digest(cf),digest)) {
        String s=String.format("Mismatch for key %s (%s vs %s)",key,FBUtilities.bytesToHex(ColumnFamily.digest(cf)),FBUtilities.bytesToHex(digest));
        throw new DigestMismatchException(s);
      }
    }
  }
  ColumnFamily resolved=resolveSuperset(versions);
  maybeScheduleRepairs(resolved,table,key,versions,endpoints);
  if (logger_.isDebugEnabled())   logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
  return new Row(key,resolved);
}
