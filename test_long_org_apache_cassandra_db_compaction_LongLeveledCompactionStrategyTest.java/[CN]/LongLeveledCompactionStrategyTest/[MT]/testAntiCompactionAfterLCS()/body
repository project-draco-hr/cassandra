{
  testParallelLeveledCompaction();
  String ksname="Keyspace1";
  String cfname="StandardLeveled";
  Keyspace keyspace=Keyspace.open(ksname);
  ColumnFamilyStore store=keyspace.getColumnFamilyStore(cfname);
  WrappingCompactionStrategy strategy=((WrappingCompactionStrategy)store.getCompactionStrategy());
  Collection<SSTableReader> initialSSTables=store.getUnrepairedSSTables();
  assertEquals(store.getSSTables().size(),initialSSTables.size());
  CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes checker=new CheckThatSSTableIsReleasedOnlyAfterCompactionFinishes();
  store.getDataTracker().subscribe(checker);
  Range<Token> range=new Range<Token>(new BytesToken("110".getBytes()),new BytesToken("111".getBytes()),store.partitioner);
  List<Range<Token>> ranges=Arrays.asList(range);
  Refs<SSTableReader> refs=Refs.tryRef(initialSSTables);
  if (refs == null)   throw new IllegalStateException();
  long repairedAt=1000;
  CompactionManager.instance.performAnticompaction(store,ranges,refs,repairedAt);
  assertFalse("Anti-compaction released sstable from compacting set before compaction was finished",checker.isFailed());
  for (  SSTableReader sstable : store.getSSTables()) {
    assertFalse(sstable.isMarkedCompacted());
    assertEquals(1,sstable.selfRef().globalCount());
  }
  assertEquals(0,store.getDataTracker().getCompacting().size());
  LeveledCompactionStrategy lcs=(LeveledCompactionStrategy)strategy.getWrappedStrategies().get(1);
  for (  SSTableReader reader : initialSSTables) {
    Range<Token> sstableRange=new Range<Token>(reader.first.getToken(),reader.last.getToken());
    if (sstableRange.intersects(range)) {
      assertFalse(lcs.manifest.generations[reader.getSSTableLevel()].contains(reader));
    }
  }
}
